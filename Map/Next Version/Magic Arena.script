//Script version 2.116 (17 jan 2016)

const

//Skills cooldowns

  LANCE_ROAD_DELAY = 80;
  LANCE_FIELD_DELAY = 80;
  LANCE_WINE_DELAY = 250;

  BARB_ROAD_DELAY = 100;
  BARB_FIELD_DELAY = 170;
  BARB_WINE_DELAY = 350;

  XBOW_ROAD_DELAY = 90;
  XBOW_FIELD_DELAY = 160;
  XBOW_WINE_DELAY = 200;

  SWORD_ROAD_DELAY = 120;
  SWORD_FIELD_DELAY = 130;
  SWORD_WINE_DELAY = 250;

  PIKE_ROAD_DELAY = 150;
  PIKE_FIELD_DELAY = 170;
  PIKE_WINE_DELAY = 280;

  BOWMAN_ROAD_DELAY = 120;
  BOWMAN_FIELD_DELAY = 140;
  BOWMAN_WINE_DELAY = 250;

  AXE_ROAD_DELAY = 150;
  AXE_FIELD_DELAY = 180;
  AXE_WINE_DELAY = 1250;

  VAGA_ROAD_DELAY = 90;
  VAGA_FIELD_DELAY = 140;
  VAGA_WINE_DELAY = 600;

  WARRIOR_ROAD_DELAY = 110;
  WARRIOR_FIELD_DELAY = 160;
  WARRIOR_WINE_DELAY = 280;

  KNIGHT_ROAD_DELAY = 130;
  KNIGHT_FIELD_DELAY = 150;
  KNIGHT_WINE_DELAY = 180;

  ROGUE_ROAD_DELAY = 60;
  ROGUE_FIELD_DELAY = 90;
  ROGUE_WINE_DELAY = 0;

  ROGUE_TOTEM_DELAY = 0;
  ROGUE_FIREWORKS_DELAY = 0;
  ROGUE_REVENGE_DELAY = 0;
  ROGUE_MENTAL_DELAY = 0;

  SCOUT_ROAD_DELAY = 90;
  SCOUT_FIELD_DELAY = 150;
  SCOUT_WINE_DELAY = 350;

//Skills parameters

  TELEPORT_RADIUS = 5;
  SACRIFICIAL_RADIUS = 8;
  TOTEM_ADD_RADIUS = 7;
  MILIZOMBIE_RADIUS = 4;
  MAX_MILIZOMBIE = 100;
  IN_FEAR_RADIUS = 5;
  BOMB_RADIUS = 7;
  ROCKET_USAGE_RADIUS = 50;
  MIN_ROCKET_USAGE_RADIUS = 0;
  PRISON_USAGE_RADIUS = 6;
  PRISON_RADIUS = 3;
  GRAVITY_RADIUS1 = 5;
  FIRE_RADIUS = 6;
  SHOCK_RADIUS = 6;
  REGEN_RADIUS = 6;
  ARMOR_RADIUS = 7;
  ROPE_RADIUS = 5;
  ROPE_ALLY_RADIUS = 7;
  STEAL_RADIUS = 8;
  STONES_RADIUS = 7;
  VAMPIRE_RADIUS = 5;
  MIND_RADIUS = 4;
  SILENCE_SCOUT_RADIUS = 6;

  RAGE_RADIUS = 5;
  TOTEM_RADIUS = 4;
  CONCENTRATION_RADIUS = 9;
  VISE_RADIUS = 5;
  EXP_RADIUS = 6;
  GRAVITY_RADIUS = 5;
  FIREWORKS1_RADIUS = 5;
  FIREWORKS2_RADIUS = 4;
  SILENCE_RADIUS = 8;
  DEAFENING_RADIUS = 4;
  MENTAL_RADIUS = 3;
  POWER_RADIUS = 5;
  
  RAGE_CYCLES = 1;
  TOTEM_CYCLES = 5;
  CONCENTRATION_CYCLES = 1;
  VISE_CYCLES = 1;
  EXP_CYCLES = 1;
  GRAVITY_CYCLES = 1;
  FIREWORKS1_CYCLES = 1;
  FIREWORKS2_CYCLES = 1;
  DEAFENING_CYCLES = 1;
  SPURT_LENGTH = 12;
  BOOMERANG_LENGTH = 10;
  MENTAL_CYCLES = 1;
  MENTAL_DISTANCE = 8;
  TEN_K_SPEARS_WAVES = 1;
  POWER_CYCLES = 10;

//Skills speed

  XBOW_ROAD_SPEED = 4;
  XBOW_WINE_SPEED = 5;

  LANCE_ROAD_SPEED = 3;
  LANCE_WINE_SPEED = 15;

  BARB_ROAD_SPEED = 0.5;
  BARB_FIELD_SPEED = 1.6;
  BARB_WINE_SPEED = 0.3;

  SWORD_ROAD_SPEED = 0.75;

  PIKE_ROAD_SPEED = 1;
  PIKE_WINE_SPEED = 0.8;

  BOWMAN_ROAD_SPEED = 0.7;
  BOWMAN_WINE_SPEED = 4;

  AXE_ROAD_SPEED = 1;
  AXE_FIELD_SPEED = 2;

  VAGA_ROAD_SPEED = 0.75;
  VAGA_FIELD_SPEED = 1.5;

  WARRIOR_ROAD_SPEED = 2;
  WARRIOR_WINE_SPEED = 1.4;

  KNIGHT_FIELD_SPEED = 3;
  KNIGHT_WINE_SPEED = 3;

  ROGUE_ROAD_SPEED = 2;

  SCOUT_ROAD_SPEED = 0.8;

//Skills objects

  LANCE_OBJECT = 21;
  LANCE_OBJECT2 = 18;
  LANCE_OBJECT3 = 19;

  XBOW_OBJECT = 54;
  XBOW_OBJECT2 = 57;
  XBOW_OBJECT3 = 24;

  BARB_OBJECT = 214;
  BARB_OBJECT2 = 210;
  BARB_OBJECT3 = 220;
  BARB_OBJECT4 = 216;
  BARB_OBJECT5 = 218;

  SWORD_OBJECT = 68;
  SWORD_OBJECT1 = 70;

  PIKE_OBJECT = 13;
  PIKE_OBJECT2 = 45;
  PIKE_OBJECT3 = 46;
  PIKE_OBJECT4 = 47;
  PIKE_OBJECT5 = 16;
  PIKE_OBJECT6 = 41;
  PIKE_OBJECT7 = 42;
  PIKE_OBJECT8 = 43;
  PIKE_OBJECT9 = 14;
  PIKE_OBJ_STONE = 8;
  PIKE_OBJ_STONE1 = 61;

  BOWMAN_OBJECT = 58;
  BOWMAN_OBJECT2 = 55;
  BOWMAN_OBJECT3 = 50;
  BOWMAN_OBJECT4 = 24;
  BOWMAN_OBJECT5 = 215;
  BOWMAN_OBJECT6 = 3;
  BOWMAN_ROCKET = 0;
  BOWMAN_ROCKET2 = 24;
  
  AXE_OBJECT = 60;
  AXE_OBJECT2 = 23;
  AXE_OBJECT3 = 5;
  AXE_OBJECT4 = 6;

  VAGA_OBJECT = 7;
  VAGA_OBJECT2 = 196;
  VAGA_OBJECT3 = 62;
  VAGA_OBJECT4 = 60;
  VAGA_OBJECT5 = 6;
  VAGA_OBJECT6 = 73;
  VAGA_OBJECT7 = 58;
  VAGA_OBJECT8 = 59;

  SHIELD_OBJECT = 182;
  SHIELD_OBJECT2 = 183;
  SHIELD_OBJECT3 = 184;
  SHIELD_OBJECT4 = 185;
  SHIELD_OBJECT5 = 186;
  SHIELD_OBJECT6 = 187;
  SHIELD_OBJECT7 = 188;
  SHIELD_OBJECT8 = 189;

  WARRIOR_OBJECT = 18;
  WARRIOR_OBJECT2 = 21;
  WARRIOR_OBJECT3 = 24;
  WARRIOR_OBJECT4 = 4;
  WARRIOR_OBJECT5 = 59;
  WARRIOR_OBJECT6 = 58;

  KNIGHT_OBJECT = 62;
  KNIGHT_OBJECT2 = 12;
  KNIGHT_OBJECT3 = 69;
  KNIGHT_OBJECT4 = 181;

  ROGUE_OBJECT = 24;
  ROGUE_OBJECT2 = 192;
  ROGUE_OBJECT3 = 195;

  SCOUT_OBJECT = 8;
  SCOUT_OBJECT2 = 7;
  SCOUT_OBJECT3 = 211;
  SCOUT_OBJECT4 = 213;
  SCOUT_OBJECT5 = 19;
  SCOUT_OBJECT6 = 126;
  SCOUT_OBJECT7 = 112;

  CIRCLE_FILL_OBJ = 17;

//Runes

  RUNE_X = 35;
  RUNE_Y1 = 63;
  RUNE_Y2 = 86;
  RUNE_TIMER = 900;
  RUNE_ZOMBIE_LIFE = 1800;
  RUNE_REGEN_OBJ = 7;
  RUNE_DOUBLE_OBJ = 105;
  RUNE_ILLUSION_OBJ = 203;
  RUNE_IMMORTAL_OBJ = 63;
  RUNE_RECHARGE_OBJ = 88;
  RUNE_DOUBLE_TIME = 300;
  RUNE_IMMORTAL_TIME = 200;
  RUNE_ILLUSION_TIME = 1800;
  RUNE_RECHARGE_TIME = 600;

//Animation

  IMMORTAL_ANIMATION = 20;
  DOUBLE_ANIMATION = 28;
  SILENCE_ANIMATION = 14;
  FEAR_ANIMATION = 220;
  STUN_ANIMATION = 16;
  MIND_ANIMATION = 9;
  RECHARGE_ANIMATION = 0; 

//Player stats

  IMMORTAL_TIME = 60;
  RECHOICE_IMMORTAL_TIME = 30;
  STUNNED_TIME = 50;
  STUNNED_ANIMATION_TIME = 15;
  IN_FEAR_TIME = 80;
  START_HP = 10;
  MAX_HP = 12;
  CHOOSE_HERO_TIMER = 350;
  GAME_START_TIME = 440;
  ZOMBIE_STORM_TIME = 100;
  STORM_CHANCE = 0.7;
  PRISON_TIME = 60;
  CIRCLE_DEF_TIME = 6;
  WEREWOLF_TIME = 450;
  REGEN_TIME = 40;
  DELAY_OF_TURNING = 2;
  VAGA_DELAY_OF_TURNING = 10;
  REGEN_DELAY = 90;
  CONCENTRATION_TIME = 60;
  SHOCK_TIME = 20;
  SKILL_RESPAWN_TIME = 1;
  ARMOR_TIME = 50;
  ARMOR_DELAY = 12;
  ROPE_DELAY = 14;
  DEAFENING_TIME = 50;
  SPURT_TIME = 35;
  SPURT_AI_FACTOR = 8;
  SPURT_AI_RANDOM = 5;
  STOLEN_SKILL_TIME = 1200;
  CAPTURE_MIND_TIME = 200;
  TRACK_TIME = 70;
  TRACK_DELAY = 3;
  TRACK_FACTOR = 3;
  GRAVITY_MOVE_TIME = 20;
  SILENCE_SCOUT_TIME = 50;
  SILENCE_SCOUT_DELAY = 12;

//Game mechanics

  DESYNC_FACTOR = 1;
  RELIEF_CHANGE_FACTOR = 7;
  RELIEF_REGEN_TIME = 300;
  CLEANUP_TIME = 20;
  PLANT_TREES_TIME = 25;
  PLANT_TREES_FACTOR = 0.65;
  TREE_AGE1 = 1500;
  TREE_AGE2 = 3000;
  TREE_AGE3 = 4800;
  TREE_AGE4 = 7200;
  TREES_GROW_FACTOR = 20;
  AVOID_FACTOR = 3;
  RECHARGE_FACTOR = 0.25;
  ZOMBIE_STORM_FACTOR = 20;
  HEAL_CHECK_RADIUS = 4;
  HEAL_CHECK_TIME = 15;
  CLEAR_ARRAY_FACTOR = 5;
  DEBUG_MODE = True;
  CHANGE_RELIEF = True;
  MOVEMENT_DISTANCE = 3;
  MOVEMENT_FACTOR = 2;
  MAX_CIRCLES_AT_ONCE = 4;
  RECHOICE_TIME = 150;
  GAMEPLAY_STATUS_TIME = 75;
  AI_RUNE_CHECK_TIME = 25;
  STORM_CHECK_RADIUS = 6;
  TILES_RECHECK_TIME = 150;
  SKILL_CANCEL_OBJ = -2;
  REBORN_TIME = 50;
  BOWMAN_PRISON_AI_CHANCE = 0.9;
  EFFECT_CHECK_FACTOR = 7;
  FENCE_TIME = 10;

//Battlefield

  SPECTATORS = False;
  MIN_X = 12;
  MAX_X = 59;
  MIN_Y = 51;
  MAX_Y = 98;
  CENTERSCREEN_X = 17;
  CENTERSCREEN_Y = 17;
  TEMP_PLAYER = 11;

//Sound

  DOUBLE_KILL_CHECK_TIME = 75;
  TRIPLE_KILL_CHECK_TIME = 150;
  RAMPAGE_CHECK_TIME = 225;
  MAX_TIME_BETWEEN_KILLS = 75;
  KILLS_REFRESH_TIME = 60;


type
  aSkill = (sNone,
            sFieryLance, sTeleport, s10kSpears,
            sCrackingEarth, sWaveOfRage, sTotem,
            sSpikedEarth, sZombieSummon, sFear,
            sAccurateShot, sSuddenDeath, sSniperShot,
            sRocket, sPrison, sRevengeFromNowhere,
            sGravity, sDeadlyFireworks, sWerewolf,
            sDisorientation, sTrack, sRegen,
            sViseOfDeath, sSacrificialTeleport, sConcentration,
            sFierySnake, sSturdyArmor, sPowerWithin,
            sRopesOfDeath, sDeafeningClatter, sRagingSpurt,
            sMentalBurst, sSteal, sUniversal,
            sBoomerang, sSilence, sMind);


type
  aPlayer = Record
    SpawnX: Integer;
    SpawnY: Integer;
    Hero: Integer;
    HeroType: Integer;
    HeroMindType: Integer;
    TempHeroMindType: Integer;
    HeroImmortal: Boolean;
    HeroImmortalTime: Integer;
    HeroChosen: Boolean;
    HP: Integer;
    RoadSkillDelay: Integer;
    FieldSkillDelay: Integer;
    WineSkillDelay: Integer;
    Direction: Integer;
    TribuneX: Integer;
    TribuneY: Integer;
    HeroStunnedTime: Integer;
    HeroStunned: Boolean;
    HeroInFearTime: Integer;
    HeroInFear: Boolean;
    HeroFearGiver: Integer;
    ZombiePlayer: Integer;
    RoadPlayer: Integer;
    DefenceTime: Integer;
    HeroPrisoned: Boolean;
    HeroPrisonedTime: Integer;
    WerewolfTime: Integer;
    VagaX: Integer;
    VagaY: Integer;
    VagaDir: Integer;
    VagaAppearTime: Integer;
    VagaAppearTimeBack: Integer;
    RegenDelay: Integer;
    ClearPikeObjTime: Integer;
    GravityX: Integer;
    GravityY: Integer;
    RespawnCheckTime: Integer;
    DDTime : Integer;
    DD: Boolean;
    InIllusion: Boolean;
    PlayersTeam: Integer;
    TempPlayersTeam: Integer;
    CastingSkill: Boolean;
    SkillTime: Integer;
    SkillCastX: Integer;
    SkillCastY: Integer;
    SkillCastDir: Integer;
    SkillCastRespawnTime: Integer;
    ArmorStartTime: Integer;
    ArmorGiver: Integer;
    HeroSilent: Boolean;
    HeroSilentTime: Integer;
    HeroSilentStartTime: Integer;
    AIChoiceTime: Integer;
    RopeUnitDir: Integer;
    RopeTime: Integer;
    RopeAttacker: Integer;
    RopeDX: Integer;
    RopeDY: Integer;
    Preparing: Boolean;
    PreparingTime: Integer;
    ReCharge: Boolean;
    ReChargeTime: Integer;
    TempReCharge: Boolean;
    TempReChargeTime: Integer;
    LastUsedSkill: aSkill;
    StolenSkill: aSkill;
    StolenSkillName: ANSIString;
    StolenSkillTime: Integer;
    TempStolenSkill: aSkill;
    TempStolenSkillName: ANSIString;
    TempStolenSkillTime: Integer;
    TempHeroType: Integer;
    MindTime: Integer;
    MindTime2: Integer;
    CaptureMind: Boolean;
    CaptureMindTime: Integer;
    MindStunned: Boolean;
    StunnedMindTime: Integer;
    MindAppearTime: Integer;
    MindAppearTimeBack: Integer;
    MindX: Integer;
    MindY: Integer;
    MindDir: Integer;
    MindX2: Integer;
    MindY2: Integer;
    MindDir2: Integer;
    PikeAppearTime: Integer;
    PikeX: Integer;
    PikeY: Integer;
    PikeDir: Integer;
    KnightAppearTime: Integer;
    KnightX: Integer;
    KnightY: Integer;
    KnightDir: Integer;
    TempHero: Integer;
    TempX: Integer;
    TempY: Integer;
    SkillDirection: Integer;
    TrackStartTime: Integer;
    TrackStopTime: Integer;
    SettingTrack: Boolean;
    ReChoice: Boolean;
    ReChoiceTime: Integer;
    ReChoiceAllowed: Boolean;
    PlayerStatus: ANSIString;
    PlayerStatusTime: Integer;
    Kills: Integer;
    MovedByGravity: Boolean;
    GravityTime: Integer;
    ScoutSilenceGiver: Integer;
    ScoutSilenceStartTime: Integer;
    TotalKills: Integer;
    KillTimes: array of Integer;
    KillsCountTime: Integer;
    DoubleKill: Boolean;
    TripleKill: Boolean;
    Rampage: Boolean;
    GravityUser: Integer;
    MovedByRopes: Boolean;
    SpurtStartTime: Integer;
    CurrentSpurtLength: Integer;
    RebornTime: Integer;
    HeroReborn: Boolean;
    MovedToTribune: Boolean;
    PowerWithinCircleCycles: Integer;
    PowerWithinCircleTime: Integer;
    FireworkTime: Integer;
    FireworkX: Integer;
    FireworkY: Integer;
    CrackingStartTime: Integer;
  end;


type
  aZombie = Record
    Owner: Integer;
    ID: Integer;
    Hunger: Integer;
  end;


type
  aCircle = Record
    AddTime: Integer;
    X: Integer;
    Y: Integer;
    Radius: Integer;
    Obj: Integer;
  end;


type
  aTile = Record
    X: Integer;
    Y: Integer;
    Owner: Integer;
    Skill: aSkill;
    Relief: Integer;
    ReliefRefreshTime: Integer;
    ObjectRefreshTime: Integer;
    TreeTime: Integer;
    TileType: Integer;
    TileDirection: Integer;
  end;


var
  I, J, K: Integer;
  Players: array[0..11] of aPlayer;
  ClearTilesRoadTimes, SetTilesRoadTimes, TilesRoadX, TilesRoadY, TilesRoadObjects,
  ClearTilesFieldTimes, SetTilesFieldTimes, TilesFieldX, TilesFieldY, TilesFieldObjects,
  ClearTilesWineTimes, SetTilesWineTimes, TilesWineX, TilesWineY, TilesWineObjects: array[0..11] of array of Integer;
  RageCircles, TotemCircles, ConcentrationCircles, ViseCircles, ExpCircles,
  FireworksCircles1, FireworksCircles2, FireworksCircles3, FireworksCircles4, 
  FireworksCircles5, KnightCircles, RogueCircles, StolenRogueCircles, PowerWithinCircles: array[0..11] of array[0..MAX_CIRCLES_AT_ONCE - 1] of array of aCircle;
  GravityCircles: array[0..11] of array of aCircle;
  RageCirclesCounter, TotemCirclesCounter, ConcentrationCirclesCounter, ViseCirclesCounter, ExpCirclesCounter,
  FireworksCircles1Counter, FireworksCircles2Counter, FireworksCircles3Counter, FireworksCircles4Counter, 
  FireworksCircles5Counter, KnightCirclesCounter, RogueCirclesCounter, StolenRogueCirclesCounter, PowerWithinCirclesCounter: array[0..11] of Integer;
  TilesRoadLength, TilesFieldLength, TilesWineLength: array[0..11] of Integer;
  RageCirclesLength, TotemCirclesLength, ConcentrationCirclesLength, ViseCirclesLength, ExpCirclesLength,
  FireworksCircles1Length, FireworksCircles2Length, FireworksCircles3Length, 
  FireworksCircles4Length, FireworksCircles5Length, KnightCirclesLength, RogueCirclesLength, StolenRogueCirclesLength, PowerWithinCirclesLength: array[0..11] of array[0..MAX_CIRCLES_AT_ONCE - 1] of Integer;
  GravityCirclesLength, TimeToClearGravityArray: array[0..11] of Integer;
  TimeToClearRageArray, TimeToClearTotemArray, TimeToClearConcentrationArray,
  TimeToClearViseArray, TimeToClearExpArray, TimeToClearFireworks1Array,
  TimeToClearFireworks2Array, TimeToClearFireworks3Array, TimeToClearFireworks4Array, TimeToClearFireworks5Array,
  TimeToClearKnightArray, TimeToClearRogueArray, TimeToClearStolenRogueArray, TimeToClearPowerWithinArray: array[0..11] of array[0..MAX_CIRCLES_AT_ONCE - 1] of Integer;
  PikeObjects, ShieldObjects: array[0..7] of Integer;
  Tiles: array[MIN_X..MAX_X] of array[MIN_Y..MAX_Y] of aTile;
  TeamChoice: array[0..1] of ANSIString;
  TeamInfo, Scores: array[0..1] of ANSIString;
  ClearRoadTilesArrayTime, ClearFieldTilesArrayTime, ClearWineTilesArrayTime: array[0..11] of Integer;
  RuneTime: Integer;
  M, M2: array[0..7] of Integer;
  ZomboHero: array[0..7] of array[0..3] of Integer;
  AISoldiers: array of Integer;
  SpurtTimes, SpurtX, SpurtY, SpurtDir: array[0..11] of array[0..SPURT_LENGTH - 1] of Integer;
  RUNE_Y: Integer;
  OldX, OldY, NewX, NewY: array[0..11] of Integer;
  PlayersLeft, SortedPlayersLeft, PlayersRight, SortedPlayersRight: array of Integer;
  Zombies: array of aZombie;
  LastAttacker, LastAttackerUnitType: Integer;
  FirstBlood: Boolean;
  RuneTaken: Boolean;
  RuneObject: Integer;


function InRange(Value, Min, Max: Integer): Boolean;
begin
  Result := (Value >= Min) and (Value <= Max);
end;


function TileOnBattlefield(X, Y: Integer): Boolean;
begin
  if X <= 0 then
    Exit;
  if Y <= 0 then
    Exit;
  Result := (InRange(X, MIN_X, MAX_X))
  and (InRange(Y, MIN_Y, MAX_Y))
  and (States.MapTileType(X, Y) <> 202);
end;


function CanPlaceObject(X, Y: Integer): Boolean;
begin
  if X <= 0 then
    Exit;
  if Y <= 0 then
    Exit;

  Result := (TileOnBattlefield(X, Y))
  and (States.MapTileObject(X, Y) <> BARB_OBJECT3)
  and (States.MapTileObject(X, Y) <> BOWMAN_ROCKET)
  and (States.MapTileObject(X, Y) <> BOWMAN_OBJECT5)
  and (not InRange(States.MapTileObject(X, Y), SHIELD_OBJECT, SHIELD_OBJECT8))
  and (not InRange(States.MapTileObject(X, Y), SWORD_OBJECT, VAGA_OBJECT6));

end;


procedure KillUnneeded;
var
  Units: array of Integer;
begin
  for J := 0 to 7 do
  begin
    if States.PlayerEnabled(J) then
      Units := States.PlayerGetAllUnits(J);
    for K := 0 to Length(Units) - 1 do
      Actions.UnitKill(Units[K], True);
  end;

  Actions.UnitKill(States.UnitAt(26, 9), True);
  Actions.UnitKill(States.UnitAt(26, 11), True);
  Actions.UnitKill(States.UnitAt(26, 13), True);

end;


procedure AutoFeed;
var
  UnitsToFeed: array of Integer;
begin
  for I := 0 to 8 do
  begin
    if States.PlayerEnabled(I) then
      UnitsToFeed := States.PlayerGetAllUnits(I);
    for K := 0 to Length(UnitsToFeed) - 1 do
      Actions.UnitHungerSet(UnitsToFeed[K], States.UnitMaxHunger);
  end;
end;


procedure CheckTilesInfo;
var
  aX, aY: Integer;
begin
  for aX := MIN_X to MAX_X do
  for aY := MIN_Y to MAX_Y do
  begin
    Tiles[aX][aY].X := aX;
    Tiles[aX][aY].Y := aY;
    Tiles[aX][aY].Owner := -1;
    Tiles[aX][aY].Relief := States.MapTileHeight(aX, aY);
    Tiles[aX][aY].ReliefRefreshTime := 0;
    Tiles[aX][aY].ObjectRefreshTime := 0;
    Tiles[aX][aY].Skill := sNone;
    Tiles[aX][aY].TreeTime := 0;
    Tiles[aX][aY].TileType := States.MapTileType(aX, aY);
    Tiles[aX][aY].TileDirection := States.MapTileRotation(aX, aY);
  end;
end;


procedure RegenRelief;
var
  aX, aY: Integer;
begin

  if not CHANGE_RELIEF then
    Exit;

  for aX := MIN_X to MAX_X do
  for aY := MIN_Y to MAX_Y do
    if (States.MapTileHeight(aX, aY) <> Tiles[aX][aY].Relief)
    and (States.GameTime > Tiles[aX][aY].ReliefRefreshTime) then
      Actions.MapTileHeightSet(aX, aY, Tiles[aX][aY].Relief);

end;


procedure CheckTileCleanup;
var
  aX, aY, aObj: Integer;
begin

  for aX := MIN_X to MAX_X do
  for aY := MIN_Y to MAX_Y do
  begin
    aObj := States.MapTileObject(aX, aY);
    if (aObj <> 255)
    and (not InRange(aObj, 149, 172))
    and (TileOnBattlefield(aX, aY))
    and (States.GameTime > Tiles[aX][aY].ObjectRefreshTime)
    and (InRange(Tiles[aX][aY].Owner, 0, 11)) then
      if States.PlayerIsAI(Tiles[aX][aY].Owner) then
        Actions.MapTileObjectSet(aX, aY, 255);
  end;

end;


procedure AIHeroChoice(P: Integer);
begin
  case States.KaMRandomI(7) of
    0: Players[P].HeroType := 16;
    1: Players[P].HeroType := 23;
    2: Players[P].HeroType := 18;
    3: Players[P].HeroType := 19;
    4: Players[P].HeroType := 26;
    5: Players[P].HeroType := 17;
    6: Players[P].HeroType := 22;
  end;

  Players[P].TempHeroType := Players[P].HeroType;
  Players[P].HeroChosen := True;
  Actions.GiveUnit(8, 13, 13, 14, 4);

  if InRange(P, 0, 3) then
    TeamChoice[0] := TeamChoice[0] + '|[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[] <$32> ' + States.UnitTypeName(Players[P].HeroType);
  if InRange(P, 4, 7) then
    TeamChoice[1] := TeamChoice[1] + '|[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[] <$32> ' + States.UnitTypeName(Players[P].HeroType);

end;


procedure SetScreen;
begin
  for I := 0 to 7 do
    if States.PlayerEnabled(I) then
    begin
      Actions.CinematicStart(I);
      Actions.CinematicPanTo(I, CENTERSCREEN_X, CENTERSCREEN_Y, 0);
      Actions.CinematicEnd(I);
    end;
end;


procedure SortScoresLeft;
var
  Temp: Integer;
begin
  if Length(PlayersLeft) <= 0 then
    Exit;

  for I := Length(PlayersLeft) - 1 downto 1 do
    if Players[SortedPlayersLeft[I]].Kills > Players[SortedPlayersLeft[I - 1]].Kills then
      begin
        Temp := SortedPlayersLeft[I - 1];
        SortedPlayersLeft[I - 1] := SortedPlayersLeft[I];
        SortedPlayersLeft[I] := Temp;
      end;
end;


procedure SortScoresRight;
var
  Temp: Integer;
begin
  if Length(PlayersRight) <= 0 then
    Exit;

  for I := Length(PlayersRight) - 1 downto 1 do
    if Players[SortedPlayersRight[I]].Kills > Players[SortedPlayersRight[I - 1]].Kills then
      begin
        Temp := SortedPlayersRight[I - 1];
        SortedPlayersRight[I - 1] := SortedPlayersRight[I];
        SortedPlayersRight[I] := Temp;
      end;
end;


procedure OnMissionStart;
begin

  for I := 0 to 3 do
    if States.PlayerEnabled(I) then
    begin
      SetLength(PlayersLeft, Length(PlayersLeft) + 1);
      PlayersLeft[Length(PlayersLeft) - 1] := I;
      SetLength(SortedPlayersLeft, Length(SortedPlayersLeft) + 1);
      SortedPlayersLeft[Length(SortedPlayersLeft) - 1] := I;
    end;

  for I := 4 to 7 do
    if States.PlayerEnabled(I) then
    begin
      SetLength(PlayersRight, Length(PlayersRight) + 1);
      PlayersRight[Length(PlayersRight) - 1] := I;
      SetLength(SortedPlayersRight, Length(SortedPlayersRight) + 1);
      SortedPlayersRight[Length(SortedPlayersRight) - 1] := I;
    end;

  AISoldiers := States.PlayerGetAllGroups(8);

  if States.KaMRandom > 0.5 then
    RUNE_Y := RUNE_Y1
  else
    RUNE_Y := RUNE_Y2;

  CheckTilesInfo;

  RuneTaken := True;
  RuneObject := 255;

  FirstBlood := False;

  LastAttacker := -1;
  LastAttackerUnitType := -1;

  PikeObjects[0] := PIKE_OBJECT;
  PikeObjects[1] := PIKE_OBJECT2;
  PikeObjects[2] := PIKE_OBJECT3;
  PikeObjects[3] := PIKE_OBJECT4;
  PikeObjects[4] := PIKE_OBJECT5;
  PikeObjects[5] := PIKE_OBJECT6;
  PikeObjects[6] := PIKE_OBJECT7;
  PikeObjects[7] := PIKE_OBJECT8;

  ShieldObjects[0] := SHIELD_OBJECT;
  ShieldObjects[1] := SHIELD_OBJECT2;
  ShieldObjects[2] := SHIELD_OBJECT3;
  ShieldObjects[3] := SHIELD_OBJECT4;
  ShieldObjects[4] := SHIELD_OBJECT5;
  ShieldObjects[5] := SHIELD_OBJECT6;
  ShieldObjects[6] := SHIELD_OBJECT7;
  ShieldObjects[7] := SHIELD_OBJECT8;

  for I := 0 to 11 do
  for K := 0 to 11 do
  begin
    if (States.PlayerEnabled(I))
    and (States.PlayerEnabled(K))
    and (I <> K) then
    begin
      Actions.PlayerShareFog(I, K, False);
      Actions.PlayerShareFog(K, I, False);
    end;
  end;

  for I := 0 to 7 do
  for K := 0 to 3 do
    ZomboHero[I][K] := -1;

  for I := 0 to 3 do
    if States.PlayerEnabled(I) then
    begin
      Actions.PlayerAllianceChange(I, 11, True, True);
      Actions.PlayerAllianceChange(11, I, False, False);
    end;

  for I := 4 to 7 do
    if States.PlayerEnabled(I) then
    begin
      Actions.PlayerAllianceChange(I, 10, True, True);
      Actions.PlayerAllianceChange(10, I, False, False);
    end;

  for I := 4 to 7 do
    if States.PlayerEnabled(I) then
      Actions.PlayerAllianceChange(I, 8, True, True);

  KillUnneeded;

  AutoFeed;

  RuneTime := RUNE_TIMER;

  Actions.ShowMsg(-1, '<$0>');

  for I := 0 to 7 do
  for K := 0 to 7 do
  begin
    if (States.PlayerEnabled(I))
    and (States.PlayerEnabled(K))
    and (I <> K) then
    begin
      Actions.PlayerAllianceChange(I, K, True, True);
      Actions.PlayerAllianceChange(K, I, True, True);
    end;
  end;

  for I := 0 to 11 do
  for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
  begin
    RageCirclesLength[I][K] := 0;
    TotemCirclesLength[I][K] := 0;
    ConcentrationCirclesLength[I][K] := 0;
    ViseCirclesLength[I][K] := 0;
    ExpCirclesLength[I][K] := 0;
    FireworksCircles1Length[I][K] := 0;
    FireworksCircles2Length[I][K] := 0;
    FireworksCircles3Length[I][K] := 0;
    FireworksCircles4Length[I][K] := 0;
    FireworksCircles5Length[I][K] := 0;
    KnightCirclesLength[I][K] := 0;
    RogueCirclesLength[I][K] := 0;
    StolenRogueCirclesLength[I][K] := 0;
    PowerWithinCirclesLength[I][K] := 0;
  end;

  for I := 0 to 11 do
  begin
    ClearRoadTilesArrayTime[I] := -1;
    ClearFieldTilesArrayTime[I] := -1;
    ClearWineTilesArrayTime[I] := -1;
    TilesRoadLength[I] := 0;
    TilesFieldLength[I] := 0;
    TilesWineLength[I] := 0;
    RageCirclesCounter[I] := -1;
    TotemCirclesCounter[I] := -1;
    ConcentrationCirclesCounter[I] := -1;
    ViseCirclesCounter[I] := -1;
    ExpCirclesCounter[I] := -1;
    FireworksCircles1Counter[I] := -1;
    FireworksCircles2Counter[I] := -1;
    FireworksCircles3Counter[I] := -1;
    FireworksCircles4Counter[I] := -1;
    FireworksCircles5Counter[I] := -1;
    KnightCirclesCounter[I] := -1;
    RogueCirclesCounter[I] := -1;
    StolenRogueCirclesCounter[I] := -1;
    PowerWithinCirclesCounter[I] := -1;
  end;

  for I := 8 to 9 do
    Players[I].PlayersTeam := -1;

  Players[10].PlayersTeam := 0;

  Players[11].PlayersTeam := 1;

  for I := 0 to 7 do
    if States.PlayerEnabled(I) then
      Actions.FogCoverAll(I);

  for I := 0 to 7 do
    if States.PlayerEnabled(I) then
      Actions.FogRevealRect(I, 4, 4, 30, 30);

  for I := 0 to 7 do
  begin
    with Players[I] do
    begin
      Hero := -1;
      HeroType := -1;
      HeroImmortal := False;
      HeroChosen := False;
      HP := START_HP;
      RoadSkillDelay := 0;
      FieldSkillDelay := 0;
      WineSkillDelay := 0;
      HeroImmortalTime := 0;
      HeroStunnedTime := 0;
      HeroStunned := False;
      HeroInFearTime := 0;
      HeroInFear := False;
      HeroFearGiver := -1;
      DefenceTime := 0;
      HeroPrisoned := False;
      HeroPrisonedTime := 0;
      WerewolfTime := 0;
      VagaX := 0;
      VagaY := 0;
      VagaAppearTime := 0;
      VagaAppearTimeBack := 0
      VagaDir := 0;
      RegenDelay := 0;
      ClearPikeObjTime := 0;
      GravityX := 0;
      GravityY := 0;
      RespawnCheckTime := -1;
      DDTime := 0;
      DD := False;
      InIllusion := False;
      CastingSkill := False;
      SkillTime := 0;
      SkillCastX := 0;
      SkillCastY := 0;
      SkillCastDir := 0;
      SkillCastRespawnTime := 0;
      ArmorStartTime := 0;
      ArmorGiver := -1;
      HeroSilent := False;
      HeroSilentTime := 0;
      HeroSilentStartTime := 0;
      AIChoiceTime := 10 + States.KaMRandomI(100) + States.KaMRandomI(200);
      RopeUnitDir := -1;
      RopeAttacker := -1;
      RopeTime := -1;
      RopeDX := -1;
      RopeDY := -1;
      Preparing := False;
      PreparingTime := 0;
      ReCharge := False;
      ReChargeTime := 0;
      TempReCharge := False;
      TempReChargeTime := 0;
      LastUsedSkill := sNone;
      StolenSkill := sNone;
      StolenSkillName := '<$57>';
      TempHeroType := -1;
      StolenSkillTime := 0;
      MindTime := 0;
      MindTime2 := 0;
      CaptureMind := False;
      CaptureMindTime := 0;
      MindStunned := False;
      StunnedMindTime := 0;
      HeroMindType := -1;
      TempHeroMindType := -1;
      TempStolenSkill := sNone;
      TempStolenSkillName := '';
      TempStolenSkillTime := 0;
      TempPlayersTeam := -1;
      MindAppearTime := 0;
      MindAppearTimeBack := 0;
      MindX := 0;
      MindY := 0;
      MindDir := 0;
      MindX2 := 0;
      MindY2 := 0;
      MindDir2 := 0;
      PikeAppearTime := 0;
      PikeX := 0;
      PikeY := 0;
      PikeDir := 0;
      KnightAppearTime := 0;
      KnightX := 0;
      KnightY := 0;
      KnightDir := 0;
      TempHero := -1;
      TempX := 2 + 2 * I;
      TempY := 2;
      SkillDirection := -1;
      TrackStartTime := 0;
      TrackStopTime := 0;
      SettingTrack := False;
      ReChoice := False;
      ReChoiceTime := 0;
      ReChoiceAllowed := True;
      Kills := 0;
      PlayerStatus := '';
      PlayerStatusTime := 0;
      MovedByGravity := False;
      GravityTime := 0;
      ScoutSilenceStartTime := 0;
      ScoutSilenceGiver := -1;
      TotalKills := 0;
      KillsCountTime := KILLS_REFRESH_TIME;
      DoubleKill := False;
      TripleKill := False;
      Rampage := False;
      GravityUser := -1;
      MovedByRopes := False;
      SpurtStartTime := 0;
      CurrentSpurtLength := 0;
      RebornTime := 0;
      HeroReborn := False;
      MovedToTribune := False;
      PowerWithinCircleCycles := 0;
      PowerWithinCircleTime := 0;
      FireworkTime := 0;
      FireworkX := 0;
      FireworkY := 0;
      CrackingStartTime := 0;
    end;
  end;

  for I := 0 to 3 do
  begin
    with Players[I] do
    begin
      SpawnX := 19;
      SpawnY := 58 + I * 11;
      Direction := 2;
      TribuneY := 3;
      TribuneX := 43 + 2 * I;
      ZombiePlayer := 10;
      RoadPlayer := 8;
      PlayersTeam := 0;
    end;
  end;

  for I := 4 to 7 do
  begin
    with Players[I] do
    begin
      SpawnX := 52;
      SpawnY := 58 + ((I - 4) * 11);
      Direction := 6;
      TribuneY := 26;
      TribuneX := 55 + ((I - 4) * 2);
      ZombiePlayer := 11;
      RoadPlayer := 9;
      PlayersTeam := 1;
    end;
  end;

end;


function RuneType: Integer;
begin
  case States.KaMRandomI(15) of
    0..2:    Result := RUNE_REGEN_OBJ;
    3..5:    Result := RUNE_DOUBLE_OBJ;
    6..8:    Result := RUNE_ILLUSION_OBJ;
    9..11:   Result := RUNE_IMMORTAL_OBJ;
    12..14:  Result := RUNE_RECHARGE_OBJ;
  end;
end;


function TileOnRuneSpawn(X, Y: Integer): Boolean;
begin
  if X <= 0 then
    Exit;
  if Y <= 0 then
    Exit;

  Result := (X = RUNE_X)
  and (Y = RUNE_Y);

end;


procedure CheckRuneTime;
begin
  if RuneTime > 0 then
    RuneTime := RuneTime - 1;
  if RuneTime = 0 then
  begin
    if States.KaMRandomI(10) > 4 then
      RUNE_Y := RUNE_Y1
    else
      RUNE_Y := RUNE_Y2;
    Actions.MapTileObjectSet(RUNE_X, RUNE_Y1, 255);
    Actions.MapTileObjectSet(RUNE_X, RUNE_Y2, 255);
    Actions.MapTileObjectSet(RUNE_X, RUNE_Y, RuneType);
    RuneObject := RuneType;
    RuneTaken := False;
    Actions.PlayWAV(-1, 'Rune', 1);
    RuneTime := RUNE_TIMER;
  end;
end;


procedure CheckRuneCleanup;
begin
  if States.MapTileObject(RUNE_X, RUNE_Y) = BARB_OBJECT3 then
    RuneTaken := True;
  if (not RuneTaken)
  and (States.MapTileObject(RUNE_X, RUNE_Y) <> RuneObject) then
    Actions.MapTileObjectSet(RUNE_X, RUNE_Y, RuneObject);
end;


procedure GetRuneEffect(P, aRune: Integer);
begin

  if RuneTaken then
    Exit;

  case aRune of

    RUNE_REGEN_OBJ:
      if (not Players[P].MindStunned)
      and (not Players[P].CaptureMind) then
        if States.GameTime > Players[P].RegenDelay then
          if Players[P].HP < MAX_HP then
          begin
            Players[P].HP := Players[P].HP + 1;
            Players[P].RegenDelay := States.GameTime + REGEN_DELAY;
            RuneTaken := True;
            Actions.MapTileObjectSet(RUNE_X, RUNE_Y, 255);
          end;

    RUNE_DOUBLE_OBJ:
    begin
      Players[P].DD := True;
      Players[P].DDTime := States.GameTime + RUNE_DOUBLE_TIME;
      RuneTaken := True;
      Actions.MapTileObjectSet(RUNE_X, RUNE_Y, 255);
    end;

    RUNE_ILLUSION_OBJ:
      for I := 0 to 3 do
      begin
        ZomboHero[P][I] := Actions.GiveGroup(Players[P].ZombiePlayer, Players[P].HeroType, RUNE_X + States.KaMRandomI(5) - States.KaMRandomI(5), RUNE_Y + States.KaMRandomI(5) - States.KaMRandomI(5), States.KaMRandomI(8), 1, 1);
        SetLength(Zombies, Length(Zombies) + 1);
        Zombies[Length(Zombies) - 1].Owner := P;
        Zombies[Length(Zombies) - 1].ID := States.GroupMember(ZomboHero[P][I], 0);
        Actions.GroupHungerSet(ZomboHero[P][I], RUNE_ZOMBIE_LIFE);
        RuneTaken := True;
        Actions.MapTileObjectSet(RUNE_X, RUNE_Y, 255);
      end;

    RUNE_IMMORTAL_OBJ:
    begin
      Players[P].HeroImmortal := True;
      Players[P].HeroImmortalTime := States.GameTime + RUNE_IMMORTAL_TIME;
      RuneTaken := True;
      Actions.MapTileObjectSet(RUNE_X, RUNE_Y, 255);
    end;

    RUNE_RECHARGE_OBJ:
    begin
      Players[P].ReCharge := True;
      Players[P].ReChargeTime := States.GameTime + RUNE_RECHARGE_TIME;
      Players[P].RoadSkillDelay := 0;
      Players[P].FieldSkillDelay := 0;
      Players[P].WineSkillDelay := 0;
      RuneTaken := True;
      Actions.MapTileObjectSet(RUNE_X, RUNE_Y, 255);
    end;

  end;

end;


procedure CheckStolenSkillTime(P: Integer);
begin
  if Players[P].StolenSkillTime = 0 then
  begin
    Players[P].StolenSkill := sNone;
    Players[P].StolenSkillName := '<$57>';
  end;

  if Players[P].StolenSkillTime > 0 then
    Players[P].StolenSkillTime := Players[P].StolenSkillTime - 1;
end;


function HPColor(P: Integer): ANSIString;
begin
  case Players[P].HP of
    9..20: Result := '[$00FF00]';
    7..8:  Result := '[$32CD9B]';
    5..6:  Result := '[$00FFFF]';
    3..4:  Result := '[$008CFF]';
    1, 2:  Result := '[$0050FF]'
    else   Result := '[$000000]';
  end;
end;


function KillsColor(P: Integer): ANSIString;
begin
  case Players[P].Kills of
    20..24:  Result := '[$0045FF]';
    15..19:  Result := '[$00A5FF]';
    10..14:  Result := '[$00D7FF]';
    5..9:    Result := '[$00FFFF]';
    0..4:    Result := '[$FFFFFF]'
    else     Result := '[$0000FF]';
  end;
end;


function ReChoiceColor(P: Integer): ANSIString;
begin
  if Players[P].ReChoiceAllowed then
    Result := '[$00FF00]'
  else
    Result := '[$0000FF]';
end;


function GameplayStatus(P: Integer): ANSIString;
begin
  if Players[P].PlayerStatusTime - States.GameTime > 0 then
    Result := '||' + Players[P].PlayerStatus

  else

    Result := '';
end;


function RogueStatus(P: Integer): ANSIString;
begin

  if Players[P].HeroType <> 25 then
    Result := ''

  else

  begin

  if Players[P].StolenSkillTime > 0 then
    Result := '|[$56BAC2]<$59>[] |([$EBAEBA]' + Players[P].StolenSkillName + '[]) [$56BAC2]<$60>[] ' + IntToStr(Players[P].StolenSkillTime/10) + '[$56BAC2]. |<$61>[]'

  else

    Result := '';

  end;

end;


function RebornStatus(P: Integer): ANSIString;
begin
  if Players[P].RebornTime - States.GameTime > 0 then
    Result := '|[$BAECDA]<$83>[] (' + IntToStr((Players[P].RebornTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function FieryTrackStatus(P: Integer): ANSIString;
begin
  if Players[P].SettingTrack then
    Result := '|[$1528FE]<$23>[] (' + IntToStr((Players[P].TrackStopTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function DDStatus(P: Integer): ANSIString;
begin
  if Players[P].DDTime - States.GameTime > 0 then
    Result := '|[$A67F10]<$44>[] (' + IntToStr((Players[P].DDTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function IllusionStatus(P: Integer): ANSIString;
begin
  if Players[P].InIllusion then
    Result := '|[$FCA986]<$43>[]'

  else

    Result := '';
end;


function RegenStatus(P: Integer): ANSIString;
begin
  if Players[P].RegenDelay - States.GameTime > 0 then
    Result := '|[$25FF10]<$1>[] (<$7> ' + IntToStr((Players[P].RegenDelay - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function StunnedStatus(P: Integer): ANSIString;
begin
  if Players[P].HeroStunned
  and not (Players[P].MindStunned) then
    Result := '|[$19A5DF]<$2>[] (' + IntToStr((Players[P].HeroStunnedTime - States.GameTime)/10) + ')'

  else

    Result := '';

  if Players[P].Preparing then
    Result := '';

end;


function FearStatus(P: Integer): ANSIString;
begin
  if Players[P].HeroInFear then
    Result := '|[$52AADF]<$3>[] (' + IntToStr((Players[P].HeroInFearTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function ImmortalStatus(P: Integer): ANSIString;
begin
  if (Players[P].HeroImmortal)
  and not (Players[P].CaptureMind) then
    Result := '|[$1515DF]<$5>[] (' + IntToStr((Players[P].HeroImmortalTime - States.GameTime)/10) + ')'

  else

    Result := '';

  if Players[P].Preparing then
    Result := '';

end;


function PrisonedStatus(P: Integer): ANSIString;
begin
  if Players[P].HeroPrisoned then
    Result := '|[$51AFEE]<$4>[]'

  else

    Result := '';
end;


function WerewolfStatus(P: Integer): ANSIString;
begin
  if Players[P].WerewolfTime > States.GameTime then
    Result := '|[$5A6FAE]<$6>[] (' + IntToStr((Players[P].WerewolfTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function SilenceStatus(P: Integer): ANSIString;
begin
  if Players[P].HeroSilent then
    Result := '|[$BEBEAA]<$49>[] (' + IntToStr((Players[P].HeroSilentTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function PreparingStatus(P: Integer): ANSIString;
begin
  if Players[P].Preparing then
    Result := '|[$FAC667]<$53>[] (' + IntToStr((Players[P].PreparingTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function ReChargeStatus(P: Integer): ANSIString;
begin
  if Players[P].ReCharge then
    Result := '|[$746CCC]<$54>[] (' + IntToStr((Players[P].ReChargeTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function MindStatus(P: Integer): ANSIString;
begin
  if Players[P].CaptureMind then
    Result := '|[$11FF11]<$104>[] ' + '[$' + States.PlayerColorText(M[P]) + ']' + States.PlayerName(M[P]) + '[$FFFFFF]; <$39>: ' + HPColor(M[P]) + IntToStr(Players[M[P]].HP) + '[$FFFFFF] (' + IntToStr((Players[P].CaptureMindTime - States.GameTime)/10) + ')' 

  else

    Result := '';
end;


function MindStunnedStatus(P: Integer): ANSIString;
begin
  if Players[P].MindStunned then
    Result := '|[$0050FF]<$103>[] (' + IntToStr((Players[P].StunnedMindTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function StatusText(P: Integer): ANSIString;
begin
  Result := ImmortalStatus(P) + StunnedStatus(P) + FearStatus(P) {+ PrisonedStatus(P)} + WerewolfStatus(P)
  + RegenStatus(P) + DDStatus(P) {+ IllusionStatus(P)} + SilenceStatus(P) + PreparingStatus(P)
  + ReChargeStatus(P) + RogueStatus(P) + MindStatus(P) + MindStunnedStatus(P) + RebornStatus(P) + FieryTrackStatus(P) + GameplayStatus(P);
end;


procedure CheckDelays(P: Integer);
begin

  if Players[P].RoadSkillDelay > 0 then
    Players[P].RoadSkillDelay := Players[P].RoadSkillDelay - 1;

  if Players[P].FieldSkillDelay > 0 then
    Players[P].FieldSkillDelay := Players[P].FieldSkillDelay - 1;

  if Players[P].WineSkillDelay > 0 then
    Players[P].WineSkillDelay := Players[P].WineSkillDelay - 1;

end;


function CanUseWineFieldSkill(X, Y: Integer): Boolean;
begin
  Result := False;
  if X <= 0 then
    Exit;
  if Y <= 0 then
    Exit;
  if TileOnBattlefield(X, Y) then 
    Result := (States.MapTileType(X, Y) <> 197)
    and (States.MapTileType(X, Y) <> 202)
    and (States.MapTileType(X, Y) <> 206)
    and (States.MapTileType(X, Y) <> 207)
    and (States.MapTileType(X, Y) <> 215)
    and (States.MapTileType(X, Y) <> 223)
    and (not States.IsRoadAt(8, X, Y));
end;


function SkillName(fSkill: aSkill): ANSIString;
begin
  case fSkill of

    sFieryLance: Result := '<$12>';
    sTeleport: Result := '<$20>';
    s10kSpears: Result := '<$28>';

    sCrackingEarth: Result := '<$14>';
    sWaveOfRage: Result := '<$22>';
    sTotem: Result := '<$30>';

    sSpikedEarth: Result := '<$9>';
    sZombieSummon: Result := '<$17>';
    sFear: Result := '<$25>';

    sAccurateShot: Result := '<$11>';
    sSuddenDeath: Result := '<$19>';
    sSniperShot: Result := '<$27>';

    sGravity: Result := '<$8>';
    sDeadlyFireworks: Result := '<$16>';
    sWerewolf: Result := '<$24>';

    sDisorientation: Result := '<$15>';
    sTrack: Result := '<$23>';
    sRegen: Result := '<$31>';

    sViseOfDeath: Result := '<$13>';
    sSacrificialTeleport: Result := '<$21>';
    sConcentration: Result := '<$29>';

    sRocket: Result := '<$10>';
    sPrison: Result := '<$18>';
    sRevengeFromNowhere: Result := '<$26>';

    sFierySnake: Result := '<$46>';
    sSturdyArmor: Result := '<$47>';
    sPowerWithin: Result := '<$48>';

    sRopesOfDeath: Result := '<$50>';
    sDeafeningClatter: Result := '<$51>';
    sRagingSpurt: Result := '<$52>';

    sMentalBurst: Result := '<$55>';
    sSteal: Result := '<$56>';
    sUniversal: Result := '';

    sBoomerang: Result := '<$80>';
    sSilence: Result := '<$81>';
    sMind: Result := '<$102>';

    sNone: Result := '';

  end;
end;


function RoadSkillName(P, UT: Integer): ANSIString;
begin
  case UT of
    15: Result := '[$4C818B]<$8>[]';
    16: Result := '[$2222B2]<$9>[]';
    17: Result := '[$0000FF]<$10>[]';
    18: Result := '[$00A5FF]<$11>[]';
    19: Result := '[$4782FF]<$12>[]';
    20: Result := '[$B8B8B8]<$13>[]';
    21: Result := '[$AAAAAA]<$80>[]';
    22: Result := '[$634BBA]<$50>[]';
    23: Result := '[$499AEE]<$14>[]';
    26: Result := '[$0022FF]<$46>[]';
    27: Result := '[$FF7648]<$15>[]';
    25: Result := '[$ADF346]<$55>[]';
  end;
end;


function FieldSkillName(P, UT: Integer): ANSIString;
begin
  case UT of
    15: Result := '[$00A5FF]<$16>[]';
    16: Result := '[$578B2E]<$17>[]';
    17: Result := '[$8B668B]<$18>[]';
    18: Result := '[$0045FF]<$19>[]';
    19: Result := '[$FFFF97]<$20>[]';
    20: Result := '[$00008B]<$21>[]';
    21: Result := '[$BA5555]<$81>[]';
    22: Result := '[$902F9D]<$51>[]';
    23: Result := '[$4040FF]<$22>[]';
    26: Result := '[$528AAF]<$47>[]';
    27: Result := '[$00CDCD]<$23>[]';
    25: Result := '[$CC7854]<$56>[]';
  end;
end;


function WineSkillName(P, UT: Integer): ANSIString;
begin
  case UT of
    15: Result := '[$26368B]<$24>[]';
    16: Result := '[$8B008B]<$25>[]';
    17: Result := '[$00FFFF]<$26>[]';
    18: Result := '[$D30094]<$27>[]';
    19: Result := '[$00C7FF]<$28>[]';
    20: Result := '[$006400]<$29>[]';
    21: Result := '[$AAFFAA]<$102>[]';
    22: Result := '[$2580CE]<$52>[]';
    23: Result := '[$EE677A]<$30>[]';
    26: Result := '[$1707A6]<$48>[]';
    27: Result := '[$00FC7C]<$31>[]';
    25: Result := '[$AE209F]' + Players[P].StolenSkillName + '[]';
  end;
end;


function RoadSkillInfo(P, UT: Integer): ANSIString;
begin
  case UT of
    15: Result := '<$307>';
    16: Result := '<$304>';
    17: Result := '<$305>';
    18: Result := '<$303>';
    19: Result := '<$301>';
    20: Result := '<$306>';
    21: Result := '<$311>';
    22: Result := '<$309>';
    23: Result := '<$302>';
    26: Result := '<$308>';
    27: Result := '<$313>';
    25: Result := '<$310>';
  end;
end;


function FieldSkillInfo(P, UT: Integer): ANSIString;
begin
  case UT of
    15: Result := '<$407>';
    16: Result := '<$404>';
    17: Result := '<$405>';
    18: Result := '<$403>';
    19: Result := '<$401>';
    20: Result := '<$406>';
    21: Result := '<$411>';
    22: Result := '<$409>';
    23: Result := '<$402>';
    26: Result := '<$408>';
    27: Result := '<$413>';
    25: Result := '<$410>';
  end;
end;


function WineSkillInfo(P, UT: Integer): ANSIString;
begin
  case UT of
    15: Result := '<$507>';
    16: Result := '<$504>';
    17: Result := '<$505>';
    18: Result := '<$503>';
    19: Result := '<$501>';
    20: Result := '<$506>';
    21: Result := '<$511>';
    22: Result := '<$509>';
    23: Result := '<$502>';
    26: Result := '<$508>';
    27: Result := '<$513>';
    25: Result := '<$510>';
  end;
end;


function HeroDescription(P, UT: Integer): ANSIString;
begin
  case UT of
    15:  Result := '<$207>';
    16:  Result := '<$204>';
    17:  Result := '<$205>';
    18:  Result := '<$203>';
    19:  Result := '<$201>';
    20:  Result := '<$206>';
    21:  Result := '<$211>';
    22:  Result := '<$209>';
    23:  Result := '<$202>';
    25:  Result := '<$210>';
    26:  Result := '<$208>'
    else Result := '';
  end;
end;


function PlayerInfo(P: Integer): ANSIString;
begin
  if Players[P].ReChoice then
    Result := ' [$BECADA]<$66>[]; <$39>: ' + HPColor(P) + IntToStr(Players[P].HP) + '[]'
  else
    Result := ' <$42>: ' + States.UnitTypeName(Players[P].HeroType) + '; <$39>: ' + HPColor(P) + IntToStr(Players[P].HP) + '[]';
end;


procedure SetCircle(P, X, Y, R, aObj: Integer; aDef, aSaveCracking: Boolean; fSkill: aSkill);
var
  X1, X2, Y1, Y2, PosX, PosY: Integer;
  Tree: Boolean;
begin
  X1 := X - R;
  X2 := X + R;
  Y1 := Y - R;
  Y2 := Y + R;
  for PosX := X1 to X2 do
  for PosY := Y1 to Y2 do
  begin
    if (((X - PosX) * (X - PosX) + (Y - PosY) * (Y - PosY)) <= R * R) then
      if TileOnBattlefield(PosX, PosY)
      and (PosX > 0)
      and (PosY > 0)
      and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT3)
      and (States.MapTileObject(PosX, PosY) <> SWORD_OBJECT)
      and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT)
      and (States.MapTileObject(PosX, PosY) <> BOWMAN_ROCKET)
      and (States.MapTileObject(PosX, PosY) <> BOWMAN_OBJECT5)
      and (States.MapTileObject(PosX, PosY) <> WARRIOR_OBJECT5)
      and (States.MapTileObject(PosX, PosY) <> CIRCLE_FILL_OBJ)
      and (States.MapTileObject(PosX, PosY) <> KNIGHT_OBJECT4)
      and (States.MapTileObject(PosX, PosY) <> VAGA_OBJECT8)
      and (not InRange(States.MapTileObject(PosX, PosY), SWORD_OBJECT1, VAGA_OBJECT6))
      and (fSkill <> sDeadlyFireworks) then
      begin
        Tree := (aObj = 255) and (InRange(States.MapTileObject(PosX, PosY), 149, 172));
        if not Tree then
        begin
          Actions.MapTileObjectSet(PosX, PosY, aObj);
          if (Tiles[PosX][PosY].Owner <> P)
          and (Tiles[PosX][PosY].Skill <> sTrack)
          and (Tiles[PosX][PosY].Skill <> sDeadlyFireworks) then
          begin
            Tiles[PosX][PosY].Owner := P;
            Tiles[PosX][PosY].Skill := fSkill;
          end;
        end;
          if aObj = 255 then
            if Tiles[PosX][PosY].Skill = fSkill then
              Tiles[PosX][PosY].Skill := sNone;
        end;
        if not aSaveCracking then
          if States.MapTileObject(PosX, PosY) = BARB_OBJECT then
            Actions.MapTileObjectSet(PosX, PosY, aObj);
  end;

  if fSkill = sDeadlyFireworks then
  begin
    for PosX := X1 to X2 do
    for PosY := Y1 to Y2 do
    begin
      if (((X - PosX) * (X - PosX) + (Y - PosY) * (Y - PosY)) <= R * R) then
        if TileOnBattlefield(PosX, PosY)
        and (PosX > 0)
        and (PosY > 0)
        and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT3)
        and (States.MapTileObject(PosX, PosY) <> SWORD_OBJECT)
        and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT)
        and (States.MapTileObject(PosX, PosY) <> BOWMAN_ROCKET)
        and (States.MapTileObject(PosX, PosY) <> BOWMAN_OBJECT5)
        and (States.MapTileObject(PosX, PosY) <> WARRIOR_OBJECT5)
        and (States.MapTileObject(PosX, PosY) <> CIRCLE_FILL_OBJ)
        and (States.MapTileObject(PosX, PosY) <> KNIGHT_OBJECT4)
        and (States.MapTileObject(PosX, PosY) <> VAGA_OBJECT8)
        and (not InRange(States.MapTileObject(PosX, PosY), SWORD_OBJECT1, VAGA_OBJECT6))
        and (not InRange(States.MapTileObject(PosX, PosY), SHIELD_OBJECT, SHIELD_OBJECT8)) then
        begin
          Tree := (aObj = 255) and (InRange(States.MapTileObject(PosX, PosY), 149, 172));
          if not Tree then
          begin
            Actions.MapTileObjectSet(PosX, PosY, aObj);
            if (Tiles[PosX][PosY].Skill = sNone)
            or (Tiles[PosX][PosY].Skill = sGravity) then
            begin
              Tiles[PosX][PosY].Owner := P;
              Tiles[PosX][PosY].Skill := fSkill;
            end;
          end;
          if aObj = 255 then
            if Tiles[PosX][PosY].Skill = fSkill then
              Tiles[PosX][PosY].Skill := sNone;
        end;
        if not aSaveCracking then
          if States.MapTileObject(PosX, PosY) = BARB_OBJECT then
            Actions.MapTileObjectSet(PosX, PosY, aObj);
    end;
  end;

  if aDef then
  begin
    Players[P].DefenceTime := States.GameTime + CIRCLE_DEF_TIME;
    for PosX := X1 to X2 do
    for PosY := Y1 to Y2 do
    begin
      if (((X - PosX) * (X - PosX) + (Y - PosY) * (Y - PosY)) <= ((R - 1) * (R - 1))) then
        if TileOnBattlefield(PosX, PosY)
        and (PosX > 0)
        and (PosY > 0)
        and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT3)
        and (States.MapTileObject(PosX, PosY) <> SWORD_OBJECT)
        and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT)
        and (States.MapTileObject(PosX, PosY) <> BOWMAN_ROCKET)
        and (States.MapTileObject(PosX, PosY) <> BOWMAN_OBJECT5)
        and (States.MapTileObject(PosX, PosY) <> WARRIOR_OBJECT5)
        and (States.MapTileObject(PosX, PosY) <> CIRCLE_FILL_OBJ)
        and (States.MapTileObject(PosX, PosY) <> KNIGHT_OBJECT4)
        and (States.MapTileObject(PosX, PosY) <> VAGA_OBJECT8)
        and (not InRange(States.MapTileObject(PosX, PosY), SWORD_OBJECT1, VAGA_OBJECT6)) then
          Actions.MapTileObjectSet(PosX, PosY, ShieldObjects[P]);
        if not aSaveCracking then
          if States.MapTileObject(PosX, PosY) = BARB_OBJECT then
            Actions.MapTileObjectSet(PosX, PosY, ShieldObjects[P]);
    end;
  end;

  if aObj = BARB_OBJECT2 then
    if InRange(States.MapTileObject(PosX, PosY), SHIELD_OBJECT, SHIELD_OBJECT8) then
      Actions.MapTileObjectSet(PosX, PosY, ShieldObjects[P]);

  if aObj = PikeObjects[P] then
    Players[P].ClearPikeObjTime := States.GameTime + 20;

  if not aDef then
  begin
    for PosX := X1 to X2 do
    for PosY := Y1 to Y2 do
    begin
      if (((X - PosX) * (X - PosX) + (Y - PosY) * (Y - PosY)) <= ((R - 1) * (R - 1))) then
        if TileOnBattlefield(PosX, PosY)
        and (PosX > 0)
        and (PosY > 0)
        and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT3)
        and (States.MapTileObject(PosX, PosY) <> SWORD_OBJECT)
        and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT)
        and (States.MapTileObject(PosX, PosY) <> BOWMAN_ROCKET)
        and (States.MapTileObject(PosX, PosY) <> BOWMAN_OBJECT5)
        and (States.MapTileObject(PosX, PosY) <> WARRIOR_OBJECT5)
        and (States.MapTileObject(PosX, PosY) <> CIRCLE_FILL_OBJ)
        and (States.MapTileObject(PosX, PosY) <> KNIGHT_OBJECT4)
        and (States.MapTileObject(PosX, PosY) <> VAGA_OBJECT8)
        and (not InRange(States.MapTileObject(PosX, PosY), SWORD_OBJECT1, VAGA_OBJECT6)) then
        begin
          Tree := (aObj = 255) and (InRange(States.MapTileObject(PosX, PosY), 149, 172));
          if not Tree then
            Actions.MapTileObjectSet(PosX, PosY, 255);
        end;
        if not aSaveCracking then
          if States.MapTileObject(PosX, PosY) = BARB_OBJECT then
            Actions.MapTileObjectSet(PosX, PosY, 255);
    end;
  end;

end;


procedure StartReChoice(P: Integer);
begin
  Actions.GroupKillAll(Players[P].Hero, True);
  Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
  Actions.FogCoverAll(P);
  Actions.FogRevealRect(P, 4, 4, 30, 30);
  Players[P].ReChoice := True;
  Players[P].ReChoiceTime := States.GameTime + RECHOICE_TIME;
  Actions.CinematicStart(P);
  Actions.CinematicPanTo(P, CENTERSCREEN_X, CENTERSCREEN_Y, 0);
  Actions.CinematicEnd(P);
end;


procedure EndReChoice(P: Integer);
var
  TH: Integer;
begin
  TH := Players[P].Hero;
  Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].SpawnX, Players[P].SpawnY, Players[P].Direction, 1, 1);
  Actions.GroupKillAll(TH, True);
  Players[P].ReChoice := False;
  Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
  Actions.FogCoverAll(P);
  Actions.FogRevealRect(P, 1, 39, 70, 109);
  Actions.CinematicStart(P);
  Actions.CinematicPanTo(P, Players[P].SpawnX, Players[P].SpawnY, 0);
  Actions.CinematicEnd(P);
  Players[P].RoadSkillDelay := 0;
  Players[P].FieldSkillDelay := 0;
  Players[P].WineSkillDelay := 0;
  Players[P].ReChoiceAllowed := False;
  Players[P].VagaAppearTimeBack := 0;
  Players[P].VagaAppearTime := 0;
  Players[P].HeroStunnedTime := 0;
  Players[P].HeroSilentTime := 0;
  Players[P].HeroInFearTime := 0;
  Players[P].WerewolfTime := 0;
  Players[P].DDTime := 0;
  Players[P].ReChargeTime := 0;
  Players[P].HeroImmortal := True;
  Players[P].HeroImmortalTime := States.GameTime + RECHOICE_IMMORTAL_TIME;
end;


procedure OnHousePlanPlaced(P, X, Y, HT: Integer);
begin
  Actions.PlanRemove(P, X, Y);
  if Players[P].Hero < 0 then
    Exit;
  if Players[P].HeroType <= 0 then
    Exit;
  if not TileOnBattlefield(X, Y) then
    Exit;
  if (HT <> 13)
  and (HT <> 21) then
    Exit;
  if HT = 13 then
  begin
    Actions.ShowMsg(P, RoadSkillInfo(P, Players[P].HeroType));
    Actions.ShowMsg(P, FieldSkillInfo(P, Players[P].HeroType));
    Actions.ShowMsg(P, WineSkillInfo(P, Players[P].HeroType));
  end;
  if (HT = 21)
  and (States.UnitPositionX(States.GroupMember(Players[P].Hero, 0)) = Players[P].SpawnX)
  and (States.UnitPositionY(States.GroupMember(Players[P].Hero, 0)) = Players[P].SpawnY)
  and (Players[P].ReChoiceAllowed)
  and (not Players[P].MindStunned)
  and (not Players[P].CaptureMind)
  and (not Players[P].HeroStunned)
  and (not Players[P].Preparing)
  and (Players[P].HP > 0) then
    StartReChoice(P);
  if (HT = 21)
  and (not Players[P].ReChoiceAllowed) then
    Actions.ShowMsg(P, '<$65>');
end;


procedure OnBeacon(P, X, Y: Integer);
begin
  if not DEBUG_MODE then
    Exit;
  if States.UnitAt(X, Y) = -1 then
    Exit;
  if States.GameTime > CHOOSE_HERO_TIMER then
    Exit;

  if (InRange(X, 16, 21))
  and (InRange(Y, 17, 18)) then
    for I := 0 to 7 do
      if States.PlayerEnabled(I) then
        if (States.PlayerIsAI(I))
        and (not Players[I].HeroChosen) then
        begin
          Players[I].HeroType := States.UnitType(States.UnitAt(X, Y));
          Players[I].HeroChosen := True;
          Actions.GiveUnit(8, 13, 13, 14, 4);
          if InRange(I, 0, 3) then
            TeamChoice[0] := TeamChoice[0] + '|[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[] <$32> ' + States.UnitTypeName(Players[I].HeroType);
          if InRange(I, 4, 7) then
            TeamChoice[1] := TeamChoice[1] + '|[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[] <$32> ' + States.UnitTypeName(Players[I].HeroType);
        end;
end;


//Heroes & Skills


//SWORD FIGHTER


procedure ZombieStun(P, U: Integer);
var
  X1, X2, Y1, Y2, Desync, Dir: Integer;
begin

  X2 := States.UnitPositionX(U);
  Y2 := States.UnitPositionY(U);

  Dir := States.UnitDirection(U);

  Desync := 0;

  if Dir mod 2 = 1 then
    if States.KaMRandom < 0.5 then
      Dir := Dir + 1;

  if Dir = 8 then
    Dir := 0;

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;
    
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 9;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 11;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 13;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 15;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 1;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 3;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 5;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 7;

    for I := 1 to 4 do
    begin
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := SWORD_OBJECT;
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
      begin
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Owner := P;
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Skill := sSpikedEarth;
      end;
    end;

    for I := 1 to 4 do
      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    case Dir of

      0,1: for Y1 := Y2 - 1 downto Y2 - 4 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 10 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sSpikedEarth;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      2,3: for X1 := X2 + 1 to X2 + 4 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 10 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sSpikedEarth;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      4,5: for Y1 := Y2 + 1 to Y2 + 4 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 10 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sSpikedEarth;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      6,7: for X1 := X2 - 1 downto X2 - 4 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 10 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sSpikedEarth;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;
        end;

end;


procedure SpikedEarth(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 10;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;
    
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 9;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 11;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 13;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 15;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 1;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 3;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 5;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 7;

    for I := 1 to 4 do
    begin
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := SWORD_OBJECT;
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
      begin
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Owner := P;
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Skill := sSpikedEarth;
      end;
    end;

    for I := 1 to 4 do
      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    if Length(Zombies) > 0 then
      for K := 0 to Length(Zombies) - 1 do
        if (Zombies[K].Owner = P)
        and (States.UnitType(Zombies[K].ID) = 14) then
          ZombieStun(P, Zombies[K].ID);

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 9 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 10 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sSpikedEarth;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      2,3: for X1 := X2 + 2 to X2 + 9 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 10 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sSpikedEarth;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 9 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 10 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sSpikedEarth;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      6,7: for X1 := X2 - 2 downto X2 - 9 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 10 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sSpikedEarth;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sSpikedEarth;

    Players[P].RoadSkillDelay := Round(SWORD_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;
end;


procedure ZombieSummon(P, X, Y: Integer);
var
  X2, Y2, Zombie: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (States.StatArmyCount(Players[P].ZombiePlayer) < MAX_MILIZOMBIE)
  and (Players[P].ZombiePlayer <> - 1) 
  and (TileOnBattlefield(X, Y)) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= MILIZOMBIE_RADIUS)
    and (Abs(Y2 - Y) <= MILIZOMBIE_RADIUS) then
    begin
      Zombie := Actions.GiveGroup(Players[P].ZombiePlayer, 14, X, Y, States.KaMRandomI(8), 1, 1);
      SetLength(Zombies, Length(Zombies) + 1);
      Zombies[Length(Zombies) - 1].Owner := P;
      Zombies[Length(Zombies) - 1].ID := States.GroupMember(Zombie, 0);
      Actions.GroupHungerSet(Zombie, RUNE_ZOMBIE_LIFE);
      if Players[P].DD then
      begin
        Zombie := Actions.GiveGroup(Players[P].ZombiePlayer, 14, X, Y + 1, States.KaMRandomI(8), 1, 1);
        SetLength(Zombies, Length(Zombies) + 1);
        Zombies[Length(Zombies) - 1].Owner := P;
        Zombies[Length(Zombies) - 1].ID := States.GroupMember(Zombie, 0);
        Actions.GroupHungerSet(Zombie, RUNE_ZOMBIE_LIFE);
      end;
      Players[P].FieldSkillDelay := Round(SWORD_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      Players[P].LastUsedSkill := sZombieSummon;
    end;
  end;

end;


procedure Fear(P, X, Y: Integer);
var
 X2, Y2, U, O: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= IN_FEAR_RADIUS)
    and (Abs(Y2 - Y) <= IN_FEAR_RADIUS) then
    begin
      U := States.UnitAt(X, Y);
      if U <> - 1 then
        O := States.UnitOwner(U);

      if InRange(States.UnitOwner(U), 8, 11) then
      begin
        Actions.UnitKill(U, False);
        Players[P].LastUsedSkill := sFear;
        Players[P].WineSkillDelay := Round(SWORD_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      end;

      if (U <> - 1)
      and (U = States.GroupMember(Players[O].Hero, 0))
      and (not Players[O].HeroInFear)
      and (not Players[O].HeroImmortal)
      and (O <> P)
      and (Players[P].PlayersTeam <> Players[O].PlayersTeam) then
      begin
        Players[O].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
        Players[O].PlayerStatus := Players[O].PlayerStatus + '|<$74> ' + '[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[]<$71> ' + SkillName(sFear);
        Players[O].HeroInFear := True;
        Players[O].HeroFearGiver := P;
        Players[O].HeroInFearTime := States.GameTime + IN_FEAR_TIME;
        if Players[O].Hero > 0 then
          Actions.GroupBlockOrders(Players[O].Hero, True);
        Players[P].LastUsedSkill := sFear;
        Players[P].WineSkillDelay := Round(SWORD_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      end;
    end;
  end;

end;


//BARBARIAN


procedure CrackingEarth(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 20;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;

    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 16;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 17;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 18;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 19;

    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 1;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 3;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4;

    Players[P].CrackingStartTime := States.GameTime + 6;

    for I := 1 to 4 do
    begin
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := BARB_OBJECT;
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
      begin
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Owner := P;
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Skill := sCrackingEarth;
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
      end;
    end;

    for I := 1 to 4 do
      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 9 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 73 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BARB_OBJECT;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sCrackingEarth;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      2,3: for X1 := X2 + 2 to X2 + 9 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 73 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BARB_OBJECT;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sCrackingEarth;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 9 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 73 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BARB_OBJECT;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sCrackingEarth;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      6,7: for X1 := X2 - 2 downto X2 - 9 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 73 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BARB_OBJECT;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sCrackingEarth;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sCrackingEarth;

    Players[P].RoadSkillDelay := Round(BARB_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure WaveOfRage(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    RageCirclesCounter[P] := RageCirclesCounter[P] + 1;
    if RageCirclesCounter[P] = MAX_CIRCLES_AT_ONCE then
      RageCirclesCounter[P] := 0;
    RageCirclesLength[P][RageCirclesCounter[P]] := RageCirclesLength[P][RageCirclesCounter[P]] + RAGE_CYCLES * RAGE_RADIUS;
    SetLength(RageCircles[P][RageCirclesCounter[P]], RageCirclesLength[P][RageCirclesCounter[P]]);

    for I := RageCirclesLength[P][RageCirclesCounter[P]] downto RageCirclesLength[P][RageCirclesCounter[P]] - RAGE_CYCLES * RAGE_RADIUS + 1 do
    begin
      RageCircles[P][RageCirclesCounter[P]][RageCirclesLength[P][RageCirclesCounter[P]] - I].Obj := BARB_OBJECT2;
      RageCircles[P][RageCirclesCounter[P]][RageCirclesLength[P][RageCirclesCounter[P]] - I].X := X2;
      RageCircles[P][RageCirclesCounter[P]][RageCirclesLength[P][RageCirclesCounter[P]] - I].Y := Y2;
      RageCircles[P][RageCirclesCounter[P]][RageCirclesLength[P][RageCirclesCounter[P]] - I].AddTime := States.GameTime + Round(BARB_FIELD_SPEED * (RageCirclesLength[P][RageCirclesCounter[P]] - I));
      if I mod RAGE_RADIUS > 0 then
        RageCircles[P][RageCirclesCounter[P]][RageCirclesLength[P][RageCirclesCounter[P]] - I].Radius := RAGE_RADIUS + 2 - I mod RAGE_RADIUS
      else
        RageCircles[P][RageCirclesCounter[P]][RageCirclesLength[P][RageCirclesCounter[P]] - I].Radius := 1;
    end; 
       
    for I := 0 to RageCirclesLength[P][RageCirclesCounter[P]] - 1 do 
      if I mod RAGE_RADIUS = 1 then
        RageCircles[P][RageCirclesCounter[P]][RageCirclesLength[P][RageCirclesCounter[P]] - I].Obj := 255;

    Players[P].LastUsedSkill := sWaveOfRage;

    Players[P].FieldSkillDelay := Round(BARB_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    TimeToClearRageArray[P][RageCirclesCounter[P]] := RageCircles[P][RageCirclesCounter[P]][RageCirclesLength[P][RageCirclesCounter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure TotemOfAncestors(P, X, Y: Integer);
var
  X2, Y2, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0)
  and not (InRange(States.MapTileObject(X, Y), SWORD_OBJECT, VAGA_OBJECT6))
  and not (InRange(States.MapTileObject(X, Y), SHIELD_OBJECT, SHIELD_OBJECT8)) then
  begin
    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 37;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    TotemCirclesCounter[P] := TotemCirclesCounter[P] + 1;
    if TotemCirclesCounter[P] = MAX_CIRCLES_AT_ONCE then
      TotemCirclesCounter[P] := 0;
    if (Abs(X2 - X) <= TOTEM_ADD_RADIUS)
    and (Abs(Y2 - Y) <= TOTEM_ADD_RADIUS) then
    begin

      TotemCirclesLength[P][TotemCirclesCounter[P]] := TotemCirclesLength[P][TotemCirclesCounter[P]] + TOTEM_CYCLES * TOTEM_RADIUS;
      SetLength(TotemCircles[P][TotemCirclesCounter[P]], TotemCirclesLength[P][TotemCirclesCounter[P]]);
      TilesWineLength[P] := TilesWineLength[P] + 9;
      SetLength(TilesWineX[P], TilesWineLength[P]);
      SetLength(TilesWineY[P], TilesWineLength[P]);
      SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
      SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
      SetLength(TilesWineObjects[P], TilesWineLength[P]);

      TilesWineX[P][Length(TilesWineX[P]) - 1] := X;
      TilesWineY[P][Length(TilesWineY[P]) - 1] := Y;

      TilesWineX[P][Length(TilesWineX[P]) - 9] := X2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 9] := Y2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2 + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 7] := X2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 6] := X2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 5] := X2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2;
      TilesWineX[P][Length(TilesWineX[P]) - 4] := X2;
      TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2;
      TilesWineX[P][Length(TilesWineX[P]) - 2] := X2;
      TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;

      for I := 2 to 9 do
      begin
        TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := BARB_OBJECT5;
        if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
        begin
          Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].Owner := P;
          Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].Skill := sTotem;
          Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
        end;
      end;

      TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := BARB_OBJECT3;
      Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
      Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := sTotem;

      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 36;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 110;
      Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];

      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 9] := States.GameTime + 10;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 9] := States.GameTime + 30;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 10;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 30;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 10;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 30;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 10;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 30;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 16;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 36;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 16;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 36;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 16;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 36;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 16;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 36;

      for I := 1 to 9 do
        if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
          ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

      for I := TotemCirclesLength[P][TotemCirclesCounter[P]] downto TotemCirclesLength[P][TotemCirclesCounter[P]] - TOTEM_CYCLES * TOTEM_RADIUS + 1 do
      begin
        TotemCircles[P][TotemCirclesCounter[P]][TotemCirclesLength[P][TotemCirclesCounter[P]] - I].Obj := BARB_OBJECT4;
        TotemCircles[P][TotemCirclesCounter[P]][TotemCirclesLength[P][TotemCirclesCounter[P]] - I].X := X;
        TotemCircles[P][TotemCirclesCounter[P]][TotemCirclesLength[P][TotemCirclesCounter[P]] - I].Y := Y;
        TotemCircles[P][TotemCirclesCounter[P]][TotemCirclesLength[P][TotemCirclesCounter[P]] - I].AddTime := States.GameTime + 39 + Round((TotemCirclesLength[P][TotemCirclesCounter[P]] - I) / BARB_WINE_SPEED);
        if I mod TOTEM_RADIUS > 0 then
          TotemCircles[P][TotemCirclesCounter[P]][TotemCirclesLength[P][TotemCirclesCounter[P]] - I].Radius := TOTEM_RADIUS + 1 - I mod TOTEM_RADIUS
        else
          TotemCircles[P][TotemCirclesCounter[P]][TotemCirclesLength[P][TotemCirclesCounter[P]] - I].Radius := 1;
        end;
        
      for I := 0 to TotemCirclesLength[P][TotemCirclesCounter[P]] - 1 do 
        if I mod TOTEM_RADIUS = 1 then
          TotemCircles[P][TotemCirclesCounter[P]][TotemCirclesLength[P][TotemCirclesCounter[P]] - I].Obj := 255;

      if States.PlayerIsAI(P) then
      begin
        Players[P].SkillCastDir := Direction;
        Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
        Players[P].SkillCastX := X2;
        Players[P].SkillCastY := Y2;
        Actions.GroupKillAll(Players[P].Hero, True);
        Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
      end;

      Players[P].LastUsedSkill := sTotem;

      Players[P].WineSkillDelay := Round(BARB_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

      TimeToClearTotemArray[P][TotemCirclesCounter[P]] := TotemCircles[P][TotemCirclesCounter[P]][TotemCirclesLength[P][TotemCirclesCounter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;

      ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

    end;

  end;

end;



//LANCE CARRIER


procedure FieryLance(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 29;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;
    TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 4] := LANCE_OBJECT;
    TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 3] := LANCE_OBJECT;
    TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 2] := LANCE_OBJECT2;
    TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := LANCE_OBJECT2;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 9;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 12;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 15;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 18;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 5;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 8;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 11;

    for I := 1 to 4 do
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
      begin
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Owner := P;
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Skill := sFieryLance;
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
      end;

    for I := 1 to 4 do
      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 11 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 17 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := LANCE_OBJECT;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sFieryLance;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      2,3: for X1 := X2 + 2 to X2 + 11 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 17 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := LANCE_OBJECT;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sFieryLance;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 11 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 17 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := LANCE_OBJECT;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sFieryLance;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      6,7: for X1 := X2 - 2 downto X2 - 11 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 17 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := LANCE_OBJECT;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sFieryLance;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sFieryLance;

    Players[P].RoadSkillDelay := Round(LANCE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure Teleport(P, X, Y: Integer);
var
  X2, Y2, NewDir: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    NewDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= TELEPORT_RADIUS)
    and (Abs(Y2 - Y) <= TELEPORT_RADIUS) then
    begin
      Players[P].LastUsedSkill := sTeleport;
      if States.PlayerIsAI(P) then 
        Players[P].TempHeroType := Players[P].HeroType;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(P, Players[P].TempHeroType, X, Y, NewDir, 1, 1);
      Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
      Players[P].FieldSkillDelay := Round(LANCE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
    end;
  end;

end;


procedure TenThousandsSpears(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 60;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    TilesWineLength[P] := TilesWineLength[P] + 24;
    SetLength(TilesWineX[P], TilesWineLength[P]);
    SetLength(TilesWineY[P], TilesWineLength[P]);
    SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
    SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
    SetLength(TilesWineObjects[P], TilesWineLength[P]);

    TilesWineX[P][Length(TilesWineX[P]) - 24] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 23] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 22] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 21] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 24] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 23] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 22] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 21] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 20] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 19] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 18] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 17] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 20] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 19] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 18] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 17] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 16] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 15] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 14] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 13] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 16] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 15] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 14] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 13] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 12] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 11] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 10] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 9] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 12] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 11] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 10] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 9] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 7] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 6] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 5] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 3] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 24] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 23] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 22] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 21] := LANCE_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 24] := States.GameTime + 26;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 23] := States.GameTime + 27;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 22] := States.GameTime + 28;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 21] := States.GameTime + 29;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 24] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 23] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 22] := States.GameTime + 3;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 21] := States.GameTime + 4;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 20] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 19] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 18] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 17] := LANCE_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 20] := States.GameTime + 30;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 19] := States.GameTime + 31;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 18] := States.GameTime + 32;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 17] := States.GameTime + 33;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 20] := States.GameTime + 5;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 19] := States.GameTime + 6;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 18] := States.GameTime + 7;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 17] := States.GameTime + 8;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 16] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 15] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 14] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 13] := LANCE_OBJECT2;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 16] := States.GameTime + 34;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 15] := States.GameTime + 35;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 14] := States.GameTime + 36;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 13] := States.GameTime + 37;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 16] := States.GameTime + 9;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 15] := States.GameTime + 10;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 14] := States.GameTime + 11;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 13] := States.GameTime + 12;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 12] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 11] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 10] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 9] := LANCE_OBJECT2;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 12] := States.GameTime + 38;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 11] := States.GameTime + 39;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 10] := States.GameTime + 40;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 9] := States.GameTime + 41;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 12] := States.GameTime + 13;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 11] := States.GameTime + 14;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 10] := States.GameTime + 15;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 9] := States.GameTime + 16;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 8] := LANCE_OBJECT3;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 7] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 6] := LANCE_OBJECT3;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 5] := LANCE_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 42;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 43;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 44;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 45;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 17;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 18;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 19;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 20;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 4] := LANCE_OBJECT3;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 3] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 2] := LANCE_OBJECT3;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 46;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 47;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 48;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 49;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 21;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 22;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 23;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 24;

    for I := 1 to 24 do
    begin

      if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
      begin

        Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].Owner := P;
        Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].Skill := s10kSpears;
        Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];

      end;

      if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

    end;

    for K := 0 to TEN_K_SPEARS_WAVES - 1 do
    begin

      case Direction of

        0,1: begin
               for Y1 := Y2 - 2 downto Y2 - 22 do
               for X1 := X2 - 1 to X2 + 1 do
                 if TileOnBattlefield(X1, Y1) then
                 begin
                   Desync := Desync + 1;
                   TilesWineLength[P] := TilesWineLength[P] + 1;
                   SetLength(TilesWineX[P], TilesWineLength[P]);
                   SetLength(TilesWineY[P], TilesWineLength[P]);
                   SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
                   SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
                   SetLength(TilesWineObjects[P], TilesWineLength[P]);
                   TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
                   TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
                   ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 35 + 16 * K + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                   SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 30 + 16 * K + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                   TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;
                   Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
                   Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := s10kSpears;
                   Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
                 end;
             end;

        2,3: begin
               for X1 := X2 + 2 to X2 + 22 do
               for Y1 := Y2 - 1 to Y2 + 1 do
                 if TileOnBattlefield(X1, Y1) then
                 begin
                   Desync := Desync + 1;
                   TilesWineLength[P] := TilesWineLength[P] + 1;
                   SetLength(TilesWineX[P], TilesWineLength[P]);
                   SetLength(TilesWineY[P], TilesWineLength[P]);
                   SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
                   SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
                   SetLength(TilesWineObjects[P], TilesWineLength[P]);
                   TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
                   TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
                   ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 35 + 16 * K + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                   SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 30 + 16 * K + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                   TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;
                   Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
                   Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := s10kSpears;
                   Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
                 end;
             end;

        4,5: begin
               for Y1 := Y2 + 2 to Y2 + 22 do
               for X1 := X2 - 1 to X2 + 1 do
                 if TileOnBattlefield(X1, Y1) then
                 begin
                   Desync := Desync + 1;
                   TilesWineLength[P] := TilesWineLength[P] + 1;
                   SetLength(TilesWineX[P], TilesWineLength[P]);
                   SetLength(TilesWineY[P], TilesWineLength[P]);
                   SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
                   SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
                   SetLength(TilesWineObjects[P], TilesWineLength[P]);
                   TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
                   TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
                   ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 35 + 16 * K + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                   SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 30 + 16 * K + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                   TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;
                   Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
                   Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := s10kSpears;
                   Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
                 end;
             end;

        6,7:  begin
               for X1 := X2 - 2 downto X2 - 22 do
               for Y1 := Y2 - 1 to Y2 + 1 do
                 if TileOnBattlefield(X1, Y1) then
                 begin
                   Desync := Desync + 1;
                   TilesWineLength[P] := TilesWineLength[P] + 1;
                   SetLength(TilesWineX[P], TilesWineLength[P]);
                   SetLength(TilesWineY[P], TilesWineLength[P]);
                   SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
                   SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
                   SetLength(TilesWineObjects[P], TilesWineLength[P]);
                   TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
                   TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
                   ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 35 + 16 * K + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                   SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 30 + 16 * K + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                   TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;
                   Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
                   Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := s10kSpears;
                   Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
                 end;
             end;
        end;

    end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := s10kSpears;

    Players[P].WineSkillDelay := Round(LANCE_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


//CROSSBOWMAN


procedure AccurateShot(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 14;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;
    
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 9;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 10;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 11;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 1;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 3;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 5;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 7;

    for I := 1 to 4 do
    begin   
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := XBOW_OBJECT2;
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
      begin
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Owner := P;
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Skill := sAccurateShot;
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
      end;
    end;

    for I := 1 to 4 do
      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 13 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 17 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := XBOW_OBJECT3;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sAccurateShot;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      2,3: for X1 := X2 + 2 to X2 + 13 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 17 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := XBOW_OBJECT3;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sAccurateShot;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 13 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 17 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := XBOW_OBJECT3;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sAccurateShot;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      6,7: for X1 := X2 - 2 downto X2 - 13 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 17 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := XBOW_OBJECT3;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sAccurateShot;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sAccurateShot;

    Players[P].RoadSkillDelay := Round(XBOW_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure SuddenDeath(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 30;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X2 - X) > BOMB_RADIUS)
    or (Abs(Y2 - Y) > BOMB_RADIUS) then
      Exit;

    if (Abs(X2 - X) <= BOMB_RADIUS)
    and (Abs(Y2 - Y) <= BOMB_RADIUS) then
    begin
      TilesFieldLength[P] := TilesFieldLength[P] + 13;
      SetLength(TilesFieldX[P], TilesFieldLength[P]);
      SetLength(TilesFieldY[P], TilesFieldLength[P]);
      SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
      SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
      SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
    
      TilesFieldX[P][Length(TilesFieldX[P]) - 4] := X2 + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 3] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 2] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X2 + 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 4] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 3] := Y2 - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 2] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y2 - 1;

      for I := 1 to 4 do    
        TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := XBOW_OBJECT;
    
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 4] := States.GameTime + 17;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 3] := States.GameTime + 21;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 2] := States.GameTime + 25;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 29;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 4] := States.GameTime + 1;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 3] := States.GameTime + 5;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 2] := States.GameTime + 9;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 13;
        
      TilesFieldX[P][Length(TilesFieldX[P]) - 5] := X;
      TilesFieldY[P][Length(TilesFieldY[P]) - 5] := Y;
      TilesFieldX[P][Length(TilesFieldX[P]) - 6] := X;
      TilesFieldY[P][Length(TilesFieldY[P]) - 6] := Y - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 7] := X;
      TilesFieldY[P][Length(TilesFieldY[P]) - 7] := Y + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 8] := X - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 8] := Y;
      TilesFieldX[P][Length(TilesFieldX[P]) - 9] := X + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 9] := Y;
      TilesFieldX[P][Length(TilesFieldX[P]) - 10] := X + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 10] := Y + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 11] := X + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 11] := Y - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 12] := X - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 12] := Y + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 13] := X - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 13] := Y - 1;

      for I := 5 to 13 do
        TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := XBOW_OBJECT3;

      for I := 10 to 13 do
      begin
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := States.GameTime + 64;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - I] := States.GameTime + 34;
      end;

      for I := 6 to 9 do
      begin
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := States.GameTime + 62;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - I] := States.GameTime + 32;
      end;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 5] := States.GameTime + 60;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 5] := States.GameTime + 30;

      for I := 1 to 13 do
      begin

        if TileOnBattlefield(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) then
        begin

          Tiles[TilesFieldX[P][Length(TilesFieldX[P]) - I]][TilesFieldY[P][Length(TilesFieldY[P]) - I]].Owner := P;
          Tiles[TilesFieldX[P][Length(TilesFieldX[P]) - I]][TilesFieldY[P][Length(TilesFieldY[P]) - I]].Skill := sSuddenDeath;
          Tiles[TilesFieldX[P][Length(TilesFieldX[P]) - I]][TilesFieldY[P][Length(TilesFieldY[P]) - I]].ObjectRefreshTime := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 13];

        end;

        if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
          ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] + CLEANUP_TIME;

      end;

      Players[P].LastUsedSkill := sSuddenDeath;

      Players[P].FieldSkillDelay := Round(XBOW_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    end;

    if States.PlayerIsAI(P) then
    begin
      Players[P].SkillCastDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    ClearFieldTilesArrayTime[P] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 13] + CLEAR_ARRAY_FACTOR + 2;

  end;

end;


procedure SniperShot(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 21;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    TilesWineLength[P] := TilesWineLength[P] + 8;
    SetLength(TilesWineX[P], TilesWineLength[P]);
    SetLength(TilesWineY[P], TilesWineLength[P]);
    SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
    SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
    SetLength(TilesWineObjects[P], TilesWineLength[P]);

    TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 7] := X2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2 + 1; 
    
    TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2;
    TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2;
    TilesWineX[P][Length(TilesWineX[P]) - 6] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 5] := X2; 
    
    TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 + 1;
    
    TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2 - 1;

    for I := 5 to 8 do
      TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := XBOW_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 10;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 11;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 12;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 13;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 3;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 4;
    
    for I := 1 to 4 do
      TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := XBOW_OBJECT2;
    
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 14;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 15;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 16;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 17;
    
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 5;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 6;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 7;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 8;

    for I := 1 to 8 do
    begin

      if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
      begin

        Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].Owner := P;
        Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].Skill := sSniperShot;
        Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];

      end;

      if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

    end;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 48 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 21 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 17 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := XBOW_OBJECT3;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := sSniperShot;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
             end;

      2,3: for X1 := X2 + 2 to X2 + 48 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 21 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 17 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := XBOW_OBJECT3;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := sSniperShot;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 48 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 21 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 17 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := XBOW_OBJECT3;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := sSniperShot;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
             end;

      6,7: for X1 := X2 - 2 downto X2 - 48 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 21 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 17 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := XBOW_OBJECT3;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := sSniperShot;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sSniperShot;

    Players[P].WineSkillDelay := Round(XBOW_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


//PIKEMAN


procedure ViseOfDeath(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 29;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    ViseCirclesCounter[P] := ViseCirclesCounter[P] + 1;
    if ViseCirclesCounter[P] = MAX_CIRCLES_AT_ONCE then
      ViseCirclesCounter[P] := 0;

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    ViseCirclesLength[P][ViseCirclesCounter[P]] := ViseCirclesLength[P][ViseCirclesCounter[P]] + VISE_CYCLES * VISE_RADIUS;
    SetLength(ViseCircles[P][ViseCirclesCounter[P]], ViseCirclesLength[P][ViseCirclesCounter[P]]);
    for I := ViseCirclesLength[P][ViseCirclesCounter[P]] downto ViseCirclesLength[P][ViseCirclesCounter[P]] - VISE_CYCLES * VISE_RADIUS + 1 do
    begin
      ViseCircles[P][ViseCirclesCounter[P]][ViseCirclesLength[P][ViseCirclesCounter[P]] - I].Obj := PikeObjects[P];
      ViseCircles[P][ViseCirclesCounter[P]][ViseCirclesLength[P][ViseCirclesCounter[P]] - I].X := X2;
      ViseCircles[P][ViseCirclesCounter[P]][ViseCirclesLength[P][ViseCirclesCounter[P]] - I].Y := Y2;
      ViseCircles[P][ViseCirclesCounter[P]][ViseCirclesLength[P][ViseCirclesCounter[P]] - I].AddTime := States.GameTime + Round(PIKE_ROAD_SPEED * I);
      ViseCircles[P][ViseCirclesCounter[P]][ViseCirclesLength[P][ViseCirclesCounter[P]] - I].Radius := VISE_RADIUS - I mod VISE_RADIUS;
      if I mod VISE_RADIUS = 0 then
        ViseCircles[P][ViseCirclesCounter[P]][ViseCirclesLength[P][ViseCirclesCounter[P]] - I].Radius := 0;
    end;

    case Direction of

      0,1: for Y1 := Y2 - 3 downto Y2 - 10 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := PIKE_OBJECT9;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sViseOfDeath;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      2,3: for X1 := X2 + 3 to X2 + 10 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := PIKE_OBJECT9;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sViseOfDeath;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      4,5: for Y1 := Y2 + 3 to Y2 + 10 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := PIKE_OBJECT9;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sViseOfDeath;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      6,7: for X1 := X2 - 3 downto X2 - 10 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := PIKE_OBJECT9;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sViseOfDeath;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sViseOfDeath;

    Players[P].RoadSkillDelay := Round(PIKE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    TimeToClearViseArray[P][ViseCirclesCounter[P]] := ViseCircles[P][ViseCirclesCounter[P]][0].AddTime + CLEAR_ARRAY_FACTOR;

    ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure SacrificialTeleport(P, X, Y: Integer);
var
  X2, Y2, NewDir: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (Players[P].Hero > 0)
  and (Players[P].HP >= 2)
  and (TileOnBattlefield(X, Y))
  and not (Players[P].CaptureMind) then
  begin
    NewDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= SACRIFICIAL_RADIUS)
    and (Abs(Y2 - Y) <= SACRIFICIAL_RADIUS) then
    begin
      Players[P].LastUsedSkill := sSacrificialTeleport;
      Players[P].FieldSkillDelay := Round(PIKE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      Actions.GroupKillAll(Players[P].Hero, False);
      Players[P].HP := Players[P].HP - 1;  
      Players[P].Hero := Actions.GiveGroup(P, Players[P].TempHeroType, X, Y, NewDir, 1, 1);
      Actions.GroupHungerset(Players[P].Hero, States.UnitMaxHunger);
    end;
  end;

  if (Players[M[P]].Hero > 0)
  and (Players[M[P]].HP >= 2)
  and (TileOnBattlefield(X, Y))
  and (Players[P].CaptureMind) then
  begin
    NewDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= SACRIFICIAL_RADIUS)
    and (Abs(Y2 - Y) <= SACRIFICIAL_RADIUS) then
    begin
      Players[P].LastUsedSkill := sSacrificialTeleport;
      Players[P].FieldSkillDelay := Round(PIKE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      Actions.GroupKillAll(Players[P].Hero, False);
      Players[M[P]].HP := Players[M[P]].HP - 1;  
      Players[P].Hero := Actions.GiveGroup(P, Players[P].TempHeroType, X, Y, NewDir, 1, 1);
      Actions.GroupHungerset(Players[P].Hero, States.UnitMaxHunger);
    end;
  end;
  
end;


procedure Concentration(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (Players[P].Hero > 0)
  and (TileOnBattlefield(X, Y)) then
  begin
    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 80;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    ConcentrationCirclesCounter[P] := ConcentrationCirclesCounter[P] + 1;
    if ConcentrationCirclesCounter[P] = MAX_CIRCLES_AT_ONCE then
      ConcentrationCirclesCounter[P] := 0;
    Actions.GroupOrderHalt(Players[P].Hero);
    Actions.GroupBlockOrders(Players[P].Hero, True);
    Players[P].HeroStunned := True;
    Players[P].HeroStunnedTime := States.GameTime + CONCENTRATION_TIME + 5;
    if not Players[P].HeroImmortal then
    begin
      Players[P].HeroImmortalTime := States.GameTime + CONCENTRATION_TIME + 15;
      Players[P].HeroImmortal := True;
    end;
    Players[P].Preparing := True;
    Players[P].PreparingTime := States.GameTime + CONCENTRATION_TIME + 5;

    Players[P].PikeX := X2;
    Players[P].PikeY := Y2;
    Players[P].PikeDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    Players[P].PikeAppearTime := States.GameTime + DELAY_OF_TURNING;
    Players[P].TempHeroType := Players[P].HeroType;
    Actions.GroupKillAll(Players[P].Hero, True);
    Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);

    TilesWineLength[P] := TilesWineLength[P] + 72;
    SetLength(TilesWineX[P], TilesWineLength[P]);
    SetLength(TilesWineY[P], TilesWineLength[P]);
    SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
    SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
    SetLength(TilesWineObjects[P], TilesWineLength[P]);

    TilesWineX[P][Length(TilesWineX[P]) - 72] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 71] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 70] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 69] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 72] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 71] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 71] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 69] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 68] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 67] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 66] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 65] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 68] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 67] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 66] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 65] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 64] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 63] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 62] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 61] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 64] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 63] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 62] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 61] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 60] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 59] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 58] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 57] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 60] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 59] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 58] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 57] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 56] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 55] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 54] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 53] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 56] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 55] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 54] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 53] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 52] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 51] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 50] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 49] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 52] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 51] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 50] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 49] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 48] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 47] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 46] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 45] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 48] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 47] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 46] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 45] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 44] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 43] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 42] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 41] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 44] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 43] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 42] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 41] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 40] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 39] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 38] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 37] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 40] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 39] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 38] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 37] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 36] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 35] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 34] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 33] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 36] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 35] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 34] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 33] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 32] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 31] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 30] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 29] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 32] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 31] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 30] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 29] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 28] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 27] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 26] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 25] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 28] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 27] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 26] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 25] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 24] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 23] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 22] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 21] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 24] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 23] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 22] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 21] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 20] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 19] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 18] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 17] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 20] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 19] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 18] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 17] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 16] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 15] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 14] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 13] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 16] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 15] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 14] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 13] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 12] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 11] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 10] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 9] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 12] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 11] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 10] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 9] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 7] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 6] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 5] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 3] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 72] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 71] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 70] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 69] := PIKE_OBJ_STONE;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 72] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 71] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 70] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 69] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 72] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 71] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 70] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 69] := States.GameTime + 2;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 68] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 67] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 66] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 65] := PIKE_OBJ_STONE;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 68] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 67] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 66] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 65] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 68] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 67] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 66] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 65] := States.GameTime + 2;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 64] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 63] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 62] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 61] := PIKE_OBJ_STONE1;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 64] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 63] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 62] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 61] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 64] := States.GameTime + 16;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 63] := States.GameTime + 16;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 62] := States.GameTime + 16;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 61] := States.GameTime + 16;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 60] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 59] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 58] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 57] := PIKE_OBJ_STONE1;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 60] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 59] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 58] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 57] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 60] := States.GameTime + 16;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 59] := States.GameTime + 16;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 58] := States.GameTime + 16;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 57] := States.GameTime + 16;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 56] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 55] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 54] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 53] := PIKE_OBJ_STONE;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 56] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 55] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 54] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 53] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 56] := States.GameTime + 28;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 55] := States.GameTime + 28;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 54] := States.GameTime + 28;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 53] := States.GameTime + 28;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 52] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 51] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 50] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 49] := PIKE_OBJ_STONE;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 52] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 51] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 50] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 49] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 52] := States.GameTime + 28;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 51] := States.GameTime + 28;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 50] := States.GameTime + 28;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 49] := States.GameTime + 28;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 48] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 47] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 46] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 45] := PIKE_OBJ_STONE1;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 48] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 47] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 46] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 45] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 48] := States.GameTime + 38;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 47] := States.GameTime + 38;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 46] := States.GameTime + 38;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 45] := States.GameTime + 38;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 44] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 43] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 42] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 41] := PIKE_OBJ_STONE1;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 44] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 43] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 42] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 41] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 44] := States.GameTime + 38;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 43] := States.GameTime + 38;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 42] := States.GameTime + 38;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 41] := States.GameTime + 38;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 40] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 39] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 38] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 37] := PIKE_OBJ_STONE;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 40] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 39] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 38] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 37] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 40] := States.GameTime + 46;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 39] := States.GameTime + 46;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 38] := States.GameTime + 46;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 37] := States.GameTime + 46;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 36] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 35] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 34] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 33] := PIKE_OBJ_STONE;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 36] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 35] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 34] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 33] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 36] := States.GameTime + 46;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 35] := States.GameTime + 46;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 34] := States.GameTime + 46;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 33] := States.GameTime + 46;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 32] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 31] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 30] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 29] := PIKE_OBJ_STONE1;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 32] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 31] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 30] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 29] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 32] := States.GameTime + 52;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 31] := States.GameTime + 52;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 30] := States.GameTime + 52;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 29] := States.GameTime + 52;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 28] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 27] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 26] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 25] := PIKE_OBJ_STONE1;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 28] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 27] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 26] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 25] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 28] := States.GameTime + 52;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 27] := States.GameTime + 52;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 26] := States.GameTime + 52;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 25] := States.GameTime + 52;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 24] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 23] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 22] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 21] := PIKE_OBJ_STONE;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 24] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 23] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 22] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 21] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 24] := States.GameTime + 56;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 23] := States.GameTime + 56;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 22] := States.GameTime + 56;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 21] := States.GameTime + 56;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 20] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 19] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 18] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 17] := PIKE_OBJ_STONE;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 20] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 19] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 18] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 17] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 20] := States.GameTime + 56;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 19] := States.GameTime + 56;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 18] := States.GameTime + 56;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 17] := States.GameTime + 56;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 16] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 15] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 14] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 13] := PIKE_OBJ_STONE1;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 16] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 15] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 14] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 13] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 16] := States.GameTime + 59;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 15] := States.GameTime + 59;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 14] := States.GameTime + 59;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 13] := States.GameTime + 59;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 12] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 11] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 10] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 9] := PIKE_OBJ_STONE1;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 12] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 11] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 10] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 9] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 12] := States.GameTime + 59;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 11] := States.GameTime + 59;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 10] := States.GameTime + 59;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 9] := States.GameTime + 59;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 8] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 7] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 6] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 5] := PIKE_OBJ_STONE;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 61;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 61;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 61;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 61;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 4] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 3] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 2] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := PIKE_OBJ_STONE;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 65;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 61;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 61;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 61;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 61;

    for I := 1 to 56 do
      if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

    ConcentrationCirclesLength[P][ConcentrationCirclesCounter[P]] := ConcentrationCirclesLength[P][ConcentrationCirclesCounter[P]] + CONCENTRATION_CYCLES * CONCENTRATION_RADIUS;
    SetLength(ConcentrationCircles[P][ConcentrationCirclesCounter[P]], ConcentrationCirclesLength[P][ConcentrationCirclesCounter[P]]);
    for I := ConcentrationCirclesLength[P][ConcentrationCirclesCounter[P]] downto ConcentrationCirclesLength[P][ConcentrationCirclesCounter[P]] - CONCENTRATION_CYCLES * CONCENTRATION_RADIUS + 1 do
    begin
      ConcentrationCircles[P][ConcentrationCirclesCounter[P]][ConcentrationCirclesLength[P][ConcentrationCirclesCounter[P]] - I].Obj := PikeObjects[P];
      ConcentrationCircles[P][ConcentrationCirclesCounter[P]][ConcentrationCirclesLength[P][ConcentrationCirclesCounter[P]] - I].X := X2;
      ConcentrationCircles[P][ConcentrationCirclesCounter[P]][ConcentrationCirclesLength[P][ConcentrationCirclesCounter[P]] - I].Y := Y2;
      ConcentrationCircles[P][ConcentrationCirclesCounter[P]][ConcentrationCirclesLength[P][ConcentrationCirclesCounter[P]] - I].AddTime := States.GameTime + 62 + Round((ConcentrationCirclesLength[P][ConcentrationCirclesCounter[P]] - I) / PIKE_WINE_SPEED);
      if I mod CONCENTRATION_RADIUS > 0 then
        ConcentrationCircles[P][ConcentrationCirclesCounter[P]][ConcentrationCirclesLength[P][ConcentrationCirclesCounter[P]] - I].Radius := CONCENTRATION_RADIUS + 1 - I mod CONCENTRATION_RADIUS
      else
        ConcentrationCircles[P][ConcentrationCirclesCounter[P]][ConcentrationCirclesLength[P][ConcentrationCirclesCounter[P]] - I].Radius := 1;
    end;

    for I := 0 to ConcentrationCirclesLength[P][ConcentrationCirclesCounter[P]] - 1 do 
      if I mod CONCENTRATION_RADIUS = 1 then
        ConcentrationCircles[P][ConcentrationCirclesCounter[P]][ConcentrationCirclesLength[P][ConcentrationCirclesCounter[P]] - I].Obj := 255;

    Players[P].LastUsedSkill := sConcentration;

    Players[P].WineSkillDelay := Round(PIKE_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    TimeToClearConcentrationArray[P][ConcentrationCirclesCounter[P]] := ConcentrationCircles[P][ConcentrationCirclesCounter[P]][ConcentrationCirclesLength[P][ConcentrationCirclesCounter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;

    ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


//VAGA-VAGA


procedure Disorientation(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    {if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 11;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;}

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X2 - X) <= SHOCK_RADIUS)
    and (Abs(Y2 - Y) <= SHOCK_RADIUS) then
    begin
      TilesRoadLength[P] := TilesRoadLength[P] + 9;
      SetLength(TilesRoadX[P], TilesRoadLength[P]);
      SetLength(TilesRoadY[P], TilesRoadLength[P]);
      SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
      SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
      SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
        
      TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
      TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
      TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X;
      TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y - 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X;
      TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y + 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X - 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y;
      TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X + 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y;
      TilesRoadX[P][Length(TilesRoadX[P]) - 6] := X + 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 6] := Y + 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 7] := X + 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 7] := Y - 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 8] := X - 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 8] := Y + 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 9] := X - 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 9] := Y - 1;

      for I := 1 to 9 do
        TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := VAGA_OBJECT6;

      for I := 6 to 9 do
      begin
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := States.GameTime + 10;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - I] := States.GameTime + 6;
      end;

      for I := 2 to 5 do
      begin
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := States.GameTime + 8;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - I] := States.GameTime + 4;
      end;

      ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 6;
      SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 2;

      for I := 1 to 9 do
      begin

        if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
        begin

          Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Owner := P;
          Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Skill := sDisorientation;
          Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 9];

        end;

        if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

      end;

      Players[P].LastUsedSkill := sDisorientation;

      Players[P].RoadSkillDelay := Round(VAGA_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

      ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 9] + CLEAR_ARRAY_FACTOR;

    end;

  end;

end;


function FieryTrackX(P: Integer): Integer;
var
  aX, aD: Integer;
begin
  aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
  aD := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
  case aD of
    0: Result := aX;
    1: Result := aX - 1;
    2: Result := aX - 1;
    3: Result := aX - 1;
    4: Result := aX;
    5: Result := aX + 1;
    6: Result := aX + 1;
    7: Result := aX + 1;
  end;
end;


function FieryTrackY(P: Integer): Integer;
var
  aY, aD: Integer;
begin
  aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
  aD := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
  case aD of
    0: Result := aY + 1;
    1: Result := aY + 1;
    2: Result := aY;
    3: Result := aY - 1;
    4: Result := aY - 1;
    5: Result := aY - 1;
    6: Result := aY;
    7: Result := aY + 1;
  end;
end;


procedure FieryTrack(P, X, Y: Integer);
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Players[P].TrackStartTime := States.GameTime + TRACK_DELAY;
    Players[P].LastUsedSkill := sTrack;
    Players[P].FieldSkillDelay := Round(VAGA_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
  end;

end;


procedure Regen(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= REGEN_RADIUS)
    and (Abs(Y2 - Y) <= REGEN_RADIUS) then
    begin

      if States.PlayerIsAI(P) then
      begin
        Players[P].CastingSkill := True;
        Players[P].SkillTime := States.GameTime + 20;
        Actions.GroupOrderHalt(Players[P].Hero);
      end;

      TilesWineLength[P] := TilesWineLength[P] + 13;
      SetLength(TilesWineX[P], TilesWineLength[P]);
      SetLength(TilesWineY[P], TilesWineLength[P]);
      SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
      SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
      SetLength(TilesWineObjects[P], TilesWineLength[P]);
    
      TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 + 1;
    
      TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2 - 1;

      for I := 1 to 4 do 
        TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := VAGA_OBJECT5;
  
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 8;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 10;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 12;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 14;
    
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 1;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 3;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 5;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 7;
        
      TilesWineX[P][Length(TilesWineX[P]) - 5] := X;
      TilesWineY[P][Length(TilesWineY[P]) - 5] := Y;
      TilesWineX[P][Length(TilesWineX[P]) - 6] := X;
      TilesWineY[P][Length(TilesWineY[P]) - 6] := Y - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 7] := X;
      TilesWineY[P][Length(TilesWineY[P]) - 7] := Y + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 8] := X - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 8] := Y;
      TilesWineX[P][Length(TilesWineX[P]) - 9] := X + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 9] := Y;
      TilesWineX[P][Length(TilesWineX[P]) - 10] := X + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 10] := Y + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 11] := X + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 11] := Y - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 12] := X - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 12] := Y + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 13] := X - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 13] := Y - 1;

      for I := 5 to 13 do
      begin
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := States.GameTime + 100;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - I] := States.GameTime + 20;
        TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := VAGA_OBJECT;
        if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
        begin
          Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].Owner := P;
          Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].Skill := sRegen;
        end;
      end;

      for I := 1 to 13 do
        if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
          ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

      Players[P].LastUsedSkill := sRegen;

      Players[P].WineSkillDelay := Round(VAGA_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

      ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 13] + CLEAR_ARRAY_FACTOR;

    end;

  end;

end;


//AXE FIGHTER


procedure Gravity(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero <> -1) then
  begin
    {if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 10;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;}

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X2 - X) <= GRAVITY_RADIUS1)
    and (Abs(Y2 - Y) <= GRAVITY_RADIUS1) then
    begin
      Players[P].GravityX := X;
      Players[P].GravityY := Y;
      GravityCirclesLength[P] := GravityCirclesLength[P] + GRAVITY_CYCLES * GRAVITY_RADIUS;
      SetLength(GravityCircles[P], GravityCirclesLength[P]);
      for I := GravityCirclesLength[P] downto GravityCirclesLength[P] - GRAVITY_CYCLES * GRAVITY_RADIUS + 1 do
      begin
        GravityCircles[P][GravityCirclesLength[P] - I].Obj := AXE_OBJECT;
        GravityCircles[P][GravityCirclesLength[P] - I].X := X;
        GravityCircles[P][GravityCirclesLength[P] - I].Y := Y;
        GravityCircles[P][GravityCirclesLength[P] - I].AddTime := States.GameTime + Round(AXE_ROAD_SPEED * I);
        GravityCircles[P][GravityCirclesLength[P] - I].Radius := GRAVITY_RADIUS - I mod GRAVITY_RADIUS;
        if I mod GRAVITY_RADIUS = 0 then
          GravityCircles[P][GravityCirclesLength[P] - I].Radius := 0;
      end;

    Players[P].LastUsedSkill := sGravity;

    Players[P].RoadSkillDelay := Round(AXE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    TimeToClearGravityArray[P] := GravityCircles[P][0].AddTime + CLEAR_ARRAY_FACTOR;

    end;

  end;

end;


procedure DeadlyFireworks(P, X, Y: Integer);
var
  X2, Y2: Integer;
  R: array[0..9] of Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X2 - X) <= FIRE_RADIUS)
    and (Abs(Y2 - Y) <= FIRE_RADIUS) then
    begin

      if States.PlayerIsAI(P) then
      begin
        Players[P].CastingSkill := True;
        Players[P].SkillTime := States.GameTime + 40;
        Actions.GroupOrderHalt(Players[P].Hero);
      end;

      Players[P].FireworkTime := States.GameTime + 58;
      Players[P].FireworkX := X;
      Players[P].FireworkY := Y;

      TilesFieldLength[P] := TilesFieldLength[P] + 31;
      SetLength(TilesFieldX[P], TilesFieldLength[P]);
      SetLength(TilesFieldY[P], TilesFieldLength[P]);
      SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
      SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
      SetLength(TilesFieldObjects[P], TilesFieldLength[P]);

      for I := 0 to 9 do
        R[I] := States.KaMRandomI(3) + 1;

      for I := 21 to 26 do
      begin
        TilesFieldX[P][Length(TilesFieldX[P]) - I] := X;
        TilesFieldY[P][Length(TilesFieldX[P]) - I] := Y;
        TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := AXE_OBJECT4;
      end;

      for I := 27 to 31 do
      begin
        TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := CIRCLE_FILL_OBJ;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - I] := States.GameTime + 48;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := States.GameTime + 58;
      end;

      TilesFieldX[P][Length(TilesFieldX[P]) - 20] := X2 + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 19] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 18] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 17] := X2 + 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 20] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 19] := Y2 - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 18] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 17] := Y2 - 1;

      TilesFieldX[P][Length(TilesFieldX[P]) - 16] := X2 + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 15] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 14] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 13] := X2 + 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 16] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 15] := Y2 - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 14] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 13] := Y2 - 1;

      TilesFieldX[P][Length(TilesFieldX[P]) - 12] := X2 + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 11] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 10] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 9] := X2 + 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 12] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 11] := Y2 - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 10] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 9] := Y2 - 1;
    
      TilesFieldX[P][Length(TilesFieldX[P]) - 8] := X2 + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 7] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 6] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 5] := X2 + 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 8] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 7] := Y2 - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 6] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 5] := Y2 - 1;

      TilesFieldX[P][Length(TilesFieldX[P]) - 4] := X2 + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 3] := X2 - 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 4] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 3] := Y2 - 1;

      TilesFieldX[P][Length(TilesFieldX[P]) - 2] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X2 + 1;

      TilesFieldY[P][Length(TilesFieldY[P]) - 2] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y2 - 1;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 26] := States.GameTime + 40;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 25] := States.GameTime + 35;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 24] := States.GameTime + 29;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 23] := States.GameTime + 23;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 22] := States.GameTime + 16;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 21] := States.GameTime + 8;

      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 26] := States.GameTime + 38;    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 25] := States.GameTime + 32;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 24] := States.GameTime + 26;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 23] := States.GameTime + 20;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 22] := States.GameTime + 9;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 21] := States.GameTime + 1;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 20] := States.GameTime + 40;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 19] := States.GameTime + 40;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 18] := States.GameTime + 40;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 17] := States.GameTime + 40;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 20] := States.GameTime + 38;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 19] := States.GameTime + 38;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 18] := States.GameTime + 38;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 17] := States.GameTime + 38;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 16] := States.GameTime + 35;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 15] := States.GameTime + 35;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 14] := States.GameTime + 35;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 13] := States.GameTime + 35;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 16] := States.GameTime + 32;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 15] := States.GameTime + 32;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 14] := States.GameTime + 32;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 13] := States.GameTime + 32;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 12] := States.GameTime + 29;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 11] := States.GameTime + 29;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 10] := States.GameTime + 29;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 9] := States.GameTime + 29;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 12] := States.GameTime + 26;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 11] := States.GameTime + 26;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 10] := States.GameTime + 26;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 9] := States.GameTime + 26;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 8] := States.GameTime + 23;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 7] := States.GameTime + 23;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 6] := States.GameTime + 23;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 5] := States.GameTime + 23;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 8] := States.GameTime + 20;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 7] := States.GameTime + 20;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 6] := States.GameTime + 20;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 5] := States.GameTime + 20;
    
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 4] := States.GameTime + 16;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 3] := States.GameTime + 16;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 4] := States.GameTime + 9;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 3] := States.GameTime + 9;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 2] := States.GameTime + 8;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 8;

      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 2] := States.GameTime + 1;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 1;

      for I := 1 to 20 do
      begin
        TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := AXE_OBJECT3;
        if TileOnBattlefield(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) then
        begin
          Tiles[TilesFieldX[P][Length(TilesFieldX[P]) - I]][TilesFieldY[P][Length(TilesFieldY[P]) - I]].Owner := P;
          Tiles[TilesFieldX[P][Length(TilesFieldX[P]) - I]][TilesFieldY[P][Length(TilesFieldY[P]) - I]].Skill := sDeadlyFireworks;
          Tiles[TilesFieldX[P][Length(TilesFieldX[P]) - I]][TilesFieldY[P][Length(TilesFieldY[P]) - I]].ObjectRefreshTime := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 26];
        end;
      end;

      for I := 1 to 20 do
        if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
           ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] + CLEANUP_TIME;

      FireworksCircles1Counter[P] := FireworksCircles1Counter[P] + 1;
      if FireworksCircles1Counter[P] = MAX_CIRCLES_AT_ONCE then
        FireworksCircles1Counter[P] := 0;

      FireworksCircles2Counter[P] := FireworksCircles2Counter[P] + 1;
      if FireworksCircles2Counter[P] = MAX_CIRCLES_AT_ONCE then
        FireworksCircles2Counter[P] := 0;

      FireworksCircles3Counter[P] := FireworksCircles3Counter[P] + 1;
      if FireworksCircles3Counter[P] = MAX_CIRCLES_AT_ONCE then
        FireworksCircles3Counter[P] := 0;

      FireworksCircles4Counter[P] := FireworksCircles4Counter[P] + 1;
      if FireworksCircles4Counter[P] = MAX_CIRCLES_AT_ONCE then
        FireworksCircles4Counter[P] := 0;

      FireworksCircles5Counter[P] := FireworksCircles5Counter[P] + 1;
      if FireworksCircles5Counter[P] = MAX_CIRCLES_AT_ONCE then
        FireworksCircles5Counter[P] := 0;

      FireworksCircles1Length[P][FireworksCircles1Counter[P]] := FireworksCircles1Length[P][FireworksCircles1Counter[P]] + FIREWORKS1_CYCLES * FIREWORKS1_RADIUS;
      SetLength(FireworksCircles1[P][FireworksCircles1Counter[P]], FireworksCircles1Length[P][FireworksCircles1Counter[P]]);
      for I := FireworksCircles1Length[P][FireworksCircles1Counter[P]] downto FireworksCircles1Length[P][FireworksCircles1Counter[P]] - FIREWORKS1_CYCLES * FIREWORKS1_RADIUS + 1 do
      begin
        FireworksCircles1[P][FireworksCircles1Counter[P]][FireworksCircles1Length[P][FireworksCircles1Counter[P]] - I].Obj := AXE_OBJECT2;
        FireworksCircles1[P][FireworksCircles1Counter[P]][FireworksCircles1Length[P][FireworksCircles1Counter[P]] - I].X := X;
        FireworksCircles1[P][FireworksCircles1Counter[P]][FireworksCircles1Length[P][FireworksCircles1Counter[P]] - I].Y := Y;
        TilesFieldX[P][Length(TilesFieldX[P]) - 27] := X;
        TilesFieldY[P][Length(TilesFieldY[P]) - 27] := Y;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 27] := States.GameTime + 40;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 27] := States.GameTime + 50;
        FireworksCircles1[P][FireworksCircles1Counter[P]][FireworksCircles1Length[P][FireworksCircles1Counter[P]] - I].AddTime := States.GameTime + 40 + Round(AXE_FIELD_SPEED * (FireworksCircles1Length[P][FireworksCircles1Counter[P]] - I));
        if I mod FIREWORKS1_RADIUS > 0 then
          FireworksCircles1[P][FireworksCircles1Counter[P]][FireworksCircles1Length[P][FireworksCircles1Counter[P]] - I].Radius := FIREWORKS1_RADIUS - I mod FIREWORKS1_RADIUS
        else
          FireworksCircles1[P][FireworksCircles1Counter[P]][FireworksCircles1Length[P][FireworksCircles1Counter[P]] - I].Radius := 0;
      end;        
      for I := 0 to FireworksCircles1Length[P][FireworksCircles1Counter[P]] - 1 do 
        if I mod FIREWORKS1_RADIUS = 1 then
          FireworksCircles1[P][FireworksCircles1Counter[P]][FireworksCircles1Length[P][FireworksCircles1Counter[P]] - I].Obj := 255;

      FireworksCircles2Length[P][FireworksCircles2Counter[P]] := FireworksCircles2Length[P][FireworksCircles2Counter[P]] + FIREWORKS2_CYCLES * FIREWORKS2_RADIUS;
      SetLength(FireworksCircles2[P][FireworksCircles2Counter[P]], FireworksCircles2Length[P][FireworksCircles2Counter[P]]);
      for I := FireworksCircles2Length[P][FireworksCircles2Counter[P]] downto FireworksCircles2Length[P][FireworksCircles2Counter[P]] - FIREWORKS2_CYCLES * FIREWORKS2_RADIUS + 1 do
      begin
        FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].Obj := AXE_OBJECT2;
        FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].X := X + FIREWORKS1_RADIUS;
        FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].Y := Y;
        if R[3] < 2 then
        begin
          FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].X := X + FIREWORKS1_RADIUS - R[States.KaMRandomI(10)];
          FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].Y := Y - FIREWORKS1_RADIUS + R[States.KaMRandomI(10)];
        end;
        TilesFieldX[P][Length(TilesFieldX[P]) - 28] := FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].X;
        TilesFieldY[P][Length(TilesFieldY[P]) - 28] := FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].Y;
        FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].AddTime := States.GameTime + 48 + Round(AXE_FIELD_SPEED * (FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I));
        if I mod FIREWORKS2_RADIUS > 0 then
          FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].Radius := FIREWORKS2_RADIUS - I mod FIREWORKS2_RADIUS
        else
          FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].Radius := 0;
      end;        
      for I := 0 to FireworksCircles2Length[P][FireworksCircles2Counter[P]] - 1 do 
        if I mod FIREWORKS2_RADIUS = 1 then
          FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].Obj := 255;

      FireworksCircles3Length[P][FireworksCircles3Counter[P]] := FireworksCircles3Length[P][FireworksCircles3Counter[P]] + FIREWORKS2_CYCLES * FIREWORKS2_RADIUS;
      SetLength(FireworksCircles3[P][FireworksCircles3Counter[P]], FireworksCircles3Length[P][FireworksCircles3Counter[P]]);
      for I := FireworksCircles3Length[P][FireworksCircles3Counter[P]] downto FireworksCircles3Length[P][FireworksCircles3Counter[P]] - FIREWORKS2_CYCLES * FIREWORKS2_RADIUS + 1 do
      begin
        FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].Obj := AXE_OBJECT2;
        FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].X := X - FIREWORKS1_RADIUS;
        FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].Y := Y;
        if R[2] < 2 then
        begin
          FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].X := X - FIREWORKS1_RADIUS + R[States.KaMRandomI(10)];
          FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].Y := Y - FIREWORKS1_RADIUS + R[States.KaMRandomI(10)];
        end;
        TilesFieldX[P][Length(TilesFieldX[P]) - 29] := FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].X;
        TilesFieldY[P][Length(TilesFieldY[P]) - 29] := FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].Y;
        FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].AddTime := States.GameTime + 48 + Round(AXE_FIELD_SPEED * (FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I));
        if I mod FIREWORKS2_RADIUS > 0 then
          FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].Radius := FIREWORKS2_RADIUS - I mod FIREWORKS2_RADIUS
        else
          FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].Radius := 0;
      end;        
      for I := 0 to FireworksCircles3Length[P][FireworksCircles3Counter[P]] - 1 do 
        if I mod FIREWORKS2_RADIUS = 1 then
          FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].Obj := 255;

      FireworksCircles4Length[P][FireworksCircles4Counter[P]] := FireworksCircles4Length[P][FireworksCircles4Counter[P]] + FIREWORKS2_CYCLES * FIREWORKS2_RADIUS;
      SetLength(FireworksCircles4[P][FireworksCircles4Counter[P]], FireworksCircles4Length[P][FireworksCircles4Counter[P]]);
      for I := FireworksCircles4Length[P][FireworksCircles4Counter[P]] downto FireworksCircles4Length[P][FireworksCircles4Counter[P]] - FIREWORKS2_CYCLES * FIREWORKS2_RADIUS + 1 do
      begin
        FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].Obj := AXE_OBJECT2;
        FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].X := X;
        FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].Y := Y + FIREWORKS1_RADIUS;
        if R[1] < 2 then
        begin
          FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].X := X + FIREWORKS1_RADIUS - R[States.KaMRandomI(10)];
          FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].Y := Y + FIREWORKS1_RADIUS - R[States.KaMRandomI(10)];
        end;
        TilesFieldX[P][Length(TilesFieldX[P]) - 30] := FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].X;
        TilesFieldY[P][Length(TilesFieldY[P]) - 30] := FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].Y;
        FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].AddTime := States.GameTime + 48 + Round(AXE_FIELD_SPEED * (FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I));
        if I mod FIREWORKS2_RADIUS > 0 then
          FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].Radius := FIREWORKS2_RADIUS - I mod FIREWORKS2_RADIUS
        else
          FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].Radius := 0;
      end;        
      for I := 0 to FireworksCircles4Length[P][FireworksCircles4Counter[P]] - 1 do 
        if I mod FIREWORKS2_RADIUS = 1 then
          FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].Obj := 255;

      FireworksCircles5Length[P][FireworksCircles5Counter[P]] := FireworksCircles5Length[P][FireworksCircles5Counter[P]] + FIREWORKS2_CYCLES * FIREWORKS2_RADIUS;
      SetLength(FireworksCircles5[P][FireworksCircles5Counter[P]], FireworksCircles5Length[P][FireworksCircles5Counter[P]]);
      for I := FireworksCircles5Length[P][FireworksCircles5Counter[P]] downto FireworksCircles5Length[P][FireworksCircles5Counter[P]] - FIREWORKS2_CYCLES * FIREWORKS2_RADIUS + 1 do
      begin
        FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].Obj := AXE_OBJECT2;
        FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].X := X;
        FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].Y := Y - FIREWORKS1_RADIUS;
        if R[0] < 2 then
        begin
          FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].X := X - FIREWORKS1_RADIUS + R[States.KaMRandomI(10)];
          FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].Y := Y + FIREWORKS1_RADIUS - R[States.KaMRandomI(10)];
        end;
        TilesFieldX[P][Length(TilesFieldX[P]) - 31] := FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].X;
        TilesFieldY[P][Length(TilesFieldY[P]) - 31] := FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].Y;
        FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].AddTime := States.GameTime + 48 + Round(AXE_FIELD_SPEED * (FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I));
        if I mod FIREWORKS2_RADIUS > 0 then
          FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].Radius := FIREWORKS2_RADIUS - I mod FIREWORKS2_RADIUS
      else
        FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].Radius := 0;
      end;        
      for I := 0 to FireworksCircles5Length[P][FireworksCircles5Counter[P]] - 1 do 
        if I mod FIREWORKS2_RADIUS = 1 then
          FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].Obj := 255;

      if States.PlayerIsAI(P) then
      begin
        Players[P].SkillCastDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
        Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
        Players[P].SkillCastX := X2;
        Players[P].SkillCastY := Y2;
        Actions.GroupKillAll(Players[P].Hero, True);
      end;

      Players[P].LastUsedSkill := sDeadlyFireworks;

      Players[P].FieldSkillDelay := Round(AXE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

      TimeToClearFireworks1Array[P][FireworksCircles1Counter[P]] := FireworksCircles1[P][FireworksCircles1Counter[P]][FireworksCircles1Length[P][FireworksCircles1Counter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;
      TimeToClearFireworks2Array[P][FireworksCircles2Counter[P]] := FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;
      TimeToClearFireworks3Array[P][FireworksCircles3Counter[P]] := FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;
      TimeToClearFireworks4Array[P][FireworksCircles4Counter[P]] := FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;
      TimeToClearFireworks5Array[P][FireworksCircles5Counter[P]] := FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;

      ClearFieldTilesArrayTime[P] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 31] + CLEAR_ARRAY_FACTOR;

    end;

  end;

end;


procedure Werewolf(P, X, Y: Integer);
var
  X2, Y2, NewDir: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    NewDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    Players[P].WineSkillDelay := 0;
    Players[P].RoadSkillDelay := 0;
    Players[P].FieldSkillDelay := 0;
    Actions.GroupKillAll(Players[P].Hero, True);
    Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    Players[P].VagaX := X2;
    Players[P].VagaY := Y2;
    Players[P].VagaDir := NewDir;
    Players[P].VagaAppearTime := States.GameTime + VAGA_DELAY_OF_TURNING;
    Players[P].TempHeroType := Players[P].HeroType;
    Players[P].HeroType := 27;
    Players[P].LastUsedSkill := sWerewolf;
  end;

end;


//BOWMAN


procedure LaunchRocket(P, X, Y: Integer);
var
  X1, Y1, aX, aY, Desync, DX, DY: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if not TileOnBattlefield(X, Y) then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin

    Desync := 0;

    X1 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y1 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 18;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;

    if (Abs(X - X1) > ROCKET_USAGE_RADIUS)
    or (Abs(Y - Y1) > ROCKET_USAGE_RADIUS) then
      Exit;

    if (Abs(X - X1) < MIN_ROCKET_USAGE_RADIUS)
    and (Abs(Y - Y1) < MIN_ROCKET_USAGE_RADIUS) then
      Exit;

    DX := X - X1;
    if DX < 0 then
      DX := -1 * DX;

    DY := Y - Y1;
    if DY < 0 then
      DY := -1 * DY;

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X1 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X1 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X1 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y1 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y1 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y1 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1 - 1;

    for I := 1 to 4 do
    begin
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := BOWMAN_OBJECT;
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
      begin
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Owner := P;
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Skill := sRocket;
      end;
    end;

    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 3;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 4;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 5;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 6;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 1;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 3;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4;

    for I := 1 to 4 do
    begin
      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
      begin
         SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - I] := 0;
         ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;
         TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := BOWMAN_OBJECT5;
      end;
    end;

    if (X = X1)
    and (Y < Y1) then
    begin
      for aY := Y1 - 1 downto Y do
        if TileOnBattlefield(X, aY) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;
    end;

    if (X = X1)
    and (Y > Y1) then
    begin
      for aY := Y1 + 1 to Y do
        if TileOnBattlefield(X, aY) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;
    end;

    if (Y = Y1)
    and (X < X1) then
    begin
      for aX := X1 - 1 downto X do
        if TileOnBattlefield(aX, Y) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;
    end;

    if (Y = Y1)
    and (X > X1) then
    begin
      for aX := X1 + 1 to X do
        if TileOnBattlefield(aX, Y) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;
    end;

    if (X > X1)
    and (Y > Y1)
    and (DX < DY) then
    begin
      for aX := X1 + 1 to X1 + DX do
      for aY := Y1 + 1 to Y1 + DX do
        if (aY = Y1 + (aX - X1))
        and (TileOnBattlefield(aX, aY)) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

      for aY := Y1 + DX to Y do
        if TileOnBattlefield(X, aY) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;
      
    end;

    if (X > X1)
    and (Y > Y1)
    and (DX >= DY) then
    begin
      for aX := X1 + 1 to X1 + DY do
      for aY := Y1 + 1 to Y1 + DY do
        if (aY = Y1 + (aX - X1))
        and (TileOnBattlefield(aX, aY)) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

      for aX := X1 + DY to X do
        if TileOnBattlefield(aX, Y) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;
      
    end;

    if (X > X1)
    and (Y < Y1)
    and (DX < DY) then
    begin
      for aX := X1 + 1 to X1 + DX do
      for aY := Y1 - 1 downto Y1 - DX do
        if (aY = Y1 - (aX - X1))
        and (TileOnBattlefield(aX, aY)) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

      for aY := Y1 - DX downto Y do
        if TileOnBattlefield(X, aY) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

    end;

    if (X > X1)
    and (Y < Y1)
    and (DX >= DY) then
    begin
      for aX := X1 + 1 to X1 + DY do
      for aY := Y1 - 1 downto Y1 - DY do
        if (aY = Y1 - (aX - X1))
        and (TileOnBattlefield(aX, aY)) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

      for aX := X1 + DY to X do
        if TileOnBattlefield(aX, Y) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

    end;

    if (X < X1)
    and (Y < Y1)
    and (DX < DY) then
    begin
      for aX := X1 - 1 downto X1 - DX do
      for aY := Y1 - 1 downto Y1 - DX do
        if (aY = Y1 + (aX - X1))
        and (TileOnBattlefield(aX, aY)) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

      for aY := Y1 - DX downto Y do
        if TileOnBattlefield(X, aY) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

    end;

    if (X < X1)
    and (Y < Y1)
    and (DX >= DY) then
    begin
      for aX := X1 - 1 downto X1 - DY do
      for aY := Y1 - 1 downto Y1 - DY do
        if (aY = Y1 + (aX - X1))
        and (TileOnBattlefield(aX, aY)) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

      for aX := X1 - DY downto X do
        if TileOnBattlefield(aX, Y) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

    end;

    if (X < X1)
    and (Y > Y1)
    and (DX < DY) then
    begin
      for aX := X1 - 1 downto X1 - DX do
      for aY := Y1 + 1 to Y1 + DX do
        if (aY = Y1 - (aX - X1))
        and (TileOnBattlefield(aX, aY)) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

      for aY := Y1 + DX to Y do
        if TileOnBattlefield(X, aY) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

    end;

    if (X < X1)
    and (Y > Y1)
    and (DX >= DY) then
    begin
      for aX := X1 - 1 downto X1 - DY do
      for aY := Y1 + 1 to Y1 + DY do
        if (aY = Y1 - (aX - X1))
        and (TileOnBattlefield(aX, aY)) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

      for aX := X1 - DY downto X do
        if TileOnBattlefield(aX, Y) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

    end;

    TilesRoadLength[P] := TilesRoadLength[P] + 1;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := SetTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] + 33;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := SetTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] + 3;
    TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_ROCKET;
    Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
    Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sRocket;
    Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X1, Y1, States.KaMRandomI(8));
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastX := X1;
      Players[P].SkillCastY := Y1;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sRocket;

    Players[P].RoadSkillDelay := Round(BOWMAN_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 2 * CLEAR_ARRAY_FACTOR;

  end;

end;


procedure Prison(P, X, Y: Integer);
var
  aX, aY, X1, Y1, X2, Y2, X3, Y3, G, O, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin

    X1 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y1 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X - X1) > PRISON_USAGE_RADIUS)
    or (Abs(Y - Y1) > PRISON_USAGE_RADIUS) then
      Exit;

    X2 := X - PRISON_RADIUS;
    X3 := X + PRISON_RADIUS;
    Y2 := Y - PRISON_RADIUS;
    Y3 := Y + PRISON_RADIUS;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 18;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    end;

    for aX := X2 to X3 do
    for aY := Y2 to Y3 do
    begin
      if (TileOnBattlefield(aX, aY))      
      and (((X - aX) * (X - aX) + (Y - aY) * (Y - aY)) <= PRISON_RADIUS * PRISON_RADIUS)
      and (((X - aX) * (X - aX) + (Y - aY) * (Y - aY)) > (PRISON_RADIUS - 2) * (PRISON_RADIUS - 2)) then
      begin
        TilesFieldLength[P] := TilesFieldLength[P] + 1;
        SetLength(TilesFieldX[P], TilesFieldLength[P]);
        SetLength(TilesFieldY[P], TilesFieldLength[P]);
        SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
        TilesFieldX[P][Length(TilesFieldX[P]) - 1] := aX;
        TilesFieldY[P][Length(TilesFieldY[P]) - 1] := aY;
        if (States.MapTileObject(aX, aY) <> BARB_OBJECT3)
        and (States.MapTileObject(aX, aY) <> BOWMAN_ROCKET) then
        begin
          ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + PRISON_TIME + 1;
          SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 1;
          TilesFieldObjects[P][Length(TilesFieldObjects[P]) - 1] := BOWMAN_OBJECT5;
        end;
      end;
    end;

    for aX := X2 to X3 do
    for aY := Y2 to Y3 do
    begin
      if (TileOnBattlefield(aX, aY))      
      and (((X - aX) * (X - aX) + (Y - aY) * (Y - aY)) <= (PRISON_RADIUS - 2) * (PRISON_RADIUS - 2)) then
      begin
        G := States.GroupAt(aX, aY);
        if G > 0 then
        begin
          O := States.GroupOwner(G);
          if (G = Players[O].Hero)
          and (not Players[O].HeroPrisoned) then
            Players[O].HeroPrisonedTime := States.GameTime + PRISON_TIME + 2;
            Players[O].HeroPrisoned := True;
        end;
      end;
    end;

    if States.PlayerIsAI(P) then
    begin
      Players[P].SkillCastDir := Direction;
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastX := X1;
      Players[P].SkillCastY := Y1;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sPrison;

    Players[P].FieldSkillDelay := Round(BOWMAN_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearFieldTilesArrayTime[P] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure RevengeFromNowhere(P, X, Y, Dir: Integer);
var
  X2, Y2, X1, Y1, Direction, Desync, CircleTime: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 17;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    ExpCirclesCounter[P] := ExpCirclesCounter[P] + 1;
    if ExpCirclesCounter[P] = MAX_CIRCLES_AT_ONCE then
      ExpCirclesCounter[P] := 0;

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    ExpCirclesLength[P][ExpCirclesCounter[P]] := ExpCirclesLength[P][ExpCirclesCounter[P]] + EXP_CYCLES * EXP_RADIUS;
    SetLength(ExpCircles[P][ExpCirclesCounter[P]], ExpCirclesLength[P][ExpCirclesCounter[P]]);
    TilesWineLength[P] := TilesWineLength[P] + 9;
    SetLength(TilesWineX[P], TilesWineLength[P]);
    SetLength(TilesWineY[P], TilesWineLength[P]);
    SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
    SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
    SetLength(TilesWineObjects[P], TilesWineLength[P]);

    TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 7] := X2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2 + 1; 
    
    TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2;
    TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2;
    TilesWineX[P][Length(TilesWineX[P]) - 6] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 5] := X2; 
    
    TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 + 1;
    
    TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2 - 1;

    for I := 5 to 8 do
      TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := BOWMAN_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 13;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 14;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 15;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 16;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 3;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 4;
    
    for I := 1 to 4 do
      TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := BOWMAN_OBJECT2;
    
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 17;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 18;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 19;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 20;
    
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 5;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 6;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 7;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 8;

    for I := 1 to 8 do
    begin

      if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
      begin

        Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].Owner := P;
        Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].Skill := sRevengeFromNowhere;
        Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];

      end;

      if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
        if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
          ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

    end;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 18 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 24 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := BOWMAN_OBJECT3;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := sRevengeFromNowhere;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
               CircleTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
             end;

      2,3: for X1 := X2 + 2 to X2 + 18 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 24 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := BOWMAN_OBJECT3;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := sRevengeFromNowhere;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
               CircleTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 18 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 24 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := BOWMAN_OBJECT3;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := sRevengeFromNowhere;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
               CircleTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
             end;

      6,7: for X1 := X2 - 2 downto X2 - 18 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 24 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := BOWMAN_OBJECT3;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := sRevengeFromNowhere;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
               CircleTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
             end;
    end; 

    for I := ExpCirclesLength[P][ExpCirclesCounter[P]] downto ExpCirclesLength[P][ExpCirclesCounter[P]] - EXP_CYCLES * EXP_RADIUS + 1 do
    begin
      ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Obj := BOWMAN_OBJECT4;

      case Direction of 
      
      2,3,6,7: begin
                 ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X := X1;
                 ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y := Y2;
               end;

      0,1,4,5: begin
                 ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X := X2;
                 ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y := Y1;
               end;
      end;

      if ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X > MAX_X then
        ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X := MAX_X;

      if ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y > MAX_Y then
        ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y := MAX_Y;

      if ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X < MIN_X then
        ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X := MIN_X;

      if ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y < MIN_Y then
        ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y := MIN_Y;

      TilesWineX[P][Length(TilesWineX[P]) - 9] := ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X;    
      TilesWineY[P][Length(TilesWineY[P]) - 9] := ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 9] := CircleTime;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 9] := CircleTime + 2 * (ExpCirclesLength[P][ExpCirclesCounter[P]] - I);
      TilesWineObjects[P][Length(TilesWineObjects[P]) - 9] := CIRCLE_FILL_OBJ;
      Tiles[TilesWineX[P][Length(TilesWineX[P]) - 9]][TilesWineY[P][Length(TilesWineY[P]) - 9]].Owner := P;
      Tiles[TilesWineX[P][Length(TilesWineX[P]) - 9]][TilesWineY[P][Length(TilesWineY[P]) - 9]].Skill := sRevengeFromNowhere;

      ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].AddTime := CircleTime + 2 * (ExpCirclesLength[P][ExpCirclesCounter[P]] - I);

      if I mod EXP_RADIUS > 0 then
        ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Radius := EXP_RADIUS + 1 - I mod EXP_RADIUS
      else
        ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Radius := 1;
    end;
        
    for I := 0 to ExpCirclesLength[P][ExpCirclesCounter[P]] - 1 do 
      if I mod EXP_RADIUS = 1 then
        ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Obj := 255;

    TimeToClearExpArray[P][ExpCirclesCounter[P]] := ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;

    Players[P].LastUsedSkill := sRevengeFromNowhere;

    Players[P].WineSkillDelay := Round(BOWMAN_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 9] + CLEAR_ARRAY_FACTOR;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

  end;

end;


//WARRIOR


procedure FierySnake(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, DX1, DX2, DX3, DY1, DY2, DY3, Direction, R: Integer;
  Place: Boolean;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;
    DX1 := 0;
    DX2 := 0;
    DX3 := 0;
    DY1 := 0;
    DY2 := 0;
    DY3 := 0;

    R := States.KaMRandomI(2);

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 17;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
  
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;
    
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 10;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 12;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 14;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 4;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 6;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8;

    for I := 1 to 4 do
    begin
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
      begin
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Owner := P;
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Skill := sFierySnake;
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
      end;
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := WARRIOR_OBJECT + 3 * Byte(States.KaMRandom > 0.65);
    end;

    for I := 1 to 4 do
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
        if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    case Direction of

      0,1: begin
             for Y1 := Y2 - 2 downto Y2 - 13 do
             for X1 := X2 - 1 to X2 + 1 do
             begin
               if X1 = X2 - 1 then
                 DX1 := DX1 + 1;                  

               if X1 = X2 then
                 DX2 := DX2 + 1;

               if X1 = X2 + 1 then
                 DX3 := DX3 + 1;

               if TileOnBattlefield(X1, Y1) then
               begin
                 Desync := Desync + 1;

                 if R = 0 then
                   Place := ((X1 = X2 - 1)
                   and (DX1 mod 4 = 0))
                   or ((X1 = X2)
                   and (DX2 mod 2 = 1))
                   or ((X1 = X2 + 1)
                   and (DX3 mod 4 = 2));

                 if R = 1 then
                   Place := ((X1 = X2 - 1)
                   and (DX1 mod 4 = 2))
                   or ((X1 = X2)
                   and (DX2 mod 2 = 1))
                   or ((X1 = X2 + 1)
                   and (DX3 mod 4 = 0));

                 if Place then
                 begin
                   TilesRoadLength[P] := TilesRoadLength[P] + 1;
                   SetLength(TilesRoadX[P], TilesRoadLength[P]);
                   SetLength(TilesRoadY[P], TilesRoadLength[P]);
                   SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                   TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                   TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                   ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 28 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := WARRIOR_OBJECT3 - (States.KaMRandomI(2) + 1) * 3 * Byte(States.KaMRandomI(3) = 0);
                   Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
                   Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sFierySnake;
                   Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
                 end;
               end;
             end;
           end;

      2,3: begin
             for X1 := X2 + 2 to X2 + 13 do
             for Y1 := Y2 - 1 to Y2 + 1 do
             begin
               if Y1 = Y2 - 1 then
                 DY1 := DY1 + 1;

               if Y1 = Y2 then
                 DY2 := DY2 + 1;

               if Y1 = Y2 + 1 then
                 DY3 := DY3 + 1;

               if TileOnBattlefield(X1, Y1) then
               begin
                 Desync := Desync + 1;

                 if R = 0 then
                   Place := ((Y1 = Y2 - 1)
                   and (DY1 mod 4 = 0))
                   or ((Y1 = Y2)
                   and (DY2 mod 2 = 1))
                   or ((Y1 = Y2 + 1)
                   and (DY3 mod 4 = 2));

                 if R = 1 then
                   Place := ((Y1 = Y2 - 1)
                   and (DY1 mod 4 = 2))
                   or ((Y1 = Y2)
                   and (DY2 mod 2 = 1))
                   or ((Y1 = Y2 + 1)
                   and (DY3 mod 4 = 0));

                 if Place then
                 begin
                   TilesRoadLength[P] := TilesRoadLength[P] + 1;
                   SetLength(TilesRoadX[P], TilesRoadLength[P]);
                   SetLength(TilesRoadY[P], TilesRoadLength[P]);
                   SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                   TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                   TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                   ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 28 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := WARRIOR_OBJECT3 - (States.KaMRandomI(2) + 1) * 3 * Byte(States.KaMRandomI(3) = 0);
                   Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
                   Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sFierySnake;
                   Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
                 end;
               end;
             end;
           end;

      4,5: begin
             for Y1 := Y2 + 2 to Y2 + 13 do
             for X1 := X2 - 1 to X2 + 1 do
             begin
               if X1 = X2 - 1 then
                 DX1 := DX1 + 1;

               if X1 = X2 then
                 DX2 := DX2 + 1;

               if X1 = X2 + 1 then
                 DX3 := DX3 + 1;

               if TileOnBattlefield(X1, Y1) then
               begin
                 Desync := Desync + 1;

                 if R = 0 then
                   Place := ((X1 = X2 - 1)
                   and (DX1 mod 4 = 0))
                   or ((X1 = X2)
                   and (DX2 mod 2 = 1))
                   or ((X1 = X2 + 1)
                   and (DX3 mod 4 = 2));

                 if R = 1 then
                   Place := ((X1 = X2 - 1)
                   and (DX1 mod 4 = 2))
                   or ((X1 = X2)
                   and (DX2 mod 2 = 1))
                   or ((X1 = X2 + 1)
                   and (DX3 mod 4 = 0));

                 if Place then
                 begin
                   TilesRoadLength[P] := TilesRoadLength[P] + 1;
                   SetLength(TilesRoadX[P], TilesRoadLength[P]);
                   SetLength(TilesRoadY[P], TilesRoadLength[P]);
                   SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                   TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                   TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                   ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 28 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := WARRIOR_OBJECT3 - (States.KaMRandomI(2) + 1) * 3 * Byte(States.KaMRandomI(3) = 0);
                   Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
                   Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sFierySnake;
                   Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
                 end;
               end;
             end;
           end;

      6,7:  begin
             for X1 := X2 - 2 downto X2 - 13 do
             for Y1 := Y2 - 1 to Y2 + 1 do
             begin
               if Y1 = Y2 - 1 then
                 DY1 := DY1 + 1;

               if Y1 = Y2 then
                 DY2 := DY2 + 1;

               if Y1 = Y2 + 1 then
                 DY3 := DY3 + 1;

               if TileOnBattlefield(X1, Y1) then
               begin
                 Desync := Desync + 1;

                 if R = 0 then
                   Place := ((Y1 = Y2 - 1)
                   and (DY1 mod 4 = 0))
                   or ((Y1 = Y2)
                   and (DY2 mod 2 = 1))
                   or ((Y1 = Y2 + 1)
                   and (DY3 mod 4 = 2));

                 if R = 1 then
                   Place := ((Y1 = Y2 - 1)
                   and (DY1 mod 4 = 2))
                   or ((Y1 = Y2)
                   and (DY2 mod 2 = 1))
                   or ((Y1 = Y2 + 1)
                   and (DY3 mod 4 = 0));

                 if Place then
                 begin
                   TilesRoadLength[P] := TilesRoadLength[P] + 1;
                   SetLength(TilesRoadX[P], TilesRoadLength[P]);
                   SetLength(TilesRoadY[P], TilesRoadLength[P]);
                   SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                   TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                   TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                   ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 28 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := WARRIOR_OBJECT3 - (States.KaMRandomI(2) + 1) * 3 * Byte(States.KaMRandomI(3) = 0);
                   Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
                   Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sFierySnake;
                   Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
                 end;
               end;
             end;
           end;
      end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sFierySnake;

    Players[P].RoadSkillDelay := Round(WARRIOR_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;  


procedure SturdyArmor(P, X, Y: Integer);
var
 X2, Y2, U, O: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= ARMOR_RADIUS)
    and (Abs(Y2 - Y) <= ARMOR_RADIUS) then
    begin
      U := States.UnitAt(X, Y);
      if U > 0 then
        O := States.UnitOwner(U);
      if (U > 0)
      and (U = States.GroupMember(Players[O].Hero, 0))
      and (not Players[O].HeroImmortal)
      and (Players[P].PlayersTeam = Players[O].PlayersTeam) then
      begin
        TilesFieldLength[P] := TilesFieldLength[P] + 4;
        SetLength(TilesFieldX[P], TilesFieldLength[P]);
        SetLength(TilesFieldY[P], TilesFieldLength[P]);
        SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
  
        TilesFieldX[P][Length(TilesFieldX[P]) - 4] := X2;
        TilesFieldX[P][Length(TilesFieldX[P]) - 3] := X2;
        TilesFieldX[P][Length(TilesFieldX[P]) - 2] := X2 - 1;
        TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X2 + 1;
    
        TilesFieldY[P][Length(TilesFieldY[P]) - 4] := Y2 + 1;
        TilesFieldY[P][Length(TilesFieldY[P]) - 3] := Y2 - 1;
        TilesFieldY[P][Length(TilesFieldY[P]) - 2] := Y2;
        TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y2;

        for I := 1 to 4 do
          TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := WARRIOR_OBJECT4;
    
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 4] := States.GameTime + 11;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 3] := States.GameTime + 12;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 2] := States.GameTime + 13;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 14;
    
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 4] := States.GameTime + 1;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 3] := States.GameTime + 2;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 2] := States.GameTime + 3;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 4;

        for I := 1 to 4 do
          if TileOnBattlefield(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) then
            if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BARB_OBJECT3)
             or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_ROCKET)
             or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_OBJECT5)
             or (InRange(States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
               ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] + CLEANUP_TIME;

        Players[O].ArmorStartTime := States.GameTime + ARMOR_DELAY;
        Players[O].ArmorGiver := P;
        Players[P].LastUsedSkill := sSturdyArmor;
        Players[P].FieldSkillDelay := Round(WARRIOR_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
        ClearFieldTilesArrayTime[P] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

      end;
    end;
  end;
end;


procedure PowerWithin(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 20;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    TilesWineLength[P] := TilesWineLength[P] + 8;
    SetLength(TilesWineX[P], TilesWineLength[P]);
    SetLength(TilesWineY[P], TilesWineLength[P]);
    SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
    SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
    SetLength(TilesWineObjects[P], TilesWineLength[P]);

    TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 7] := X2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2 + 1; 
    
    TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2;
    TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2;
    TilesWineX[P][Length(TilesWineX[P]) - 6] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 5] := X2; 
    
    TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 + 1;
    
    TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2 - 1;

    for I := 1 to 8 do
    begin
      TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := WARRIOR_OBJECT6;
      if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
      begin
        Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].Owner := P;
        Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].Skill := sPowerWithin;
      end;
    end;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 13;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 14;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 15;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 16;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 3;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 4;
      
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 17;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 18;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 19;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 20;
    
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 5;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 6;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 7;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 8;

    for I := 1 to 8 do
      if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

    if States.PlayerIsAI(P) then
    begin
      Players[P].SkillCastDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sPowerWithin;

    Players[P].WineSkillDelay := Round(WARRIOR_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    Players[P].PowerWithinCircleTime := States.GameTime + 20;

  end;

end;


procedure DrawPowerWithinCircle(P: Integer);
var
  X2, Y2: Integer;
begin
  Players[P].PowerWithinCircleCycles := Players[P].PowerWithinCircleCycles + 1;
  X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
  Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
  PowerWithinCirclesCounter[P] := PowerWithinCirclesCounter[P] + 1;
  if PowerWithinCirclesCounter[P] = MAX_CIRCLES_AT_ONCE then
    PowerWithinCirclesCounter[P] := 0;
  PowerWithinCirclesLength[P][PowerWithinCirclesCounter[P]] := PowerWithinCirclesLength[P][PowerWithinCirclesCounter[P]] + POWER_RADIUS;
  SetLength(PowerWithinCircles[P][PowerWithinCirclesCounter[P]], PowerWithinCirclesLength[P][PowerWithinCirclesCounter[P]]);

  for I := PowerWithinCirclesLength[P][PowerWithinCirclesCounter[P]] downto PowerWithinCirclesLength[P][PowerWithinCirclesCounter[P]] - POWER_RADIUS + 1 do
  begin
    PowerWithinCircles[P][PowerWithinCirclesCounter[P]][PowerWithinCirclesLength[P][PowerWithinCirclesCounter[P]] - I].Obj := PikeObjects[P];
    PowerWithinCircles[P][PowerWithinCirclesCounter[P]][PowerWithinCirclesLength[P][PowerWithinCirclesCounter[P]] - I].X := X2;
    PowerWithinCircles[P][PowerWithinCirclesCounter[P]][PowerWithinCirclesLength[P][PowerWithinCirclesCounter[P]] - I].Y := Y2;
    PowerWithinCircles[P][PowerWithinCirclesCounter[P]][PowerWithinCirclesLength[P][PowerWithinCirclesCounter[P]] - I].AddTime := States.GameTime + Round(WARRIOR_WINE_SPEED * (PowerWithinCirclesLength[P][PowerWithinCirclesCounter[P]] - I));
    Players[P].PowerWithinCircleTime := PowerWithinCircles[P][PowerWithinCirclesCounter[P]][PowerWithinCirclesLength[P][PowerWithinCirclesCounter[P]] - I].AddTime + 3;
    if I mod POWER_RADIUS > 0 then
      PowerWithinCircles[P][PowerWithinCirclesCounter[P]][PowerWithinCirclesLength[P][PowerWithinCirclesCounter[P]] - I].Radius := POWER_RADIUS - I mod POWER_RADIUS
    else
      PowerWithinCircles[P][PowerWithinCirclesCounter[P]][PowerWithinCirclesLength[P][PowerWithinCirclesCounter[P]] - I].Radius := 0;

  end; 
       
  for I := 0 to PowerWithinCirclesLength[P][PowerWithinCirclesCounter[P]] - 1 do 
    if I mod POWER_RADIUS = 1 then
      PowerWithinCircles[P][PowerWithinCirclesCounter[P]][PowerWithinCirclesLength[P][PowerWithinCirclesCounter[P]] - I].Obj := 255;

  TimeToClearPowerWithinArray[P][PowerWithinCirclesCounter[P]] := PowerWithinCircles[P][PowerWithinCirclesCounter[P]][PowerWithinCirclesLength[P][PowerWithinCirclesCounter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR + 10;

  if Players[P].PowerWithinCircleCycles = POWER_CYCLES then
  begin
    Players[P].PowerWithinCircleCycles := 0;
    Players[P].PowerWithinCircleTime := 0;
  end;

end;


//KNIGHT


procedure RopesOfDeath(P, X, Y: Integer);
var
  X2, Y2, U, O, D: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    D := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    U := States.UnitAt(X, Y);
    if U <> - 1 then
      O := States.UnitOwner(U);
    if ((Abs(X2 - X) <= ROPE_RADIUS)
    and (Abs(Y2 - Y) <= ROPE_RADIUS)
    and (Players[O].PlayersTeam <> Players[P].PlayersTeam))
    or ((Abs(X2 - X) <= ROPE_ALLY_RADIUS)
    and (Abs(Y2 - Y) <= ROPE_ALLY_RADIUS)
    and (Players[O].PlayersTeam = Players[P].PlayersTeam)) then
    begin
      if States.PlayerIsAI(P) then
      begin
        Players[P].CastingSkill := True;
        Players[P].SkillTime := States.GameTime + 20;
        Actions.GroupOrderHalt(Players[P].Hero);
        Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, D);
      end;
      if (U <> - 1)
      and (InRange(O, 0, 7))
      and (O <> P)
      and (not Players[O].HeroImmortal)
      and (U = States.GroupMember(Players[O].Hero, 0)) then
      begin
        TilesRoadLength[P] := TilesRoadLength[P] + 4;
        SetLength(TilesRoadX[P], TilesRoadLength[P]);
        SetLength(TilesRoadY[P], TilesRoadLength[P]);
        SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
        SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
        SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
  
        TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2;
        TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2;
        TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
        TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
        TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
        TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
        TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2;
        TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;

        for I := 1 to 4 do
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := KNIGHT_OBJECT;
    
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 10;
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 11;
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 12;
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 13;
    
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 1;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 2;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 3;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4;

        for I := 1 to 4 do
          if TileOnBattleField(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
            if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
             or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
             or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
             or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

        Players[O].RopeTime := States.GameTime + ROPE_DELAY;
        Players[O].RopeAttacker := P;
        Players[O].MovedByRopes := True;
        Players[O].RopeUnitDir := States.UnitDirection(States.GroupMember(Players[O].Hero, 0));
        case D of

          0: begin
               Players[O].RopeDX := 0;
               Players[O].RopeDY := -1;
             end;

          1: begin
               Players[O].RopeDX := 1;
               Players[O].RopeDY := -1;
             end;

          2: begin
               Players[O].RopeDX := 1;
               Players[O].RopeDY := 0;
             end;

          3: begin
               Players[O].RopeDX := 1;
               Players[O].RopeDY := 1;
             end;

          4: begin
               Players[O].RopeDX := 0;
               Players[O].RopeDY := 1;
             end;

          5: begin
               Players[O].RopeDX := -1;
               Players[O].RopeDY := 1;
             end;

          6: begin
               Players[O].RopeDX := -1;
               Players[O].RopeDY := 0;
             end;

          7: begin
               Players[O].RopeDX := -1;
               Players[O].RopeDY := -1;
             end;

        end;

        Players[P].LastUsedSkill := sRopesOfDeath;
        Players[P].RoadSkillDelay := Round(KNIGHT_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
        ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

      end;
    end;
  end;
end;


procedure DeafeningClatter(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 10;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;

    KnightCirclesCounter[P] := KnightCirclesCounter[P] + 1;
    if KnightCirclesCounter[P] = MAX_CIRCLES_AT_ONCE then
      KnightCirclesCounter[P] := 0;

    KnightCirclesLength[P][KnightCirclesCounter[P]] := KnightCirclesLength[P][KnightCirclesCounter[P]] + DEAFENING_CYCLES * DEAFENING_RADIUS;
    SetLength(KnightCircles[P][KnightCirclesCounter[P]], KnightCirclesLength[P][KnightCirclesCounter[P]]);
    for I := KnightCirclesLength[P][KnightCirclesCounter[P]] downto KnightCirclesLength[P][KnightCirclesCounter[P]] - DEAFENING_CYCLES * DEAFENING_RADIUS + 1 do
    begin
      KnightCircles[P][KnightCirclesCounter[P]][KnightCirclesLength[P][KnightCirclesCounter[P]] - I].Obj := KNIGHT_OBJECT3;
      KnightCircles[P][KnightCirclesCounter[P]][KnightCirclesLength[P][KnightCirclesCounter[P]] - I].X := X2;
      KnightCircles[P][KnightCirclesCounter[P]][KnightCirclesLength[P][KnightCirclesCounter[P]] - I].Y := Y2;
      KnightCircles[P][KnightCirclesCounter[P]][KnightCirclesLength[P][KnightCirclesCounter[P]] - I].AddTime := States.GameTime + Round(KNIGHT_FIELD_SPEED * (KnightCirclesLength[P][KnightCirclesCounter[P]] - I));
      if I mod DEAFENING_RADIUS > 0 then
        KnightCircles[P][KnightCirclesCounter[P]][KnightCirclesLength[P][KnightCirclesCounter[P]] - I].Radius := DEAFENING_RADIUS + 2 - I mod DEAFENING_RADIUS
      else
        KnightCircles[P][KnightCirclesCounter[P]][KnightCirclesLength[P][KnightCirclesCounter[P]] - I].Radius := 1;
    end;        
    for I := 0 to KnightCirclesLength[P][KnightCirclesCounter[P]] - 1 do 
      if I mod DEAFENING_RADIUS = 1 then
        KnightCircles[P][KnightCirclesCounter[P]][KnightCirclesLength[P][KnightCirclesCounter[P]] - I].Obj := 255;

    Players[P].LastUsedSkill := sDeafeningClatter;

    Players[P].FieldSkillDelay := Round(KNIGHT_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    TimeToClearKnightArray[P][KnightCirclesCounter[P]] := KnightCircles[P][KnightCirclesCounter[P]][KnightCirclesLength[P][KnightCirclesCounter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure RagingSpurt(P, X, Y: Integer);
var
  X2, Y2, R: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    R := States.KaMRandomI(SPURT_AI_RANDOM);

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 50;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;

    Players[P].HeroStunnedTime := States.GameTime + SPURT_TIME + 5 + (SPURT_AI_FACTOR + R) * Byte(States.PlayerIsAI(P));
    Actions.GroupOrderHalt(Players[P].Hero);
    Actions.GroupBlockOrders(Players[P].Hero, True);
    Players[P].HeroStunned := True;
    Players[P].SpurtStartTime := States.GameTime + 27 + (SPURT_AI_FACTOR + R) * Byte(States.PlayerIsAI(P));

    TilesWineLength[P] := TilesWineLength[P] + 8;
    SetLength(TilesWineX[P], TilesWineLength[P]);
    SetLength(TilesWineY[P], TilesWineLength[P]);
    SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
    SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
    SetLength(TilesWineObjects[P], TilesWineLength[P]);

    TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 7] := X2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2 + 1; 
    
    TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2;
    TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2;
    TilesWineX[P][Length(TilesWineX[P]) - 6] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 5] := X2; 
    
    TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 + 1;
    
    TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2 - 1;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 13 + SPURT_AI_FACTOR * Byte(States.PlayerIsAI(P));
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 15 + SPURT_AI_FACTOR * Byte(States.PlayerIsAI(P));
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 17 + SPURT_AI_FACTOR * Byte(States.PlayerIsAI(P));
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 19 + SPURT_AI_FACTOR * Byte(States.PlayerIsAI(P));

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 2 + SPURT_AI_FACTOR/2 * Byte(States.PlayerIsAI(P));
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 4 + SPURT_AI_FACTOR/2 * Byte(States.PlayerIsAI(P));
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 6 + SPURT_AI_FACTOR/2 * Byte(States.PlayerIsAI(P));
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 8 + SPURT_AI_FACTOR/2 * Byte(States.PlayerIsAI(P));    
  
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 21 + SPURT_AI_FACTOR * Byte(States.PlayerIsAI(P));
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 23 + SPURT_AI_FACTOR * Byte(States.PlayerIsAI(P));
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 25 + SPURT_AI_FACTOR * Byte(States.PlayerIsAI(P));
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 27 + SPURT_AI_FACTOR * Byte(States.PlayerIsAI(P));
    
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 10 + SPURT_AI_FACTOR/2 * Byte(States.PlayerIsAI(P));
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 12 + SPURT_AI_FACTOR/2 * Byte(States.PlayerIsAI(P));
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 14 + SPURT_AI_FACTOR/2 * Byte(States.PlayerIsAI(P));
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 16 + SPURT_AI_FACTOR/2 * Byte(States.PlayerIsAI(P));

    for I := 1 to 8 do
      if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
      begin
        TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := KNIGHT_OBJECT2;
        Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
      end;

    for I := 1 to 8 do
      if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

    Players[P].LastUsedSkill := sRagingSpurt;

    Players[P].WineSkillDelay := Round(KNIGHT_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] + 2 * CLEAR_ARRAY_FACTOR;

  end;

end;


procedure StartSpurt(P: Integer);
var
  Desync, Direction, X1, Y1, X2, Y2, R: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if Players[P].Hero > 0 then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    Desync := 0;
    R := States.KaMRandomI(SPURT_AI_RANDOM);
    Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    Players[P].CurrentSpurtLength := 0;

    case Direction of

      0,1: begin
             for Y1 := Y2 - 1 downto Y2 - SPURT_LENGTH do
               if TileOnBattlefield(X2, Y1) then
                 Players[P].CurrentSpurtLength := Players[P].CurrentSpurtLength + 1;

             for Y1 := Y2 - 1 downto Y2 - Players[P].CurrentSpurtLength do
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 2 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED) + (SPURT_AI_FACTOR + R) * Byte(States.PlayerIsAI(P));
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 1 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED) + (SPURT_AI_FACTOR + R) * Byte(States.PlayerIsAI(P));
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := KNIGHT_OBJECT4;
               SpurtTimes[P][Desync - 1] := States.GameTime + 2 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED) + (SPURT_AI_FACTOR + R) * Byte(States.PlayerIsAI(P));
               SpurtX[P][Desync - 1] := X2;
               SpurtY[P][Desync - 1] := Y1;
               SpurtDir[P][Desync - 1] := 0;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := sRagingSpurt;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
               if (TileOnRuneSpawn(SpurtX[P][Desync - 1], SpurtY[P][Desync - 1]))
               and (not RuneTaken)
               and (RuneObject = RUNE_DOUBLE_OBJ) then
                 GetRuneEffect(P, RuneObject);
             end;

           end;

      2,3: begin
             for X1 := X2 + 1 to X2 + SPURT_LENGTH do
               if TileOnBattlefield(X1, Y2) then
                 Players[P].CurrentSpurtLength := Players[P].CurrentSpurtLength + 1;

             for X1 := X2 + 1 to X2 + Players[P].CurrentSpurtLength do
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 2 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED) + (SPURT_AI_FACTOR + R) * Byte(States.PlayerIsAI(P));
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 1 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED) + (SPURT_AI_FACTOR + R) * Byte(States.PlayerIsAI(P));
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := KNIGHT_OBJECT4;
               SpurtTimes[P][Desync - 1] := States.GameTime + 2 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED) + (SPURT_AI_FACTOR + R) * Byte(States.PlayerIsAI(P));
               SpurtX[P][Desync - 1] := X1;
               SpurtY[P][Desync - 1] := Y2;
               SpurtDir[P][Desync - 1] := 2;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := sRagingSpurt;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
               if (TileOnRuneSpawn(SpurtX[P][Desync - 1], SpurtY[P][Desync - 1]))
               and (not RuneTaken)
               and (RuneObject = RUNE_DOUBLE_OBJ) then
                 GetRuneEffect(P, RuneObject);
             end;

           end;

      4,5: begin
             for Y1 := Y2 + 1 to Y2 + SPURT_LENGTH do
               if TileOnBattlefield(X2, Y1) then
                 Players[P].CurrentSpurtLength := Players[P].CurrentSpurtLength + 1;

             for Y1 := Y2 + 1 to Y2 + Players[P].CurrentSpurtLength do
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 2 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED) + (SPURT_AI_FACTOR + R) * Byte(States.PlayerIsAI(P));
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 1 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED) + (SPURT_AI_FACTOR + R) * Byte(States.PlayerIsAI(P));
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := KNIGHT_OBJECT4;
               SpurtTimes[P][Desync - 1] := States.GameTime + 2 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED) + (SPURT_AI_FACTOR + R) * Byte(States.PlayerIsAI(P));
               SpurtX[P][Desync - 1] := X2;
               SpurtY[P][Desync - 1] := Y1;
               SpurtDir[P][Desync - 1] := 4;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := sRagingSpurt;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
               if (TileOnRuneSpawn(SpurtX[P][Desync - 1], SpurtY[P][Desync - 1]))
               and (not RuneTaken)
               and (RuneObject = RUNE_DOUBLE_OBJ) then
                 GetRuneEffect(P, RuneObject);
             end;

           end;

      6,7: begin
             for X1 := X2 - 1 downto X2 - SPURT_LENGTH do
               if TileOnBattlefield(X1, Y2) then
                 Players[P].CurrentSpurtLength := Players[P].CurrentSpurtLength + 1;

             for X1 := X2 - 1 downto X2 - Players[P].CurrentSpurtLength do 
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 2 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED) + (SPURT_AI_FACTOR + R) * Byte(States.PlayerIsAI(P));
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 1 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED) + (SPURT_AI_FACTOR + R) * Byte(States.PlayerIsAI(P));
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := KNIGHT_OBJECT4;
               SpurtTimes[P][Desync - 1] := States.GameTime + 2 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED) + (SPURT_AI_FACTOR + R) * Byte(States.PlayerIsAI(P));
               SpurtX[P][Desync - 1] := X1;
               SpurtY[P][Desync - 1] := Y2;
               SpurtDir[P][Desync - 1] := 6;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Owner := P;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].Skill := sRagingSpurt;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
               if (TileOnRuneSpawn(SpurtX[P][Desync - 1], SpurtY[P][Desync - 1]))
               and (not RuneTaken)
               and (RuneObject = RUNE_DOUBLE_OBJ) then
                 GetRuneEffect(P, RuneObject);
             end;

           end;

        end;

    Players[P].LastUsedSkill := sRagingSpurt;

    ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] + 2 * CLEAR_ARRAY_FACTOR;

  end;

end;


procedure CheckSpurt(P, Step: Integer);
begin
  if (States.GameTime = SpurtTimes[P][Step] + 1)
  and (States.GameTime > CHOOSE_HERO_TIMER)
  and (Players[P].HP > 0)
  and (TileOnBattlefield(SpurtX[P][Step], SpurtY[P][Step])) then
  begin
    Actions.GroupKillAll(Players[P].Hero, True);
    Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, SpurtX[P][Step], SpurtY[P][Step], SpurtDir[P][Step], 1, 1);
    Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
    if (TileOnRuneSpawn(SpurtX[P][Step], SpurtY[P][Step]))
    and (not RuneTaken)
    and (RuneObject <> RUNE_DOUBLE_OBJ) then
      GetRuneEffect(P, RuneObject);
  end;

  if (States.GameTime = SpurtTimes[P][Players[P].CurrentSpurtLength - 1] + 2)
  and ((States.UnitPositionX(States.GroupMember(Players[P].Hero, 0)) <> SpurtX[P][Players[P].CurrentSpurtLength - 1])
  or (States.UnitPositionY(States.GroupMember(Players[P].Hero, 0)) <> SpurtY[P][Players[P].CurrentSpurtLength - 1]))
  and (States.GameTime > CHOOSE_HERO_TIMER)
  and (Players[P].HP > 0) then
  begin
    Actions.GroupKillAll(Players[P].Hero, True);
    Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, SpurtX[P][Players[P].CurrentSpurtLength - 1], SpurtY[P][Players[P].CurrentSpurtLength - 1], SpurtDir[P][Players[P].CurrentSpurtLength - 1], 1, 1);
    Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
  end;

end;


//SCOUT


procedure Boomerang(P, X, Y, D: Integer);
var
  X1, Y1, X2, Y2, DX1, DY1, DX2, DY2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if not TileOnBattlefield(X, Y) then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin

    Desync := 0;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 18;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;

    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 7;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 8;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 9;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 10;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 1;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 3;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4;

    for I := 1 to 4 do
    begin
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := SCOUT_OBJECT5;
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
      begin
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Owner := P;
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Skill := sBoomerang;
      end;
    end;

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    case States.KaMRandomI(100) of

      0..49:  begin
                DX1 := X2 - 1;
                DY1 := Y2 - 1;
                DX2 := X2 + 1;
                DY2 := Y2 + 1;
              end;

      50..99: begin
                DX1 := X2 + 1;
                DY1 := Y2 + 1;
                DX2 := X2 - 1;
                DY2 := Y2 - 1;
              end;

    end;

    case Direction of

      0,1: begin

             if TileOnBattlefield(X2, Y2 - 2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

             for Y1 := Y2 - 3 downto Y2 - BOOMERANG_LENGTH do
               if TileOnBattlefield(DX1, Y1) then
               begin
                 Desync := Desync + 1;
                 TilesRoadLength[P] := TilesRoadLength[P] + 1;
                 SetLength(TilesRoadX[P], TilesRoadLength[P]);
                 SetLength(TilesRoadY[P], TilesRoadLength[P]);
                 SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                 TilesRoadX[P][Length(TilesRoadX[P]) - 1] := DX1;
                 TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                 ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
               end;

             if TileOnBattlefield(X2, Y2 - BOOMERANG_LENGTH - 1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - BOOMERANG_LENGTH - 1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

             for Y1 := Y2 - BOOMERANG_LENGTH to Y2 - 3 do
               if TileOnBattlefield(DX2, Y1) then
               begin
                 Desync := Desync + 1;
                 TilesRoadLength[P] := TilesRoadLength[P] + 1;
                 SetLength(TilesRoadX[P], TilesRoadLength[P]);
                 SetLength(TilesRoadY[P], TilesRoadLength[P]);
                 SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                 TilesRoadX[P][Length(TilesRoadX[P]) - 1] := DX2;
                 TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                 ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
               end;

             if TileOnBattlefield(X2, Y2 - 2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

           end;

      2,3: begin

             if TileOnBattlefield(X2 + 2, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

             for X1 := X2 + 3 to X2 + BOOMERANG_LENGTH do
               if TileOnBattlefield(X1, DY1) then
               begin
                 Desync := Desync + 1;
                 TilesRoadLength[P] := TilesRoadLength[P] + 1;
                 SetLength(TilesRoadX[P], TilesRoadLength[P]);
                 SetLength(TilesRoadY[P], TilesRoadLength[P]);
                 SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                 TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                 TilesRoadY[P][Length(TilesRoadY[P]) - 1] := DY1;
                 ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
               end;

             if TileOnBattlefield(X2 + BOOMERANG_LENGTH + 1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + BOOMERANG_LENGTH + 1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

             for X1 := X2 + BOOMERANG_LENGTH downto X2 + 3 do
               if TileOnBattlefield(X1, DY2) then
               begin
                 Desync := Desync + 1;
                 TilesRoadLength[P] := TilesRoadLength[P] + 1;
                 SetLength(TilesRoadX[P], TilesRoadLength[P]);
                 SetLength(TilesRoadY[P], TilesRoadLength[P]);
                 SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                 TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                 TilesRoadY[P][Length(TilesRoadY[P]) - 1] := DY2;
                 ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
               end;

             if TileOnBattlefield(X2 + 2, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

           end;

      4,5: begin

             if TileOnBattlefield(X2, Y2 + 2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 + 2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

             for Y1 := Y2 + 3 to Y2 + BOOMERANG_LENGTH do
               if TileOnBattlefield(DX1, Y1) then
               begin
                 Desync := Desync + 1;
                 TilesRoadLength[P] := TilesRoadLength[P] + 1;
                 SetLength(TilesRoadX[P], TilesRoadLength[P]);
                 SetLength(TilesRoadY[P], TilesRoadLength[P]);
                 SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                 TilesRoadX[P][Length(TilesRoadX[P]) - 1] := DX1;
                 TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                 ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
               end;

             if TileOnBattlefield(X2, Y2 + BOOMERANG_LENGTH + 1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 + BOOMERANG_LENGTH + 1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

             for Y1 := Y2 + BOOMERANG_LENGTH downto Y2 + 3 do
               if TileOnBattlefield(DX2, Y1) then
               begin
                 Desync := Desync + 1;
                 TilesRoadLength[P] := TilesRoadLength[P] + 1;
                 SetLength(TilesRoadX[P], TilesRoadLength[P]);
                 SetLength(TilesRoadY[P], TilesRoadLength[P]);
                 SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                 TilesRoadX[P][Length(TilesRoadX[P]) - 1] := DX2;
                 TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                 ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
               end;

             if TileOnBattlefield(X2, Y2 + 2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 + 2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

           end;

      6,7: begin

             if TileOnBattlefield(X2 - 2, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 - 2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

             for X1 := X2 - 3 downto X2 - BOOMERANG_LENGTH do
               if TileOnBattlefield(X1, DY1) then
               begin
                 Desync := Desync + 1;
                 TilesRoadLength[P] := TilesRoadLength[P] + 1;
                 SetLength(TilesRoadX[P], TilesRoadLength[P]);
                 SetLength(TilesRoadY[P], TilesRoadLength[P]);
                 SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                 TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                 TilesRoadY[P][Length(TilesRoadY[P]) - 1] := DY1;
                 ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
               end;

             if TileOnBattlefield(X2 - BOOMERANG_LENGTH - 1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 - BOOMERANG_LENGTH - 1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

             for X1 := X2 - BOOMERANG_LENGTH to X2 - 3 do
               if TileOnBattlefield(X1, DY2) then
               begin
                 Desync := Desync + 1;
                 TilesRoadLength[P] := TilesRoadLength[P] + 1;
                 SetLength(TilesRoadX[P], TilesRoadLength[P]);
                 SetLength(TilesRoadY[P], TilesRoadLength[P]);
                 SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                 TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                 TilesRoadY[P][Length(TilesRoadY[P]) - 1] := DY2;
                 ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
               end;

             if TileOnBattlefield(X2 - 2, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 - 2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Owner := P;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].Skill := sBoomerang;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

           end;

    end;

    Players[P].LastUsedSkill := sBoomerang;

    Players[P].RoadSkillDelay := Round(SCOUT_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure Silence(P, X, Y: Integer);
var
 X2, Y2, U, O: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= SILENCE_SCOUT_RADIUS)
    and (Abs(Y2 - Y) <= SILENCE_SCOUT_RADIUS) then
    begin
      U := States.UnitAt(X, Y);
      if U <> - 1 then
        O := States.UnitOwner(U);
      if (U <> - 1)
      and (U = States.GroupMember(Players[O].Hero, 0))
      and (not Players[O].HeroInFear)
      and (not Players[O].HeroStunned)
      and (not Players[O].HeroSilent)
      and (not Players[O].HeroImmortal)
      and (O <> P)
      and (Players[P].PlayersTeam <> Players[O].PlayersTeam) then
      begin
        TilesFieldLength[P] := TilesFieldLength[P] + 4;
        SetLength(TilesFieldX[P], TilesFieldLength[P]);
        SetLength(TilesFieldY[P], TilesFieldLength[P]);
        SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
  
        TilesFieldX[P][Length(TilesFieldX[P]) - 4] := X2;
        TilesFieldX[P][Length(TilesFieldX[P]) - 3] := X2;
        TilesFieldX[P][Length(TilesFieldX[P]) - 2] := X2 - 1;
        TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X2 + 1;
    
        TilesFieldY[P][Length(TilesFieldY[P]) - 4] := Y2 + 1;
        TilesFieldY[P][Length(TilesFieldY[P]) - 3] := Y2 - 1;
        TilesFieldY[P][Length(TilesFieldY[P]) - 2] := Y2;
        TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y2;

        for I := 1 to 4 do
          TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := SCOUT_OBJECT7;
    
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 4] := States.GameTime + 8;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 3] := States.GameTime + 9;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 2] := States.GameTime + 10;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 11;
    
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 4] := States.GameTime + 1;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 3] := States.GameTime + 2;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 2] := States.GameTime + 3;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 4;

        for I := 1 to 4 do
          if TileOnBattlefield(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) then
            if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BARB_OBJECT3)
             or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_ROCKET)
             or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_OBJECT5)
             or (InRange(States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
               ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] + CLEANUP_TIME;

        Players[O].ScoutSilenceStartTime := States.GameTime + SILENCE_SCOUT_DELAY;
        Players[O].ScoutSilenceGiver := P;
        Players[P].LastUsedSkill := sSilence;
        Players[P].FieldSkillDelay := Round(SCOUT_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
        ClearFieldTilesArrayTime[P] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;
      end;
    end;
  end;

end;


procedure Mind(P, X, Y: Integer);
var
 X2, Y2, U, O: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= MIND_RADIUS)
    and (Abs(Y2 - Y) <= MIND_RADIUS) then
    begin
      U := States.UnitAt(X, Y);
      if U <> - 1 then
        O := States.UnitOwner(U);
      if (U <> - 1)
      and (U = States.GroupMember(Players[O].Hero, 0))
      and (not Players[O].HeroInFear)
      and (not Players[O].HeroImmortal)
      and (not Players[O].MindStunned)
      and (not Players[P].CaptureMind)
      and (not Players[P].MindStunned)
      and (not Players[O].CaptureMind)
      and (O <> P)
      and (Players[P].PlayersTeam <> Players[O].PlayersTeam) then
      begin
        TilesWineLength[P] := TilesWineLength[P] + 32;
        SetLength(TilesWineX[P], TilesWineLength[P]);
        SetLength(TilesWineY[P], TilesWineLength[P]);
        SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
        SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
        SetLength(TilesWineObjects[P], TilesWineLength[P]);

        TilesWineX[P][Length(TilesWineX[P]) - 32] := X;
        TilesWineX[P][Length(TilesWineX[P]) - 31] := X + 1;
        TilesWineX[P][Length(TilesWineX[P]) - 30] := X + 1;
        TilesWineX[P][Length(TilesWineX[P]) - 29] := X + 1;

        TilesWineY[P][Length(TilesWineY[P]) - 32] := Y - 1;
        TilesWineY[P][Length(TilesWineY[P]) - 31] := Y - 1;
        TilesWineY[P][Length(TilesWineY[P]) - 30] := Y;
        TilesWineY[P][Length(TilesWineY[P]) - 29] := Y + 1;

        TilesWineX[P][Length(TilesWineX[P]) - 28] := X;
        TilesWineX[P][Length(TilesWineX[P]) - 27] := X - 1;
        TilesWineX[P][Length(TilesWineX[P]) - 26] := X - 1;
        TilesWineX[P][Length(TilesWineX[P]) - 25] := X - 1;

        TilesWineY[P][Length(TilesWineY[P]) - 28] := Y + 1;
        TilesWineY[P][Length(TilesWineY[P]) - 27] := Y + 1;
        TilesWineY[P][Length(TilesWineY[P]) - 26] := Y;
        TilesWineY[P][Length(TilesWineY[P]) - 25] := Y - 1;
           
        TilesWineX[P][Length(TilesWineX[P]) - 24] := X;
        TilesWineX[P][Length(TilesWineX[P]) - 23] := X + 1;
        TilesWineX[P][Length(TilesWineX[P]) - 22] := X + 1;
        TilesWineX[P][Length(TilesWineX[P]) - 21] := X + 1;

        TilesWineY[P][Length(TilesWineY[P]) - 24] := Y - 1;
        TilesWineY[P][Length(TilesWineY[P]) - 23] := Y - 1;
        TilesWineY[P][Length(TilesWineY[P]) - 22] := Y;
        TilesWineY[P][Length(TilesWineY[P]) - 21] := Y + 1;

        TilesWineX[P][Length(TilesWineX[P]) - 20] := X;
        TilesWineX[P][Length(TilesWineX[P]) - 19] := X - 1;
        TilesWineX[P][Length(TilesWineX[P]) - 18] := X - 1;
        TilesWineX[P][Length(TilesWineX[P]) - 17] := X - 1;

        TilesWineY[P][Length(TilesWineY[P]) - 20] := Y + 1;
        TilesWineY[P][Length(TilesWineY[P]) - 19] := Y + 1;
        TilesWineY[P][Length(TilesWineY[P]) - 18] := Y;
        TilesWineY[P][Length(TilesWineY[P]) - 17] := Y - 1;

        TilesWineX[P][Length(TilesWineX[P]) - 16] := X2;
        TilesWineX[P][Length(TilesWineX[P]) - 15] := X2 + 1;
        TilesWineX[P][Length(TilesWineX[P]) - 14] := X2 + 1;
        TilesWineX[P][Length(TilesWineX[P]) - 13] := X2 + 1;

        TilesWineY[P][Length(TilesWineY[P]) - 16] := Y2 - 1;
        TilesWineY[P][Length(TilesWineY[P]) - 15] := Y2 - 1;
        TilesWineY[P][Length(TilesWineY[P]) - 14] := Y2;
        TilesWineY[P][Length(TilesWineY[P]) - 13] := Y2 + 1;

        TilesWineX[P][Length(TilesWineX[P]) - 12] := X2;
        TilesWineX[P][Length(TilesWineX[P]) - 11] := X2 - 1;
        TilesWineX[P][Length(TilesWineX[P]) - 10] := X2 - 1;
        TilesWineX[P][Length(TilesWineX[P]) - 9] := X2 - 1;

        TilesWineY[P][Length(TilesWineY[P]) - 12] := Y2 + 1;
        TilesWineY[P][Length(TilesWineY[P]) - 11] := Y2 + 1;
        TilesWineY[P][Length(TilesWineY[P]) - 10] := Y2;
        TilesWineY[P][Length(TilesWineY[P]) - 9] := Y2 - 1;
           
        TilesWineX[P][Length(TilesWineX[P]) - 8] := X2;
        TilesWineX[P][Length(TilesWineX[P]) - 7] := X2 + 1;
        TilesWineX[P][Length(TilesWineX[P]) - 6] := X2 + 1;
        TilesWineX[P][Length(TilesWineX[P]) - 5] := X2 + 1;

        TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2 - 1;
        TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2 - 1;
        TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2;
        TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2 + 1;

        TilesWineX[P][Length(TilesWineX[P]) - 4] := X2;
        TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 - 1;
        TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
        TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 - 1;

        TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
        TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 + 1;
        TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2;
        TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2 - 1;

        for I := 1 to 32 do
          TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := SCOUT_OBJECT4;

        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 32] := States.GameTime + 18;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 31] := States.GameTime + 21;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 30] := States.GameTime + 24;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 29] := States.GameTime + 27;
    
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 32] := States.GameTime + 15;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 31] := States.GameTime + 18;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 30] := States.GameTime + 21;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 29] := States.GameTime + 24;

        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 28] := States.GameTime + 18;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 27] := States.GameTime + 21;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 26] := States.GameTime + 24;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 25] := States.GameTime + 27;
    
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 28] := States.GameTime + 15;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 27] := States.GameTime + 18;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 26] := States.GameTime + 21;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 25] := States.GameTime + 24;

        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 24] := States.GameTime + 6;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 23] := States.GameTime + 9;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 22] := States.GameTime + 12;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 21] := States.GameTime + 15;
    
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 24] := States.GameTime + 3;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 23] := States.GameTime + 6;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 22] := States.GameTime + 9;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 21] := States.GameTime + 12;

        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 20] := States.GameTime + 6;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 19] := States.GameTime + 9;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 18] := States.GameTime + 12;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 17] := States.GameTime + 15;
    
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 20] := States.GameTime + 3;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 19] := States.GameTime + 6;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 18] := States.GameTime + 9;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 17] := States.GameTime + 12;

        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 16] := States.GameTime + 18;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 15] := States.GameTime + 21;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 14] := States.GameTime + 24;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 13] := States.GameTime + 27;
    
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 16] := States.GameTime + 15;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 15] := States.GameTime + 18;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 14] := States.GameTime + 21;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 13] := States.GameTime + 24;

        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 12] := States.GameTime + 18;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 11] := States.GameTime + 21;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 10] := States.GameTime + 24;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 9] := States.GameTime + 27;
    
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 12] := States.GameTime + 15;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 11] := States.GameTime + 18;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 10] := States.GameTime + 21;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 9] := States.GameTime + 24;

        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 6;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 9;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 12;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 15;
    
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 3;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 6;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 9;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 12;

        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 6;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 9;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 12;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 15;
    
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 3;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 6;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 9;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 12;

        for I := 1 to 32 do
          if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
          or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
          or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
          or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
          ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

        M[P] := O;
        M2[O] := P;

        Players[P].MindX := X;
        Players[P].MindY := Y;
        Players[P].MindDir := States.UnitDirection(States.GroupMember(Players[O].Hero, 0));
        Players[P].MindX2 := X2;
        Players[P].MindY2 := Y2;
        Players[P].MindDir2 := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

        Actions.GroupKillAll(Players[P].Hero, True);
        Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
        Actions.GroupKillAll(Players[O].Hero, True);
        Players[O].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[O].HeroType, Players[O].TempX, Players[O].TempY, 4, 1, 1);

        Players[P].MindTime := States.GameTime + DELAY_OF_TURNING;
        Players[P].WineSkillDelay := 20;

        ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 9] + CLEAR_ARRAY_FACTOR;

      end;
    end;
  end;
end;



//ROGUE


procedure MentalBurst(P, X, Y, Dir: Integer; aStolen: Boolean);
var
  X2, Y2, Direction, Desync: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 17;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    if (InRange(Direction, 0, 1))
    and (not TileOnBattlefield(X2, Y2 - MENTAL_DISTANCE)) then
      Exit;

    if (InRange(Direction, 2, 3))
    and (not TileOnBattlefield(X2 + MENTAL_DISTANCE, Y2)) then
      Exit;

    if (InRange(Direction, 4, 5))
    and (not TileOnBattlefield(X2, Y2 + MENTAL_DISTANCE)) then
      Exit;

    if (InRange(Direction, 6, 7))
    and (not TileOnBattlefield(X2 - MENTAL_DISTANCE, Y2)) then
      Exit;

    if not aStolen then
    begin
      RogueCirclesCounter[P] := RogueCirclesCounter[P] + 1;
      if RogueCirclesCounter[P] = MAX_CIRCLES_AT_ONCE then
        RogueCirclesCounter[P] := 0;
      RogueCirclesLength[P][RogueCirclesCounter[P]] := RogueCirclesLength[P][RogueCirclesCounter[P]] + MENTAL_CYCLES * MENTAL_RADIUS;
      SetLength(RogueCircles[P][RogueCirclesCounter[P]], RogueCirclesLength[P][RogueCirclesCounter[P]]);
    end;
    if aStolen then
    begin
      StolenRogueCirclesCounter[P] := StolenRogueCirclesCounter[P] + 1;
      if StolenRogueCirclesCounter[P] = MAX_CIRCLES_AT_ONCE then
        StolenRogueCirclesCounter[P] := 0;
      StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] := StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] + MENTAL_CYCLES * MENTAL_RADIUS;
      SetLength(StolenRogueCircles[P][StolenRogueCirclesCounter[P]], StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]]);
    end;
    TilesRoadLength[P] := TilesRoadLength[P] + 5;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);

    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;
   
    for I := 1 to 4 do
    begin
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := ROGUE_OBJECT2;
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
      begin
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Owner := P;
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Skill := sMentalBurst;
      end;
    end;
    
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 10;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 12;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 14;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 4;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 6;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8;

    for I := 1 to 5 do
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
        if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    if not aStolen then
    begin
      for I := RogueCirclesLength[P][RogueCirclesCounter[P]] downto RogueCirclesLength[P][RogueCirclesCounter[P]] - MENTAL_CYCLES * MENTAL_RADIUS + 1 do
      begin
        RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].Obj := ROGUE_OBJECT;

        case Direction of 
      
        0,1: begin
               RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].X := X2;
               RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].Y := Y2 - MENTAL_DISTANCE;
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2;    
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2 - MENTAL_DISTANCE;
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := CIRCLE_FILL_OBJ;
               TimeToClearRogueArray[P][RogueCirclesCounter[P]] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               Players[P].LastUsedSkill := sMentalBurst;
               Players[P].RoadSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] + CLEAR_ARRAY_FACTOR;
               if Players[P].StolenSkill = sMentalBurst then
                 if Players[P].WineSkillDelay < ROGUE_MENTAL_DELAY then
                   Players[P].WineSkillDelay := ROGUE_MENTAL_DELAY;
               if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - 5], TilesRoadY[P][Length(TilesRoadY[P]) - 5]) then
               begin
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 5]][TilesRoadY[P][Length(TilesRoadY[P]) - 5]].Owner := P;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 5]][TilesRoadY[P][Length(TilesRoadY[P]) - 5]].Skill := sMentalBurst;
               end;
             end;

        2,3: begin
               RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].X := X2 + MENTAL_DISTANCE;
               RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].Y := Y2;
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2 + MENTAL_DISTANCE;    
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2;
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := CIRCLE_FILL_OBJ;
               TimeToClearRogueArray[P][RogueCirclesCounter[P]] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               Players[P].LastUsedSkill := sMentalBurst;
               Players[P].RoadSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] + CLEAR_ARRAY_FACTOR;
               if Players[P].StolenSkill = sMentalBurst then
                 if Players[P].WineSkillDelay < ROGUE_MENTAL_DELAY then
                   Players[P].WineSkillDelay := ROGUE_MENTAL_DELAY;
               if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - 5], TilesRoadY[P][Length(TilesRoadY[P]) - 5]) then
               begin
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 5]][TilesRoadY[P][Length(TilesRoadY[P]) - 5]].Owner := P;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 5]][TilesRoadY[P][Length(TilesRoadY[P]) - 5]].Skill := sMentalBurst;
               end;
             end;

        4,5: begin
               RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].X := X2;
               RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].Y := Y2 + MENTAL_DISTANCE;
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2;    
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2 + MENTAL_DISTANCE;
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := CIRCLE_FILL_OBJ;
               TimeToClearRogueArray[P][RogueCirclesCounter[P]] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               Players[P].LastUsedSkill := sMentalBurst;
               Players[P].RoadSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] + CLEAR_ARRAY_FACTOR;
               if Players[P].StolenSkill = sMentalBurst then
                 if Players[P].WineSkillDelay < ROGUE_MENTAL_DELAY then
                   Players[P].WineSkillDelay := ROGUE_MENTAL_DELAY;
               if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - 5], TilesRoadY[P][Length(TilesRoadY[P]) - 5]) then
               begin
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 5]][TilesRoadY[P][Length(TilesRoadY[P]) - 5]].Owner := P;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 5]][TilesRoadY[P][Length(TilesRoadY[P]) - 5]].Skill := sMentalBurst;
               end;
             end;

        6,7: begin
               RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].X := X2 - MENTAL_DISTANCE;
               RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].Y := Y2;
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2 - MENTAL_DISTANCE;    
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2;
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := CIRCLE_FILL_OBJ;
               TimeToClearRogueArray[P][RogueCirclesCounter[P]] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               Players[P].LastUsedSkill := sMentalBurst;
               Players[P].RoadSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] + CLEAR_ARRAY_FACTOR;
               if Players[P].StolenSkill = sMentalBurst then
                 if Players[P].WineSkillDelay < ROGUE_MENTAL_DELAY then
                   Players[P].WineSkillDelay := ROGUE_MENTAL_DELAY;
               if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - 5], TilesRoadY[P][Length(TilesRoadY[P]) - 5]) then
               begin
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 5]][TilesRoadY[P][Length(TilesRoadY[P]) - 5]].Owner := P;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 5]][TilesRoadY[P][Length(TilesRoadY[P]) - 5]].Skill := sMentalBurst;
               end;
             end;

      end;

      RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].AddTime := States.GameTime + 20 + Round(ROGUE_ROAD_SPEED * (RogueCirclesLength[P][RogueCirclesCounter[P]] - I));
      if I mod MENTAL_RADIUS > 0 then
        RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].Radius := MENTAL_RADIUS + 1 - I mod MENTAL_RADIUS
      else
        RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].Radius := 1;
      end;
        
      for I := 0 to RogueCirclesLength[P][RogueCirclesCounter[P]] - 1 do 
        if I mod MENTAL_RADIUS = 1 then
          RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].Obj := 255;

     TimeToClearRogueArray[P][RogueCirclesCounter[P]] := RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;

    end;

    if aStolen then
    begin
      for I := StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] downto StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - MENTAL_CYCLES * MENTAL_RADIUS + 1 do
      begin
        StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].Obj := ROGUE_OBJECT;

        case Direction of 
      
        0,1: begin
               StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].X := X2;
               StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].Y := Y2 - MENTAL_DISTANCE;
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2;    
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2 - MENTAL_DISTANCE;
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := CIRCLE_FILL_OBJ;
               TimeToClearStolenRogueArray[P][StolenRogueCirclesCounter[P]] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               Players[P].LastUsedSkill := sMentalBurst;
               Players[P].WineSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] + CLEAR_ARRAY_FACTOR;
               if Players[P].RoadSkillDelay < ROGUE_MENTAL_DELAY then
                 Players[P].RoadSkillDelay := ROGUE_MENTAL_DELAY;
               if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - 5], TilesRoadY[P][Length(TilesRoadY[P]) - 5]) then
               begin
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 5]][TilesRoadY[P][Length(TilesRoadY[P]) - 5]].Owner := P;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 5]][TilesRoadY[P][Length(TilesRoadY[P]) - 5]].Skill := sMentalBurst;
               end;
             end;

        2,3: begin
               StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].X := X2 + MENTAL_DISTANCE;
               StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].Y := Y2;
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2 + MENTAL_DISTANCE;    
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2;
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := CIRCLE_FILL_OBJ;
               TimeToClearStolenRogueArray[P][StolenRogueCirclesCounter[P]] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               Players[P].LastUsedSkill := sMentalBurst;
               Players[P].WineSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] + CLEAR_ARRAY_FACTOR;
               if Players[P].RoadSkillDelay < ROGUE_MENTAL_DELAY then
                 Players[P].RoadSkillDelay := ROGUE_MENTAL_DELAY;
               if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - 5], TilesRoadY[P][Length(TilesRoadY[P]) - 5]) then
               begin
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 5]][TilesRoadY[P][Length(TilesRoadY[P]) - 5]].Owner := P;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 5]][TilesRoadY[P][Length(TilesRoadY[P]) - 5]].Skill := sMentalBurst;
               end;
             end;

        4,5: begin
               StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].X := X2;
               StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].Y := Y2 + MENTAL_DISTANCE;
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2;    
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2 + MENTAL_DISTANCE;
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := CIRCLE_FILL_OBJ;
               TimeToClearStolenRogueArray[P][StolenRogueCirclesCounter[P]] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               Players[P].LastUsedSkill := sMentalBurst;
               Players[P].WineSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] + CLEAR_ARRAY_FACTOR;
               if Players[P].RoadSkillDelay < ROGUE_MENTAL_DELAY then
                 Players[P].RoadSkillDelay := ROGUE_MENTAL_DELAY;
               if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - 5], TilesRoadY[P][Length(TilesRoadY[P]) - 5]) then
               begin
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 5]][TilesRoadY[P][Length(TilesRoadY[P]) - 5]].Owner := P;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 5]][TilesRoadY[P][Length(TilesRoadY[P]) - 5]].Skill := sMentalBurst;
               end;
             end;

        6,7: begin
               StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].X := X2 - MENTAL_DISTANCE;
               StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].Y := Y2;
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2 - MENTAL_DISTANCE;    
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2;
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := CIRCLE_FILL_OBJ;
               TimeToClearStolenRogueArray[P][StolenRogueCirclesCounter[P]] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               Players[P].LastUsedSkill := sMentalBurst;
               Players[P].WineSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] + CLEAR_ARRAY_FACTOR;
               if Players[P].RoadSkillDelay < ROGUE_MENTAL_DELAY then
                 Players[P].RoadSkillDelay := ROGUE_MENTAL_DELAY;
               if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - 5], TilesRoadY[P][Length(TilesRoadY[P]) - 5]) then
               begin
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 5]][TilesRoadY[P][Length(TilesRoadY[P]) - 5]].Owner := P;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 5]][TilesRoadY[P][Length(TilesRoadY[P]) - 5]].Skill := sMentalBurst;
               end;
             end;

      end;

      StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].AddTime := States.GameTime + 20 + Round(ROGUE_ROAD_SPEED * (StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I));
      if I mod MENTAL_RADIUS > 0 then
        StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].Radius := MENTAL_RADIUS + 1 - I mod MENTAL_RADIUS
      else
        StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].Radius := 1;
      end;
        
      for I := 0 to StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - 1 do 
        if I mod MENTAL_RADIUS = 1 then
          StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].Obj := 255;

      TimeToClearStolenRogueArray[P][StolenRogueCirclesCounter[P]] := StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;

    end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

  end;

end;


procedure StealSkill(P, X, Y: Integer);
var
  X2, Y2, U, O: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= STEAL_RADIUS)
    and (Abs(Y2 - Y) <= STEAL_RADIUS) then
    begin
      U := States.UnitAt(X, Y);
      if U <> - 1 then
        O := States.UnitOwner(U);
      if (U <> - 1)
      and ((U = States.GroupMember(Players[O].Hero, 0))
      and (not Players[O].HeroImmortal)
      and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
      or (InRange(O, 8, 11))) then
      begin
        TilesFieldLength[P] := TilesFieldLength[P] + 4;
        SetLength(TilesFieldX[P], TilesFieldLength[P]);
        SetLength(TilesFieldY[P], TilesFieldLength[P]);
        SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
  
        TilesFieldX[P][Length(TilesFieldX[P]) - 4] := X2;
        TilesFieldX[P][Length(TilesFieldX[P]) - 3] := X2;
        TilesFieldX[P][Length(TilesFieldX[P]) - 2] := X2 - 1;
        TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X2 + 1;
    
        TilesFieldY[P][Length(TilesFieldY[P]) - 4] := Y2 + 1;
        TilesFieldY[P][Length(TilesFieldY[P]) - 3] := Y2 - 1;
        TilesFieldY[P][Length(TilesFieldY[P]) - 2] := Y2;
        TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y2;

        for I := 1 to 4 do
          TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := ROGUE_OBJECT3;
    
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 4] := States.GameTime + 11;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 3] := States.GameTime + 12;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 2] := States.GameTime + 13;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 14;
    
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 4] := States.GameTime + 1;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 3] := States.GameTime + 2;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 2] := States.GameTime + 3;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 4;

        for I := 1 to 4 do
          if TileOnBattlefield(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) then
            if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BARB_OBJECT3)
             or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_ROCKET)
             or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_OBJECT5)
             or (InRange(States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
               ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] + CLEANUP_TIME;

        if InRange(O, 0, 7) then
          Players[P].StolenSkill := Players[O].LastUsedSkill;

        if InRange(O, 8, 11) then
          if States.KaMRandom < 0.7 then
            Actions.UnitKill(U, False);

        case Players[P].StolenSkill of

          sFieryLance: Players[P].StolenSkillName := '<$12>';
          sTeleport: Players[P].StolenSkillName := '<$20>';
          s10kSpears: Players[P].StolenSkillName := '<$28>';

          sCrackingEarth: Players[P].StolenSkillName := '<$14>';
          sWaveOfRage: Players[P].StolenSkillName := '<$22>';
          sTotem: Players[P].StolenSkillName := '<$30>';

          sSpikedEarth: Players[P].StolenSkillName := '<$9>';
          sZombieSummon: Players[P].StolenSkillName := '<$17>';
          sFear: Players[P].StolenSkillName := '<$25>';

          sAccurateShot: Players[P].StolenSkillName := '<$11>';
          sSuddenDeath: Players[P].StolenSkillName := '<$19>';
          sSniperShot: Players[P].StolenSkillName := '<$27>';

          sGravity: Players[P].StolenSkillName := '<$8>';
          sDeadlyFireworks: Players[P].StolenSkillName := '<$16>';
          sWerewolf: Players[P].StolenSkillName := '<$24>';

          sDisorientation: Players[P].StolenSkillName := '<$15>';
          sTrack: Players[P].StolenSkillName := '<$23>';
          sRegen: Players[P].StolenSkillName := '<$31>';

          sViseOfDeath: Players[P].StolenSkillName := '<$13>';
          sSacrificialTeleport: Players[P].StolenSkillName := '<$21>';
          sConcentration: Players[P].StolenSkillName := '<$29>';

          sRocket: Players[P].StolenSkillName := '<$10>';
          sPrison: Players[P].StolenSkillName := '<$18>';
          sRevengeFromNowhere: Players[P].StolenSkillName := '<$26>';

          sFierySnake: Players[P].StolenSkillName := '<$46>';
          sSturdyArmor: Players[P].StolenSkillName := '<$47>';
          sPowerWithin: Players[P].StolenSkillName := '<$48>';

          sRopesOfDeath: Players[P].StolenSkillName := '<$50>';
          sDeafeningClatter: Players[P].StolenSkillName := '<$51>';
          sRagingSpurt: Players[P].StolenSkillName := '<$52>';

          sMentalBurst: Players[P].StolenSkillName := '<$55>';
          sSteal: Players[P].StolenSkillName := '<$56>';
          sUniversal: Players[P].StolenSkillName := '<$57>';

          sBoomerang: Players[P].StolenSkillName := '<$80>';
          sSilence: Players[P].StolenSkillName := '<$81>';
          sMind: Players[P].StolenSkillName := '<$102>';

          sNone: Players[P].StolenSkillName := '<$58>';

        end;

        Players[P].LastUsedSkill := sSteal;
        Players[P].FieldSkillDelay := Round(ROGUE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

        if InRange(O, 0, 7) then
        begin

          if Players[P].StolenSkill = sTotem then
            Players[P].WineSkillDelay := ROGUE_TOTEM_DELAY

          else

          if Players[P].StolenSkill = sDeadlyFireworks then
            Players[P].WineSkillDelay := ROGUE_FIREWORKS_DELAY

          else

          if Players[P].StolenSkill = sRevengeFromNowhere then
            Players[P].WineSkillDelay := ROGUE_REVENGE_DELAY

          else

          if (Players[P].StolenSkill <> sRevengeFromNowhere)
          and (Players[P].StolenSkill <> sDeadlyFireworks)
          and (Players[P].StolenSkill <> sTotem) then
            Players[P].WineSkillDelay := ROGUE_WINE_DELAY;

          if Players[P].StolenSkill <> sNone then
            Players[P].StolenSkillTime := STOLEN_SKILL_TIME;

        end;

        ClearFieldTilesArrayTime[P] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

      end;
    end;
  end;
end;


procedure UseStolenSkill(P, X, Y, Dir: Integer);
var
  X2, Y2, Direction, Desync, TempRoadSkillDelay, TempFieldSkillDelay, U, O: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    TempRoadSkillDelay := 0;
    TempFieldSkillDelay := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 17;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    U := States.UnitAt(X, Y);
    if U > 0 then
      O := States.UnitOwner(U);

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    case Players[P].StolenSkill of

      sFieryLance: begin
                     TempRoadSkillDelay := Players[P].RoadSkillDelay;
                     FieryLance(P, X, Y, -1);
                     Players[P].RoadSkillDelay := TempRoadSkillDelay;
                     Players[P].WineSkillDelay := Round(LANCE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                   end;

      sTeleport: if (Abs(X - X2) <= TELEPORT_RADIUS)
                 and (Abs(Y - Y2) <= TELEPORT_RADIUS) then
                 begin
                   TempFieldSkillDelay := Players[P].FieldSkillDelay;
                   Teleport(P, X, Y);
                   Players[P].FieldSkillDelay := TempFieldSkillDelay;
                   Players[P].WineSkillDelay := Round(LANCE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                 end;

      s10kSpears: TenThousandsSpears(P, X, Y, -1);

      sCrackingEarth: begin
                        TempRoadSkillDelay := Players[P].RoadSkillDelay;
                        CrackingEarth(P, X, Y, -1);
                        Players[P].RoadSkillDelay := TempRoadSkillDelay;
                        Players[P].WineSkillDelay := Round(BARB_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                      end;

      sWaveOfRage: begin
                     TempFieldSkillDelay := Players[P].FieldSkillDelay;
                     WaveOfRage(P, X, Y);
                     Players[P].FieldSkillDelay := TempFieldSkillDelay;
                     Players[P].WineSkillDelay := Round(BARB_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                   end;

      sTotem: if (Abs(X - X2) <= TOTEM_ADD_RADIUS)
              and (Abs(Y - Y2) <= TOTEM_ADD_RADIUS) then
                TotemOfAncestors(P, X, Y);

      sSpikedEarth: begin
                      TempRoadSkillDelay := Players[P].RoadSkillDelay;
                      SpikedEarth(P, X, Y, -1);
                      Players[P].RoadSkillDelay := TempRoadSkillDelay;
                      Players[P].WineSkillDelay := Round(SWORD_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                    end;

      sZombieSummon: if (Abs(X - X2) <= MILIZOMBIE_RADIUS)
                     and (Abs(Y - Y2) <= MILIZOMBIE_RADIUS) then
                     begin
                       TempFieldSkillDelay := Players[P].FieldSkillDelay;
                       ZombieSummon(P, X, Y);
                       Players[P].FieldSkillDelay := TempFieldSkillDelay;
                       Players[P].WineSkillDelay := Round(SWORD_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                     end;

      sFear: if (U > 0)
             and (InRange(O, 0, 7))
             and (Abs(X - X2) <= IN_FEAR_RADIUS)
             and (Abs(Y - Y2) <= IN_FEAR_RADIUS)
             and (Players[P].PlayersTeam <> Players[O].PlayersTeam) then
               Fear(P, X, Y);

      sAccurateShot: begin
                       TempRoadSkillDelay := Players[P].RoadSkillDelay;
                       AccurateShot(P, X, Y, -1);
                       Players[P].RoadSkillDelay := TempRoadSkillDelay;
                       Players[P].WineSkillDelay := Round(XBOW_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                     end;

      sSuddenDeath: if (Abs(X - X2) <= BOMB_RADIUS)
                    and (Abs(Y - Y2) <= BOMB_RADIUS) then
                    begin
                      TempFieldSkillDelay := Players[P].FieldSkillDelay;
                      SuddenDeath(P, X, Y);
                      Players[P].FieldSkillDelay := TempFieldSkillDelay;
                      Players[P].WineSkillDelay := Round(XBOW_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                    end;

      sSniperShot: SniperShot(P, X, Y, -1);

      sGravity: if (Abs(X - X2) <= GRAVITY_RADIUS)
                and (Abs(Y - Y2) <= GRAVITY_RADIUS) then
                begin
                  TempRoadSkillDelay := Players[P].RoadSkillDelay;
                  Gravity(P, X, Y);
                  Players[P].RoadSkillDelay := TempRoadSkillDelay;
                  Players[P].WineSkillDelay := Round(AXE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                end;

      sDeadlyFireworks: if (Abs(X - X2) <= FIRE_RADIUS)
                        and (Abs(Y - Y2) <= FIRE_RADIUS) then
                        begin
                          TempFieldSkillDelay := Players[P].FieldSkillDelay;
                          DeadlyFireworks(P, X, Y);
                          Players[P].FieldSkillDelay := TempFieldSkillDelay;
                          Players[P].WineSkillDelay := Round(AXE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                        end;

      sWerewolf: Werewolf(P, X, Y);

      sDisorientation: if (Abs(X - X2) <= SHOCK_RADIUS)
                       and (Abs(Y - Y2) <= SHOCK_RADIUS) then
                       begin
                         TempRoadSkillDelay := Players[P].RoadSkillDelay;
                         Disorientation(P, X, Y);
                         Players[P].RoadSkillDelay := TempRoadSkillDelay;
                         Players[P].WineSkillDelay := Round(VAGA_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                       end;

      sTrack: begin
                TempFieldSkillDelay := Players[P].FieldSkillDelay;
                FieryTrack(P, X, Y);
                Players[P].FieldSkillDelay := TempFieldSkillDelay;
                Players[P].WineSkillDelay := Round(VAGA_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
              end;

      sRegen: if (Abs(X - X2) <= REGEN_RADIUS)
              and (Abs(Y - Y2) <= REGEN_RADIUS) then
                Regen(P, X, Y);

      sViseOfDeath: begin
                      TempRoadSkillDelay := Players[P].RoadSkillDelay;
                      ViseOfDeath(P, X, Y, -1);
                      Players[P].RoadSkillDelay := TempRoadSkillDelay;
                      Players[P].WineSkillDelay := Round(PIKE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                    end;

      sSacrificialTeleport: if (Abs(X - X2) <= SACRIFICIAL_RADIUS)
                            and (Abs(Y - Y2) <= SACRIFICIAL_RADIUS)
                            and (Players[P].HP > 1) then
                            begin
                              TempFieldSkillDelay := Players[P].FieldSkillDelay;
                              SacrificialTeleport(P, X, Y);
                              Players[P].FieldSkillDelay := TempFieldSkillDelay;
                              Players[P].WineSkillDelay := Round(PIKE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                            end;

      sConcentration: Concentration(P, X, Y);

      sRocket: if (X <> X2)
               and (Y <> Y2)
               and (Abs(X - X2) <= ROCKET_USAGE_RADIUS)
               and (Abs(Y - Y2) <= ROCKET_USAGE_RADIUS)
               and (Abs(X - X2) > MIN_ROCKET_USAGE_RADIUS)
               and (Abs(Y - Y2) > MIN_ROCKET_USAGE_RADIUS) then
               begin
                 TempRoadSkillDelay := Players[P].RoadSkillDelay;
                 LaunchRocket(P, X, Y);
                 Players[P].RoadSkillDelay := TempRoadSkillDelay;
                 Players[P].WineSkillDelay := Round(BOWMAN_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               end;

      sPrison: if (Abs(X - X2) <= PRISON_USAGE_RADIUS)
               and (Abs(Y - Y2) <= PRISON_USAGE_RADIUS) then
               begin
                 TempFieldSkillDelay := Players[P].FieldSkillDelay;
                 Prison(P, X, Y);
                 Players[P].FieldSkillDelay := TempFieldSkillDelay;
                 Players[P].WineSkillDelay := Round(BOWMAN_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               end;

      sRevengeFromNowhere: RevengeFromNowhere(P, X, Y, -1);

      sFierySnake: begin
                     TempRoadSkillDelay := Players[P].RoadSkillDelay;
                     FierySnake(P, X, Y, -1);
                     Players[P].RoadSkillDelay := TempRoadSkillDelay;
                     Players[P].WineSkillDelay := Round(WARRIOR_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                   end;

      sSturdyArmor: if (U > 0)
                    and (InRange(O, 0, 7))
                    and (Abs(X - X2) <= ARMOR_RADIUS)
                    and (Abs(Y - Y2) <= ARMOR_RADIUS)
                    and (Players[P].PlayersTeam = Players[O].PlayersTeam) then
                    begin
                      TempFieldSkillDelay := Players[P].FieldSkillDelay;
                      SturdyArmor(P, X, Y);
                      Players[P].FieldSkillDelay := TempFieldSkillDelay;
                      Players[P].WineSkillDelay := Round(WARRIOR_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                    end;

      sPowerWithin: PowerWithin(P, X, Y);

      sRopesOfDeath: if (U > 0)
                     and (InRange(O, 0, 7))
                     and (Abs(X - X2) <= ROPE_RADIUS)
                     and (Abs(Y - Y2) <= ROPE_RADIUS) then
                     begin
                       TempRoadSkillDelay := Players[P].RoadSkillDelay;
                       RopesOfDeath(P, X, Y);
                       Players[P].RoadSkillDelay := TempRoadSkillDelay;
                       Players[P].WineSkillDelay := Round(KNIGHT_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                     end;

      sDeafeningClatter: begin
                           TempFieldSkillDelay := Players[P].FieldSkillDelay;
                           DeafeningClatter(P, X, Y);
                           Players[P].FieldSkillDelay := TempFieldSkillDelay;
                           Players[P].WineSkillDelay := Round(KNIGHT_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                         end;

      sRagingSpurt: RagingSpurt(P, X, Y);

      sMentalBurst: MentalBurst(P, X, Y, -1, True);

      sSteal: if (U > 0)
              and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
              and (InRange(O, 0, 7))
              and (Abs(X - X2) <= STEAL_RADIUS)
              and (Abs(Y - Y2) <= STEAL_RADIUS) then
              begin
                TempFieldSkillDelay := Players[P].FieldSkillDelay;
                StealSkill(P, X, Y);
                Players[P].FieldSkillDelay := TempFieldSkillDelay;
                Players[P].WineSkillDelay := Round(ROGUE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
              end;

      sBoomerang: begin
                    TempRoadSkillDelay := Players[P].RoadSkillDelay;
                    Boomerang(P, X, Y, -1);
                    Players[P].RoadSkillDelay := TempRoadSkillDelay;
                    Players[P].WineSkillDelay := Round(SCOUT_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                  end;

      sSilence: if (U > 0)
                and (InRange(O, 0, 7))
                and (Abs(X - X2) <= SILENCE_SCOUT_RADIUS)
                and (Abs(Y - Y2) <= SILENCE_SCOUT_RADIUS)
                and (Players[P].PlayersTeam <> Players[O].PlayersTeam) then
                begin
                  TempFieldSkillDelay := Players[P].FieldSkillDelay;
                  Silence(P, X, Y);
                  Players[P].FieldSkillDelay := TempFieldSkillDelay;
                  Players[P].WineSkillDelay := Round(SCOUT_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                end;

      sMind: if (U > 0)
             and (Abs(X - X2) <= MIND_RADIUS)
             and (Abs(Y - Y2) <= MIND_RADIUS)
             and (Players[P].PlayersTeam <> Players[O].PlayersTeam) then
               Mind(P, X, Y);

      sUniversal: Exit;

      sNone: Players[P].StolenSkillName := '<$58>';

    end; 
  end;
end;


procedure OnPlanRoadPlaced(P, X, Y: Integer);
begin

  Actions.PlanRemove(P, X, Y);

//Choose Hero

  if ((not Players[P].HeroChosen)
  and (Players[P].Hero = -1)
  and (States.UnitAt(X, Y) > 0)
  and (InRange(States.UnitType(States.UnitAt(X, Y)), 14, 27)))
  or ((Players[P].ReChoice)
  and (InRange(States.UnitType(States.UnitAt(X, Y)), 14, 27))) then
  begin
    Players[P].HeroType := States.UnitType(States.UnitAt(X, Y));
    Players[P].TempHeroType := Players[P].HeroType;
    Players[P].HeroChosen := True;
    Actions.GiveUnit(8, 13, 13, 14, 4);
    Actions.ShowMsg(P, HeroDescription(P, Players[P].HeroType));
    if InRange(P, 0, 3) then
      TeamChoice[0] := TeamChoice[0] + '|[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[] <$32> ' + States.UnitTypeName(Players[P].HeroType);
    if InRange(P, 4, 7) then
      TeamChoice[1] := TeamChoice[1] + '|[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[] <$32> ' + States.UnitTypeName(Players[P].HeroType);
  end;

  if (Players[P].ReChoice)
  and (InRange(States.UnitType(States.UnitAt(X, Y)), 14, 27)) then
    EndReChoice(P);

  if Players[P].HP <= 0 then
    Exit;

  if Players[P].Hero <= 0 then
    Exit;

  if not TileOnBattlefield(X, Y) then
    Exit;

  if Players[P].HeroReborn then
    Exit;

//Use skills

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].RoadSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
  begin
    Players[P].SkillDirection := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    if Players[P].SkillDirection mod 2 = 1 then
    begin
      case States.KaMRandomI(100) of
        0..49:  Players[P].SkillDirection := Players[P].SkillDirection + 1;
        50..99: Players[P].SkillDirection := Players[P].SkillDirection - 1;
      end;
      if Players[P].SkillDirection = 8 then
        Players[P].SkillDirection := 0;
    end;

    case Players[P].HeroType of
      15: Gravity(P, X, Y);
      16: SpikedEarth(P, X, Y, -1);
      17: LaunchRocket(P, X, Y);
      18: AccurateShot(P, X, Y, -1);
      19: FieryLance(P, X, Y, -1);
      20: ViseOfDeath(P, X, Y, -1);
      21: Boomerang(P, X, Y, -1);
      22: RopesOfDeath(P, X, Y);
      23: CrackingEarth(P, X, Y, -1);
      25: MentalBurst(P, X, Y, -1, False);
      26: FierySnake(P, X, Y, -1);
      27: Disorientation(P, X, Y);
    end;
  end;

end;


procedure OnPlanFieldPlaced(P, X, Y: Integer);
begin

  Actions.PlanRemove(P, X, Y);

  if Players[P].HP <= 0 then
    Exit;

  if Players[P].Hero <= 0 then
    Exit;

  if not TileOnBattlefield(X, Y) then
    Exit;

  if Players[P].HeroReborn then
    Exit;

//Use skills

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].FieldSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
  begin
    Players[P].SkillDirection := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    if Players[P].SkillDirection mod 2 = 1 then
    begin
      case States.KaMRandomI(100) of
        0..49:  Players[P].SkillDirection := Players[P].SkillDirection + 1;
        50..99: Players[P].SkillDirection := Players[P].SkillDirection - 1;
      end;
      if Players[P].SkillDirection = 8 then
        Players[P].SkillDirection := 0;
    end;

    case Players[P].HeroType of
      15: DeadlyFireworks(P, X, Y);
      16: ZombieSummon(P, X, Y);
      17: Prison(P, X, Y);
      18: SuddenDeath(P, X, Y);
      19: Teleport(P, X, Y);
      20: SacrificialTeleport(P, X, Y);
      21: Silence(P, X, Y);
      22: DeafeningClatter(P, X, Y);
      23: WaveOfRage(P, X, Y);
      25: StealSkill(P, X, Y);
      26: SturdyArmor(P, X, Y);
      27: FieryTrack(P, X, Y);
    end;
  end;

end;

  
procedure OnPlanWinefieldPlaced(P, X, Y: Integer);
begin

  Actions.PlanRemove(P, X, Y);

  if Players[P].HP <= 0 then
    Exit;

  if Players[P].Hero <= 0 then
    Exit;

  if not TileOnBattlefield(X, Y) then
    Exit;

  if Players[P].HeroReborn then
    Exit;

//Use skills

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].WineSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
  begin
    Players[P].SkillDirection := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    if Players[P].SkillDirection mod 2 = 1 then
    begin
      case States.KaMRandomI(100) of
        0..49:  Players[P].SkillDirection := Players[P].SkillDirection + 1;
        50..99: Players[P].SkillDirection := Players[P].SkillDirection - 1;
      end;
      if Players[P].SkillDirection = 8 then
        Players[P].SkillDirection := 0;
    end;

    case Players[P].HeroType of
      15: Werewolf(P, X, Y);
      16: Fear(P, X, Y);
      17: RevengeFromNowhere(P, X, Y, -1);
      18: SniperShot(P, X, Y, -1);
      19: TenThousandsSpears(P, X, Y, -1);
      20: Concentration(P, X, Y);
      21: Mind(P, X, Y);
      22: RagingSpurt(P, X, Y);
      23: TotemOfAncestors(P, X, Y);
      25: UseStolenSkill(P, X, Y, -1);
      26: PowerWithin(P, X, Y);
      27: Regen(P, X, Y);
    end;
  end;

end;


procedure CheckTiles(P: Integer);
var
  T, aX, aY, aObj: Integer;
begin
  aObj := -1;
  if Players[P].Hero <= 0 then
    Exit;
  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;
  if Players[P].Hero > 0 then
  if not States.GroupDead(Players[P].Hero) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
  end;
  if aX <= 0 then
    Exit;
  if aY <= 0 then
    Exit;
  if (TileOnBattlefield(aX, aY))
  or ((aX = RUNE_X)
  and (aY = RUNE_Y)) then
    aObj := States.MapTileObject(aX, aY);
  if aObj = PikeObjects[P] then
    Exit;
  if aObj = -1 then
    Exit;

  if (aObj = LANCE_OBJECT)
  or (aObj = LANCE_OBJECT2)
  or (aObj = LANCE_OBJECT3)
  or (aObj = BARB_OBJECT)
  or (aObj = BARB_OBJECT2)
  or (aObj = BARB_OBJECT3)
  or (aObj = BARB_OBJECT4)
  or (aObj = BARB_OBJECT5)
  or (aObj = XBOW_OBJECT)
  or (aObj = XBOW_OBJECT2)
  or (aObj = XBOW_OBJECT3)
  or (aObj = PIKE_OBJECT)
  or (aObj = PIKE_OBJECT2)
  or (aObj = PIKE_OBJECT3)
  or (aObj = PIKE_OBJECT4)
  or (aObj = PIKE_OBJECT5)
  or (aObj = PIKE_OBJECT6)
  or (aObj = PIKE_OBJECT7)
  or (aObj = PIKE_OBJECT8)
  or (aObj = PIKE_OBJECT9)
  or (aObj = BOWMAN_OBJECT)
  or (aObj = BOWMAN_OBJECT2)
  or (aObj = BOWMAN_OBJECT3)
  or (aObj = BOWMAN_OBJECT4)
  or (aObj = BOWMAN_ROCKET)
  or (aObj = BOWMAN_ROCKET2)
  or (aObj = AXE_OBJECT2)
  or (aObj = AXE_OBJECT3)
  or (aObj = VAGA_OBJECT2)
  or (aObj = WARRIOR_OBJECT3)
  or (aObj = WARRIOR_OBJECT)
  or (aObj = WARRIOR_OBJECT2)
  or (aObj = WARRIOR_OBJECT5)
  or (aObj = WARRIOR_OBJECT6)
  or (aObj = WARRIOR_OBJECT6 + 1)
  or (aObj = KNIGHT_OBJECT4)
  or (aObj = ROGUE_OBJECT)
  or (aObj = ROGUE_OBJECT2)
  or (aObj = CIRCLE_FILL_OBJ)
  or (aObj = SCOUT_OBJECT3)
  or (aObj = VAGA_OBJECT8)
  or (aObj = SCOUT_OBJECT5)
  or (aObj = SCOUT_OBJECT6) then
  begin
    T := Players[P].HeroType;
    if (not States.PlayerDefeated(P))
    and (not Players[P].HeroImmortal) then
    begin
      if Players[P].HP > 0 then
      begin 
        Actions.GroupKillAll(Players[P].Hero, False);
        Players[P].HeroReborn := True;
        Players[P].RebornTime := States.GameTime + REBORN_TIME;
        Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, T, Players[P].TempX, Players[P].TempY, 4, 1, 1);
        Players[P].HeroInFearTime := 0;
        if (not Players[P].CaptureMind)
        and (not Players[P].MindStunned) then
          Players[P].HeroStunnedTime := 0;
        Players[P].HeroSilentTime := 0;
        Players[P].PreparingTime := 0;
        Players[P].DDTime := 0;
        Players[P].ReChargeTime := 0;

        Actions.MapTileSet(aX, aY, Tiles[aX][aY].TileType, Tiles[aX][aY].TileDirection);

        if States.GameTime < Players[P].MindTime2 then
        begin
          Players[P].MindTime2 := 0;
          Players[P].WineSkillDelay := 500;
        end;

        if TilesRoadLength[P] > 0 then
          if (Players[P].HeroType <> 23)
          or ((Players[P].HeroType = 23)
          and (States.GameTime < Players[P].CrackingStartTime)) then
            for I := 0 to TilesRoadLength[P] - 1 do
              if SetTilesRoadTimes[P][I] > States.GameTime then
                if (TilesRoadObjects[P][I] <> BOWMAN_ROCKET)
                and (TilesRoadObjects[P][I] <> BOWMAN_OBJECT6) then
                begin
                  SetTilesRoadTimes[P][I] := 0;
                  TilesRoadObjects[P][I] := SKILL_CANCEL_OBJ;
                end;

        if TilesFieldLength[P] > 0 then
          for I := 0 to TilesFieldLength[P] - 1 do
            if SetTilesFieldTimes[P][I] > States.GameTime then
            begin
              SetTilesFieldTimes[P][I] := 0;
              TilesFieldObjects[P][I] := SKILL_CANCEL_OBJ;
            end;

        if TilesWineLength[P] > 0 then
          if ((Players[P].HeroType <> 25)
          and (Players[P].LastUsedSkill <> sCrackingEarth))
          or ((Players[P].HeroType = 25)
          and (Players[P].LastUsedSkill = sCrackingEarth)
          and (States.GameTime < Players[P].CrackingStartTime))  then
            for I := 0 to TilesWineLength[P] - 1 do
              if SetTilesWineTimes[P][I] > States.GameTime then
              begin
                SetTilesWineTimes[P][I] := 0;
                TilesWineObjects[P][I] := SKILL_CANCEL_OBJ;
              end;

        Players[P].TrackStartTime := 0;
        Players[P].TrackStopTime := 0;
        Players[P].SettingTrack := False;

        Players[P].PowerWithinCircleCycles := 0;
        Players[P].PowerWithinCircleTime := 0;

        for I := 0 to 7 do
        begin

          if Players[I].RopeAttacker = P then
            Players[I].RopeAttacker := -1;

          if Players[I].ScoutSilenceGiver = P then
            Players[I].ScoutSilenceGiver := -1;

        end;

        for K := 0 to SPURT_LENGTH - 1 do
          SpurtTimes[P][K] := 0;

        for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
          for I := 0 to TotemCirclesLength[P][K] - 1 do
            if (TotemCircles[P][K][I].AddTime > States.GameTime)
            and (TotemCircles[P][K][I].Obj <> 255) then
              TotemCircles[P][K][I].Obj := SKILL_CANCEL_OBJ;

        for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
          for I := 0 to ConcentrationCirclesLength[P][K] - 1 do
            ConcentrationCircles[P][K][I].Obj := SKILL_CANCEL_OBJ;

        for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
          for I := 0 to ExpCirclesLength[P][K] - 1 do
            if (ExpCircles[P][K][I].AddTime > States.GameTime)
            and (ExpCircles[P][K][I].Obj <> 255) then
              ExpCircles[P][K][I].Obj := SKILL_CANCEL_OBJ;

        for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
          for I := 0 to RogueCirclesLength[P][K] - 1 do
            if (RogueCircles[P][K][I].AddTime > States.GameTime)
            and (RogueCircles[P][K][I].Obj <> 255) then
              RogueCircles[P][K][I].Obj := SKILL_CANCEL_OBJ;

        for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
          for I := 0 to StolenRogueCirclesLength[P][K] - 1 do
            if (StolenRogueCircles[P][K][I].AddTime > States.GameTime)
            and (StolenRogueCircles[P][K][I].Obj <> 255) then
              StolenRogueCircles[P][K][I].Obj := SKILL_CANCEL_OBJ;

        for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
          for I := 0 to FireworksCircles1Length[P][K] - 1 do
            if (FireworksCircles1[P][K][I].AddTime > States.GameTime)
            and (FireworksCircles1[P][K][I].Obj <> 255) then
              FireworksCircles1[P][K][I].Obj := SKILL_CANCEL_OBJ;

        for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
          for I := 0 to FireworksCircles2Length[P][K] - 1 do
            if (FireworksCircles2[P][K][I].AddTime > States.GameTime)
            and (FireworksCircles2[P][K][I].Obj <> 255) then
              FireworksCircles2[P][K][I].Obj := SKILL_CANCEL_OBJ;

        for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
          for I := 0 to FireworksCircles3Length[P][K] - 1 do
            if (FireworksCircles3[P][K][I].AddTime > States.GameTime)
            and (FireworksCircles3[P][K][I].Obj <> 255) then
              FireworksCircles3[P][K][I].Obj := SKILL_CANCEL_OBJ;

        for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
          for I := 0 to FireworksCircles4Length[P][K] - 1 do
            if (FireworksCircles4[P][K][I].AddTime > States.GameTime)
            and (FireworksCircles4[P][K][I].Obj <> 255) then
              FireworksCircles4[P][K][I].Obj := SKILL_CANCEL_OBJ;

        for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
          for I := 0 to FireworksCircles5Length[P][K] - 1 do
            if (FireworksCircles5[P][K][I].AddTime > States.GameTime)
            and (FireworksCircles5[P][K][I].Obj <> 255) then
              FireworksCircles5[P][K][I].Obj := SKILL_CANCEL_OBJ;

        for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
          for I := 0 to PowerWithinCirclesLength[P][K] - 1 do
            if (PowerWithinCircles[P][K][I].AddTime > States.GameTime)
            and (PowerWithinCircles[P][K][I].Obj <> 255) then
              PowerWithinCircles[P][K][I].Obj := SKILL_CANCEL_OBJ;

        if InRange(Tiles[aX][aY].Owner, 0, 7) then
        begin
          if SkillName(Tiles[aX][aY].Skill) <> '' then
          begin
            if Tiles[aX][aY].Owner <> P then
            begin
              Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
              Players[Tiles[aX][aY].Owner].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
              Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$67> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
              Players[Tiles[aX][aY].Owner].PlayerStatus := Players[Tiles[aX][aY].Owner].PlayerStatus + '|<$84> ' + '[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[]<$93> ' + SkillName(Tiles[aX][aY].Skill);
            end;
            if ((Tiles[aX][aY].Owner = P)
            and (not Players[P].CaptureMind)
            and (not Players[P].MindStunned))
            or ((Players[P].CaptureMind)
            and (Tiles[aX][aY].Owner = M[P]))
            or ((Players[P].MindStunned)
            and (Tiles[aX][aY].Owner = M[P])) then
            begin
              Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
              Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$82> ' + SkillName(Tiles[aX][aY].Skill);
            end;
          end;
          if (P <> Tiles[aX][aY].Owner)
          and (Players[P].PlayersTeam <> Players[Tiles[aX][aY].Owner].PlayersTeam) then
          begin
            Players[Tiles[aX][aY].Owner].Kills := Players[Tiles[aX][aY].Owner].Kills + 1 + (Byte(Players[Tiles[aX][aY].Owner].DD) * Byte(Players[P].HP >= 2));
            Players[Tiles[aX][aY].Owner].TotalKills := Players[Tiles[aX][aY].Owner].TotalKills + 1;
            SetLength(Players[Tiles[aX][aY].Owner].KillTimes, Length(Players[Tiles[aX][aY].Owner].KillTimes) + 1);
            Players[Tiles[aX][aY].Owner].KillTimes[Length(Players[Tiles[aX][aY].Owner].KillTimes) - 1] := States.GameTime;
            if Length(Players[Tiles[aX][aY].Owner].KillTimes) >= 4 then
              if (Players[Tiles[aX][aY].Owner].KillTimes[Length(Players[Tiles[aX][aY].Owner].KillTimes) - 1] - Players[Tiles[aX][aY].Owner].KillTimes[Length(Players[Tiles[aX][aY].Owner].KillTimes) - 4] <= RAMPAGE_CHECK_TIME)
              {and (not Players[Tiles[aX][aY].Owner].Rampage)} then
              begin
                Actions.PlayWAV(-1, 'Rampage', 1);
                Players[Tiles[aX][aY].Owner].Rampage := True;
                Players[Tiles[aX][aY].Owner].KillsCountTime := States.GameTime + KILLS_REFRESH_TIME;
              end;
            if Length(Players[Tiles[aX][aY].Owner].KillTimes) >= 3 then
              if (Players[Tiles[aX][aY].Owner].KillTimes[Length(Players[Tiles[aX][aY].Owner].KillTimes) - 1] - Players[Tiles[aX][aY].Owner].KillTimes[Length(Players[Tiles[aX][aY].Owner].KillTimes) - 3] <= TRIPLE_KILL_CHECK_TIME)
              and (not Players[Tiles[aX][aY].Owner].TripleKill)
              and (not Players[Tiles[aX][aY].Owner].Rampage) then
              begin
                Actions.PlayWAV(-1, 'TripleKill', 1);
                Players[Tiles[aX][aY].Owner].TripleKill := True;
                Players[Tiles[aX][aY].Owner].KillsCountTime := Players[Tiles[aX][aY].Owner].KillsCountTime + MAX_TIME_BETWEEN_KILLS;
              end;
            if Length(Players[Tiles[aX][aY].Owner].KillTimes) >= 2 then
              if (Players[Tiles[aX][aY].Owner].KillTimes[Length(Players[Tiles[aX][aY].Owner].KillTimes) - 1] - Players[Tiles[aX][aY].Owner].KillTimes[Length(Players[Tiles[aX][aY].Owner].KillTimes) - 2] <= DOUBLE_KILL_CHECK_TIME)
              and (not Players[Tiles[aX][aY].Owner].DoubleKill)
              and (not Players[Tiles[aX][aY].Owner].TripleKill)
              and (not Players[Tiles[aX][aY].Owner].Rampage) then
              begin
                Actions.PlayWAV(-1, 'DoubleKill', 1);
                Players[Tiles[aX][aY].Owner].DoubleKill := True;
                Players[Tiles[aX][aY].Owner].KillsCountTime := Players[Tiles[aX][aY].Owner].KillsCountTime + MAX_TIME_BETWEEN_KILLS;
              end;
          end;
          if (Players[P].HeroInFear)
          and (Players[P].PlayersTeam = Players[Tiles[aX][aY].Owner].PlayersTeam) then
          begin
            Players[Players[P].HeroFearGiver].Kills := Players[Players[P].HeroFearGiver].Kills + 1 + (Byte(Players[Tiles[aX][aY].Owner].DD) * Byte(Players[P].HP >= 2));
            Players[Players[P].HeroFearGiver].TotalKills := Players[Players[P].HeroFearGiver].TotalKills + 1;
            SetLength(Players[Players[P].HeroFearGiver].KillTimes, Length(Players[Players[P].HeroFearGiver].KillTimes) + 1);
            Players[Players[P].HeroFearGiver].KillTimes[Length(Players[Players[P].HeroFearGiver].KillTimes) - 1] := States.GameTime;
            if Length(Players[Players[P].HeroFearGiver].KillTimes) >= 4 then
              if (Players[Players[P].HeroFearGiver].KillTimes[Length(Players[Players[P].HeroFearGiver].KillTimes) - 1] - Players[Players[P].HeroFearGiver].KillTimes[Length(Players[Players[P].HeroFearGiver].KillTimes) - 4] <= RAMPAGE_CHECK_TIME)
              {and (not Players[Players[P].HeroFearGiver].Rampage)} then
              begin
                Actions.PlayWAV(-1, 'Rampage', 1);
                Players[Players[P].HeroFearGiver].Rampage := True;
                Players[Players[P].HeroFearGiver].KillsCountTime := States.GameTime + KILLS_REFRESH_TIME;
              end;
            if Length(Players[Players[P].HeroFearGiver].KillTimes) >= 3 then
              if (Players[Players[P].HeroFearGiver].KillTimes[Length(Players[Players[P].HeroFearGiver].KillTimes) - 1] - Players[Players[P].HeroFearGiver].KillTimes[Length(Players[Players[P].HeroFearGiver].KillTimes) - 3] <= TRIPLE_KILL_CHECK_TIME)
              and (not Players[Players[P].HeroFearGiver].TripleKill)
              and (not Players[Players[P].HeroFearGiver].Rampage) then
              begin
                Actions.PlayWAV(-1, 'TripleKill', 1);
                Players[Players[P].HeroFearGiver].TripleKill := True;
                Players[Players[P].HeroFearGiver].KillsCountTime := Players[Players[P].HeroFearGiver].KillsCountTime + MAX_TIME_BETWEEN_KILLS;
              end;
            if Length(Players[Players[P].HeroFearGiver].KillTimes) >= 2 then
              if (Players[Players[P].HeroFearGiver].KillTimes[Length(Players[Players[P].HeroFearGiver].KillTimes) - 1] - Players[Players[P].HeroFearGiver].KillTimes[Length(Players[Players[P].HeroFearGiver].KillTimes) - 2] <= DOUBLE_KILL_CHECK_TIME)
              and (not Players[Players[P].HeroFearGiver].DoubleKill)
              and (not Players[Players[P].HeroFearGiver].TripleKill)
              and (not Players[Players[P].HeroFearGiver].Rampage) then
              begin
                Actions.PlayWAV(-1, 'DoubleKill', 1);
                Players[Players[P].HeroFearGiver].DoubleKill := True;
                Players[Players[P].HeroFearGiver].KillsCountTime := Players[Players[P].HeroFearGiver].KillsCountTime + MAX_TIME_BETWEEN_KILLS;
              end;
          end;
          if (Players[P].MovedByGravity)
          and (Players[P].PlayersTeam <> Players[Players[P].GravityUser].PlayersTeam)
          and (Players[P].PlayersTeam = Players[Tiles[aX][aY].Owner].PlayersTeam) then
          begin
            Players[Players[P].GravityUser].Kills := Players[Players[P].GravityUser].Kills + 1 + (Byte(Players[Tiles[aX][aY].Owner].DD) * Byte(Players[P].HP >= 2));
            Players[Players[P].GravityUser].TotalKills := Players[Players[P].GravityUser].TotalKills + 1;
            SetLength(Players[Players[P].GravityUser].KillTimes, Length(Players[Players[P].GravityUser].KillTimes) + 1);
            Players[Players[P].GravityUser].KillTimes[Length(Players[Players[P].GravityUser].KillTimes) - 1] := States.GameTime;
            if Length(Players[Players[P].GravityUser].KillTimes) >= 4 then
              if (Players[Players[P].GravityUser].KillTimes[Length(Players[Players[P].GravityUser].KillTimes) - 1] - Players[Players[P].GravityUser].KillTimes[Length(Players[Players[P].GravityUser].KillTimes) - 4] <= RAMPAGE_CHECK_TIME)
              {and (not Players[Players[P].GravityUser].Rampage)} then
              begin
                Actions.PlayWAV(-1, 'Rampage', 1);
                Players[Players[P].GravityUser].Rampage := True;
                Players[Players[P].GravityUser].KillsCountTime := States.GameTime + KILLS_REFRESH_TIME;
              end;
            if Length(Players[Players[P].GravityUser].KillTimes) >= 3 then
              if (Players[Players[P].GravityUser].KillTimes[Length(Players[Players[P].GravityUser].KillTimes) - 1] - Players[Players[P].GravityUser].KillTimes[Length(Players[Players[P].GravityUser].KillTimes) - 3] <= TRIPLE_KILL_CHECK_TIME)
              and (not Players[Players[P].GravityUser].TripleKill)
              and (not Players[Players[P].GravityUser].Rampage) then
              begin
                Actions.PlayWAV(-1, 'TripleKill', 1);
                Players[Players[P].GravityUser].TripleKill := True;
                Players[Players[P].GravityUser].KillsCountTime := Players[Players[P].GravityUser].KillsCountTime + MAX_TIME_BETWEEN_KILLS;
              end;
            if Length(Players[Players[P].GravityUser].KillTimes) >= 2 then
              if (Players[Players[P].GravityUser].KillTimes[Length(Players[Players[P].GravityUser].KillTimes) - 1] - Players[Players[P].GravityUser].KillTimes[Length(Players[Players[P].GravityUser].KillTimes) - 2] <= DOUBLE_KILL_CHECK_TIME)
              and (not Players[Players[P].GravityUser].DoubleKill)
              and (not Players[Players[P].GravityUser].TripleKill)
              and (not Players[Players[P].GravityUser].Rampage) then
              begin
                Actions.PlayWAV(-1, 'DoubleKill', 1);
                Players[Players[P].GravityUser].DoubleKill := True;
                Players[Players[P].GravityUser].KillsCountTime := Players[Players[P].GravityUser].KillsCountTime + MAX_TIME_BETWEEN_KILLS;
              end;
          end;
          if (Players[P].MovedByRopes)
          and (Players[P].PlayersTeam <> Players[Players[P].RopeAttacker].PlayersTeam)
          and (Players[P].PlayersTeam = Players[Tiles[aX][aY].Owner].PlayersTeam) then
          begin
            Players[Players[P].RopeAttacker].Kills := Players[Players[P].RopeAttacker].Kills + 1 + (Byte(Players[Tiles[aX][aY].Owner].DD) * Byte(Players[P].HP >= 2));
            Players[Players[P].RopeAttacker].TotalKills := Players[Players[P].RopeAttacker].TotalKills + 1;
            SetLength(Players[Players[P].RopeAttacker].KillTimes, Length(Players[Players[P].RopeAttacker].KillTimes) + 1);
            Players[Players[P].RopeAttacker].KillTimes[Length(Players[Players[P].RopeAttacker].KillTimes) - 1] := States.GameTime;
            if Length(Players[Players[P].RopeAttacker].KillTimes) >= 4 then
              if (Players[Players[P].RopeAttacker].KillTimes[Length(Players[Players[P].RopeAttacker].KillTimes) - 1] - Players[Players[P].RopeAttacker].KillTimes[Length(Players[Players[P].RopeAttacker].KillTimes) - 4] <= RAMPAGE_CHECK_TIME)
              {and (not Players[Players[P].RopeAttacker].Rampage)} then
              begin
                Actions.PlayWAV(-1, 'Rampage', 1);
                Players[Players[P].RopeAttacker].Rampage := True;
                Players[Players[P].RopeAttacker].KillsCountTime := States.GameTime + KILLS_REFRESH_TIME;
              end;
            if Length(Players[Players[P].RopeAttacker].KillTimes) >= 3 then
              if (Players[Players[P].RopeAttacker].KillTimes[Length(Players[Players[P].RopeAttacker].KillTimes) - 1] - Players[Players[P].RopeAttacker].KillTimes[Length(Players[Players[P].RopeAttacker].KillTimes) - 3] <= TRIPLE_KILL_CHECK_TIME)
              and (not Players[Players[P].RopeAttacker].TripleKill)
              and (not Players[Players[P].RopeAttacker].Rampage) then
              begin
                Actions.PlayWAV(-1, 'TripleKill', 1);
                Players[Players[P].RopeAttacker].TripleKill := True;
                Players[Players[P].RopeAttacker].KillsCountTime := Players[Players[P].RopeAttacker].KillsCountTime + MAX_TIME_BETWEEN_KILLS;
              end;
            if Length(Players[Players[P].RopeAttacker].KillTimes) >= 2 then
              if (Players[Players[P].RopeAttacker].KillTimes[Length(Players[Players[P].RopeAttacker].KillTimes) - 1] - Players[Players[P].RopeAttacker].KillTimes[Length(Players[Players[P].RopeAttacker].KillTimes) - 2] <= DOUBLE_KILL_CHECK_TIME)
              and (not Players[Players[P].RopeAttacker].DoubleKill)
              and (not Players[Players[P].RopeAttacker].TripleKill)
              and (not Players[Players[P].RopeAttacker].Rampage) then
              begin
                Actions.PlayWAV(-1, 'DoubleKill', 1);
                Players[Players[P].RopeAttacker].DoubleKill := True;
                Players[Players[P].RopeAttacker].KillsCountTime := Players[Players[P].RopeAttacker].KillsCountTime + MAX_TIME_BETWEEN_KILLS;
              end;
          end;
        end;
        if not (Players[P].CaptureMind)
        and not (Players[P].MindStunned) then
          Players[P].HP := Players[P].HP - 1 - Byte(Players[Tiles[aX][aY].Owner].DD);
        if Players[P].CaptureMind then
          Players[M[P]].HP := Players[M[P]].HP - 1 - Byte(Players[Tiles[aX][aY].Owner].DD);
        if Players[P].MindStunned then
        begin
          Players[M2[P]].HP := Players[M2[P]].HP - 1 - Byte(Players[Tiles[aX][aY].Owner].DD);
          Actions.GroupBlockOrders(Players[P].Hero, True);
          Actions.GroupOrderHalt(Players[P].Hero);
        end;
      end;
      Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
    end;
  end;

  if aObj = VAGA_OBJECT then
  begin
    if (not Players[P].MindStunned)
    and (not Players[P].CaptureMind) then
      if States.GameTime > Players[P].RegenDelay then
        if Players[P].HP < MAX_HP then
        begin
          Players[P].HP := Players[P].HP + 1;
          Players[P].RegenDelay := States.GameTime + REGEN_DELAY;
          if InRange(Tiles[aX][aY].Owner, 0, 7) then
          begin
            if SkillName(Tiles[aX][aY].Skill) <> '' then
            begin
              Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
              Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$69> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
            end;
          end;
          if TileOnRuneSpawn(aX, aY) then
            RuneTaken := True;
          Actions.MapTileObjectSet(aX, aY, 255);
        end;
    if Players[P].CaptureMind then
      if States.GameTime > Players[M[P]].RegenDelay then
        if Players[M[P]].HP < MAX_HP then
        begin
          Players[M[P]].HP := Players[M[P]].HP + 1;
          Players[M[P]].RegenDelay := States.GameTime + REGEN_DELAY;
          if InRange(Tiles[aX][aY].Owner, 0, 7) then
          begin
            if SkillName(Tiles[aX][aY].Skill) <> '' then
            begin
              Players[M[P]].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
              Players[M[P]].PlayerStatus := Players[M[P]].PlayerStatus + '|<$69> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
            end;
          end;
          if TileOnRuneSpawn(aX, aY) then
            RuneTaken := True;
          Actions.MapTileObjectSet(aX, aY, 255);
        end;
    if Players[P].MindStunned then
      if States.GameTime > Players[M2[P]].RegenDelay then
        if Players[M2[P]].HP < MAX_HP then
        begin
          Players[M2[P]].HP := Players[M2[P]].HP + 1;
          Players[M2[P]].RegenDelay := States.GameTime + REGEN_DELAY;
          if InRange(Tiles[aX][aY].Owner, 0, 7) then
          begin
            if SkillName(Tiles[aX][aY].Skill) <> '' then
            begin
              Players[M2[P]].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
              Players[M2[P]].PlayerStatus := Players[M2[P]].PlayerStatus + '|<$69> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
            end;
          end;
          if TileOnRuneSpawn(aX, aY) then
            RuneTaken := True;
          Actions.MapTileObjectSet(aX, aY, 255);
        end;
  end;

  if aObj = BOWMAN_ROCKET then
  begin
    TilesRoadLength[Tiles[aX][aY].Owner] := TilesRoadLength[Tiles[aX][aY].Owner] + 9;
    SetLength(TilesRoadX[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);
    SetLength(TilesRoadY[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);
    SetLength(ClearTilesRoadTimes[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);
    SetLength(SetTilesRoadTimes[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);
    SetLength(TilesRoadObjects[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);

    TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 1] := aX;
    TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 1] := aY;
    TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 2] := aX;
    TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 2] := aY - 1;
    TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 3] := aX;
    TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 3] := aY + 1;
    TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 4] := aX - 1;
    TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 4] := aY;
    TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 5] := aX + 1;
    TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 5] := aY;
    TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 6] := aX + 1;
    TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 6] := aY + 1;
    TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 7] := aX + 1;
    TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 7] := aY - 1;
    TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 8] := aX - 1;
    TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 8] := aY + 1;
    TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 9] := aX - 1;
    TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 9] := aY - 1;

    for I := 1 to 9 do
    begin
      TilesRoadObjects[Tiles[aX][aY].Owner][Length(TilesRoadObjects[Tiles[aX][aY].Owner]) - I] := BOWMAN_ROCKET2;
      ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - I] := States.GameTime + 45 + States.KaMRandomI(3);
      SetTilesRoadTimes[Tiles[aX][aY].Owner][Length(SetTilesRoadTimes[Tiles[aX][aY].Owner]) - I] := States.GameTime + 15 + States.KaMRandomI(3);

      if TileOnBattlefield(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) then
      begin
        Tiles[TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I]][TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]].Owner := Tiles[aX][aY].Owner;
        Tiles[TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I]][TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]].Skill := sRocket;
        Tiles[TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I]][TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - 9];
      end;

      if (States.MapTileObject(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - I] := ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - I] + CLEANUP_TIME;

    end;

    TilesRoadObjects[Tiles[aX][aY].Owner][Length(TilesRoadObjects[Tiles[aX][aY].Owner]) - 1] := BOWMAN_ROCKET2;
    ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - 1] := States.GameTime + 45 + States.KaMRandomI(3);
    SetTilesRoadTimes[Tiles[aX][aY].Owner][Length(SetTilesRoadTimes[Tiles[aX][aY].Owner]) - 1] := States.GameTime + 34;

    ClearRoadTilesArrayTime[Tiles[aX][aY].Owner] := ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - 9] + CLEAR_ARRAY_FACTOR + 2;

  end;

  if aObj = RUNE_DOUBLE_OBJ then
  begin
    if States.GameTime > Players[P].DDTime then
    begin
      Players[P].DD := True;
      Players[P].DDTime := States.GameTime + RUNE_DOUBLE_TIME;
      if TileOnRuneSpawn(aX, aY) then
        RuneTaken := True;
      Actions.MapTileObjectSet(aX, aY, 255);
    end;
  end;

  if aObj = RUNE_IMMORTAL_OBJ then
  begin
    if States.GameTime > Players[P].HeroImmortalTime then
    begin
      Players[P].HeroImmortal := True;
      Players[P].HeroImmortalTime := States.GameTime + RUNE_IMMORTAL_TIME;
      if InRange(Tiles[aX][aY].Owner, 0, 7)
      and (not TileOnRuneSpawn(aX, aY))
      and (not RuneTaken) then
      begin
        Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
        Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$70> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
      end;
      if TileOnRuneSpawn(aX, aY) then
        RuneTaken := True;
      Actions.MapTileObjectSet(aX, aY, 255);
    end;
  end;

  if aObj = RUNE_ILLUSION_OBJ then
  begin
    Players[P].InIllusion := True;
    for I := 0 to 3 do
    begin
      ZomboHero[P][I] := Actions.GiveGroup(Players[P].ZombiePlayer, Players[P].HeroType, RUNE_X + States.KaMRandomI(5) - States.KaMRandomI(5), RUNE_Y + States.KaMRandomI(5) - States.KaMRandomI(5), States.KaMRandomI(8), 1, 1);
      SetLength(Zombies, Length(Zombies) + 1);
      Zombies[Length(Zombies) - 1].Owner := P;
      Zombies[Length(Zombies) - 1].ID := States.GroupMember(ZomboHero[P][I], 0);
      Actions.GroupHungerSet(ZomboHero[P][I], RUNE_ZOMBIE_LIFE);
      if TileOnRuneSpawn(aX, aY) then
        RuneTaken := True;
      Actions.MapTileObjectSet(aX, aY, 255);
    end;
  end;

  if aObj = RUNE_RECHARGE_OBJ then
  begin
    Players[P].ReCharge := True;
    Players[P].ReChargeTime := States.GameTime + RUNE_RECHARGE_TIME;
    Players[P].RoadSkillDelay := 0;
    Players[P].FieldSkillDelay := 0;
    Players[P].WineSkillDelay := 0;
    if TileOnRuneSpawn(aX, aY) then
      RuneTaken := True;
    Actions.MapTileObjectSet(aX, aY, 255);
  end;

  if InRange(aObj, SWORD_OBJECT1, SWORD_OBJECT1 + 2) then
  begin
    if (not States.PlayerDefeated(P))
    and (not Players[P].HeroImmortal) then
    begin
      if Players[P].Hero > 0 then
      begin
        Actions.GroupBlockOrders(Players[P].Hero, True);
        Actions.GroupOrderHalt(Players[P].Hero);
      end;
      if InRange(Tiles[aX][aY].Owner, 0, 7)
      and (not Players[P].HeroStunned) then
      begin
        Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
        Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$68> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
      end;
      Players[P].HeroStunnedTime := States.GameTime + STUNNED_TIME;
      Players[P].HeroStunned := True;
      Actions.MapTileSet(aX, aY, STUN_ANIMATION, States.KaMRandomI(4));
    end;
  end;

  if aObj = SWORD_OBJECT then
  begin
    if (not States.PlayerDefeated(P))
    and (not Players[P].HeroImmortal) then
    begin
      if Players[P].Hero > 0 then
      begin
        Actions.GroupBlockOrders(Players[P].Hero, True);
        Actions.GroupOrderHalt(Players[P].Hero);
      end;
      if InRange(Tiles[aX][aY].Owner, 0, 7)
      and (not Players[P].HeroStunned) then
      begin
        Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
        Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$68> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
      end;
      Players[P].HeroStunnedTime := States.GameTime + STUNNED_ANIMATION_TIME;
      Players[P].HeroStunned := True;
      Actions.MapTileSet(aX, aY, STUN_ANIMATION, States.KaMRandomI(4));
    end;
  end;

  if aObj = VAGA_OBJECT6 then
  begin
    if (not States.PlayerDefeated(P))
    and (not Players[P].HeroImmortal) then
    begin
      if Players[P].Hero > 0 then
      begin
        Actions.GroupBlockOrders(Players[P].Hero, True);
        Actions.GroupOrderHalt(Players[P].Hero);
      end;
      if InRange(Tiles[aX][aY].Owner, 0, 7)
      and (not Players[P].HeroStunned) then
      begin
        Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
        Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$68> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
      end;
      Players[P].HeroStunnedTime := States.GameTime + SHOCK_TIME;
      Players[P].HeroStunned := True;
      Actions.MapTileSet(aX, aY, STUN_ANIMATION, States.KaMRandomI(4));
    end;
  end;

  if aObj = KNIGHT_OBJECT3 then
  begin
    if (not States.PlayerDefeated(P))
    and (not Players[P].HeroImmortal) then
    begin
      if Players[P].Hero > 0 then
      begin
        Actions.GroupBlockOrders(Players[P].Hero, True);
        Actions.GroupOrderHalt(Players[P].Hero);
      end;
      if InRange(Tiles[aX][aY].Owner, 0, 7)
      and (not Players[P].HeroStunned) then
      begin
        Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
        Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$68> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
      end;
      Players[P].HeroStunnedTime := States.GameTime + DEAFENING_TIME;
      Players[P].HeroStunned := True;
      Actions.MapTileSet(aX, aY, STUN_ANIMATION, States.KaMRandomI(4));
    end;
  end;

end;


procedure CheckTilesForAI;
var
  AIUnits: array of Integer;
  aObj, aX, aY: Integer;
begin
  aObj := -1;
  for I := 9 to 11 do
  begin
    AIUnits := States.PlayerGetAllUnits(I);
    for K := 0 to length(AIUnits) - 1 do
    begin
      if AIUnits[K] > 0 then
      begin
        aX := States.UnitPositionX(AIUnits[K]);
        aY := States.UnitPositionY(AIUnits[K]);
      end;
      if TileOnBattlefield(aX, aY) then
      begin
        aObj := States.MapTileObject(aX, aY);
        if (aObj = LANCE_OBJECT)
        or (aObj = LANCE_OBJECT2)
        or (aObj = LANCE_OBJECT3)
        or (aObj = BARB_OBJECT)
        or (aObj = BARB_OBJECT2)
        or (aObj = BARB_OBJECT3)
        or (aObj = BARB_OBJECT4)
        or (aObj = BARB_OBJECT5)
        or (aObj = XBOW_OBJECT)
        or (aObj = XBOW_OBJECT2)
        or (aObj = XBOW_OBJECT3)
        or (aObj = PIKE_OBJECT)
        or (aObj = PIKE_OBJECT2)
        or (aObj = PIKE_OBJECT3)
        or (aObj = PIKE_OBJECT4)
        or (aObj = PIKE_OBJECT5)
        or (aObj = PIKE_OBJECT6)
        or (aObj = PIKE_OBJECT7)
        or (aObj = PIKE_OBJECT8)
        or (aObj = PIKE_OBJECT9)
        or (aObj = BOWMAN_OBJECT)
        or (aObj = BOWMAN_OBJECT2)
        or (aObj = BOWMAN_OBJECT3)
        or (aObj = BOWMAN_OBJECT4)
        or (aObj = BOWMAN_ROCKET)
        or (aObj = BOWMAN_ROCKET2)
        or (aObj = AXE_OBJECT2)
        or (aObj = AXE_OBJECT3)
        or (aObj = VAGA_OBJECT2)
        or (aObj = WARRIOR_OBJECT3)
        or (aObj = WARRIOR_OBJECT)
        or (aObj = WARRIOR_OBJECT2)
        or (aObj = WARRIOR_OBJECT5)
        or (aObj = WARRIOR_OBJECT6)
        or (aObj = WARRIOR_OBJECT6 + 1)
        or (aObj = KNIGHT_OBJECT4)
        or (aObj = ROGUE_OBJECT)
        or (aObj = ROGUE_OBJECT2)
        or (aObj = CIRCLE_FILL_OBJ)
        or (aObj = SCOUT_OBJECT3)
        or (aObj = VAGA_OBJECT8)
        or (aObj = SCOUT_OBJECT5)
        or (aObj = SCOUT_OBJECT6) then
        begin
          Actions.UnitKill(AIUnits[K], False);

          if aObj = BOWMAN_ROCKET then
          begin
            TilesRoadLength[Tiles[aX][aY].Owner] := TilesRoadLength[Tiles[aX][aY].Owner] + 9;
            SetLength(TilesRoadX[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);
            SetLength(TilesRoadY[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);
            SetLength(ClearTilesRoadTimes[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);
            SetLength(SetTilesRoadTimes[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);
            SetLength(TilesRoadObjects[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);

            TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 1] := aX;
            TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 1] := aY;
            TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 2] := aX;
            TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 2] := aY - 1;
            TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 3] := aX;
            TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 3] := aY + 1;
            TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 4] := aX - 1;
            TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 4] := aY;
            TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 5] := aX + 1;
            TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 5] := aY;
            TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 6] := aX + 1;
            TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 6] := aY + 1;
            TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 7] := aX + 1;
            TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 7] := aY - 1;
            TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 8] := aX - 1;
            TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 8] := aY + 1;
            TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 9] := aX - 1;
            TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 9] := aY - 1;

            for I := 1 to 9 do
            begin
              TilesRoadObjects[Tiles[aX][aY].Owner][Length(TilesRoadObjects[Tiles[aX][aY].Owner]) - I] := BOWMAN_ROCKET2;
              ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - I] := States.GameTime + 45 + States.KaMRandomI(3);
              SetTilesRoadTimes[Tiles[aX][aY].Owner][Length(SetTilesRoadTimes[Tiles[aX][aY].Owner]) - I] := States.GameTime + 15 + States.KaMRandomI(3);

              if TileOnBattlefield(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) then
              begin
                Tiles[TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I]][TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]].Owner := Tiles[aX][aY].Owner;
                Tiles[TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I]][TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]].Skill := sRocket;
                Tiles[TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I]][TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - 9];
              end;

              if (States.MapTileObject(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) = BARB_OBJECT3)
              or (States.MapTileObject(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) = BOWMAN_ROCKET)
              or (States.MapTileObject(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) = BOWMAN_OBJECT5)
              or (InRange(States.MapTileObject(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
                ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - I] := ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - I] + CLEANUP_TIME + 5;

            end;

            TilesRoadObjects[Tiles[aX][aY].Owner][Length(TilesRoadObjects[Tiles[aX][aY].Owner]) - 1] := BOWMAN_ROCKET2;
            ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - 1] := States.GameTime + 45 + States.KaMRandomI(3);
            SetTilesRoadTimes[Tiles[aX][aY].Owner][Length(SetTilesRoadTimes[Tiles[aX][aY].Owner]) - 1] := States.GameTime + 34;

            ClearRoadTilesArrayTime[Tiles[aX][aY].Owner] := ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - 9] + CLEAR_ARRAY_FACTOR + 2;
         
          end;
        end;
      end;
    end;
  end;
end;


function TileIsDangerous(P, X, Y: Integer): Boolean;
var
  aObj: Integer;
begin
  Result := False;
  if TileOnBattlefield(X, Y) then
  begin
    aObj := States.MapTileobject(X, Y);
    Result := ((aObj = LANCE_OBJECT)
              or (aObj = LANCE_OBJECT2)
              or (aObj = LANCE_OBJECT3)
              or (aObj = BARB_OBJECT)
              or (aObj = BARB_OBJECT2)
              or (aObj = BARB_OBJECT3)
              or (aObj = BARB_OBJECT4)
              or (aObj = BARB_OBJECT5)
              or (aObj = XBOW_OBJECT)
              or (aObj = XBOW_OBJECT2)
              or (aObj = XBOW_OBJECT3)
              or (aObj = PIKE_OBJECT)
              or (aObj = PIKE_OBJECT2)
              or (aObj = PIKE_OBJECT3)
              or (aObj = PIKE_OBJECT4)
              or (aObj = PIKE_OBJECT5)
              or (aObj = PIKE_OBJECT6)
              or (aObj = PIKE_OBJECT7)
              or (aObj = PIKE_OBJECT8)
              or (aObj = PIKE_OBJECT9)
              or (aObj = BOWMAN_OBJECT)
              or (aObj = BOWMAN_OBJECT2)
              or (aObj = BOWMAN_OBJECT3)
              or (aObj = BOWMAN_OBJECT4)
              or (aObj = BOWMAN_ROCKET)
              or (aObj = BOWMAN_ROCKET2)
              or (aObj = AXE_OBJECT2)
              or (aObj = AXE_OBJECT3)
              or (aObj = VAGA_OBJECT2)
              or (aObj = VAGA_OBJECT8)
              or (aObj = WARRIOR_OBJECT3)
              or (aObj = WARRIOR_OBJECT)
              or (aObj = WARRIOR_OBJECT2)
              or (aObj = WARRIOR_OBJECT5)
              or (aObj = WARRIOR_OBJECT6)
              or (aObj = WARRIOR_OBJECT6 + 1)
              or (aObj = KNIGHT_OBJECT4)
              or (aObj = ROGUE_OBJECT)
              or (aObj = ROGUE_OBJECT2)
              or (aObj = CIRCLE_FILL_OBJ)
              or (aObj = SCOUT_OBJECT3)
              or (aObj = SCOUT_OBJECT6)
              or (aObj = SCOUT_OBJECT5));

    Result := Result and (not aObj = PikeObjects[P]);

  end;
end;


procedure CheckVictoryDefeat;
var
  TeamPlayersCount: array[0..1] of Integer;
begin
  for I := 0 to 1 do
    TeamPlayersCount[I] := 0;

  for I := 0 to 7 do
    if States.PlayerEnabled(I) then
    begin
      if Players[I].HP = 0 then
        Actions.PlayerDefeat(I);
    end;

  for J := 0 to 3 do
    if States.PlayerEnabled(J) then
      if not States.PlayerDefeated(J) then
        TeamPlayersCount[0] := TeamPlayersCount[0] + 1;

  for J := 4 to 7 do
    if States.PlayerEnabled(J) then
      if not States.PlayerDefeated(J) then
        TeamPlayersCount[1] := TeamPlayersCount[1] + 1;

  if TeamPlayersCount[0] = 0 then
    for J := 3 to 7 do
      if States.PlayerEnabled(J) then
        if not States.PlayerDefeated(J) then
          Actions.PlayerWin([J], True);

  if TeamPlayersCount[1] = 0 then
    for J := 0 to 3 do
      if States.PlayerEnabled(J) then
        if not States.PlayerDefeated(J) then
          Actions.PlayerWin([J], True);

  for I := 0 to 7 do
    if States.PlayerEnabled(I) then
      if (Players[I].HP = 0)
      and (Players[I].Hero > 0) then
      begin
        if (States.UnitPositionX(States.GroupMember(Players[I].Hero, 0)) <> Players[I].TribuneX)
        and (States.UnitPositionY(States.GroupMember(Players[I].Hero, 0)) <> Players[I].TribuneY) then
        begin
          Actions.GroupKillAll(Players[I].Hero, True);
          Players[I].Hero := Actions.GiveGroup(I, Players[I].HeroType, Players[I].TribuneX, Players[I].TribuneY, 4, 1, 1);
          Actions.GroupHungerSet(Players[I].Hero, States.UnitMaxHunger);
        end;
      end;

end;


procedure CheckTotemCircles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if TotemCirclesLength[P][K] > 0 then
        for I := 0 to TotemCirclesLength[P][K] - 1 do
        begin
          if TileOnBattlefield(TotemCircles[P][K][I].X, TotemCircles[P][K][I].Y) then
          begin
            if (States.GameTime = TotemCircles[P][K][I].AddTime)
            and (TotemCircles[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
              SetCircle(P, TotemCircles[P][K][I].X, TotemCircles[P][K][I].Y, TotemCircles[P][K][I].Radius, TotemCircles[P][K][I].Obj, False, True, sTotem);
          end;
        end;
    end;
end;


procedure CheckRageCircles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if RageCirclesLength[P][K] > 0 then
        for I := 0 to RageCirclesLength[P][K] - 1 do
        begin
          if TileOnBattlefield(RageCircles[P][K][I].X, RageCircles[P][K][I].Y) then
          begin
            if (States.GameTime = RageCircles[P][K][I].AddTime) then
              SetCircle(P, RageCircles[P][K][I].X, RageCircles[P][K][I].Y, RageCircles[P][K][I].Radius, RageCircles[P][K][I].Obj, True, False, sWaveOfRage);
          end;
        end;
    end;
end;


procedure CheckPowerWithinCircles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if PowerWithinCirclesLength[P][K] > 0 then
        for I := 0 to PowerWithinCirclesLength[P][K] - 1 do
        begin
          if TileOnBattlefield(PowerWithinCircles[P][K][I].X, PowerWithinCircles[P][K][I].Y) then
          begin
            if (States.GameTime = PowerWithinCircles[P][K][I].AddTime) then
              SetCircle(P, PowerWithinCircles[P][K][I].X, PowerWithinCircles[P][K][I].Y, PowerWithinCircles[P][K][I].Radius, PowerWithinCircles[P][K][I].Obj, True, False, sPowerWithin);
          end;
        end;
    end;
end;


procedure CheckFireworks1Circles(P: Integer);
var
  aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if FireworksCircles1Length[P][K] > 0 then
        for I := 0 to FireworksCircles1Length[P][K] - 1 do
        begin
          if TileOnBattlefield(FireworksCircles1[P][K][I].X, FireworksCircles1[P][K][I].Y) then
          begin
            if (States.GameTime = FireworksCircles1[P][K][I].AddTime)
            and (FireworksCircles1[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, FireworksCircles1[P][K][I].X, FireworksCircles1[P][K][I].Y, FireworksCircles1[P][K][I].Radius, FireworksCircles1[P][K][I].Obj, False, False, sDeadlyFireworks);

              if not CHANGE_RELIEF then
                Exit;

              for PosX := FireworksCircles1[P][K][I].X - FireworksCircles1[P][K][I].Radius to FireworksCircles1[P][K][I].X + FireworksCircles1[P][K][I].Radius do
              for PosY := FireworksCircles1[P][K][I].Y - FireworksCircles1[P][K][I].Radius to FireworksCircles1[P][K][I].Y + FireworksCircles1[P][K][I].Radius do
              begin
                aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
                if aRelief < 0 then
                  aRelief := -1 * aRelief;
                if (((FireworksCircles1[P][K][I].X - PosX) * (FireworksCircles1[P][K][I].X - PosX) + (FireworksCircles1[P][K][I].Y - PosY) * (FireworksCircles1[P][K][I].Y - PosY)) <= FireworksCircles1[P][K][I].Radius * FireworksCircles1[P][K][I].Radius) then
                  if (TileOnBattlefield(PosX, PosY))
                  and (InRange(States.MapTileHeight(PosX, PosY), 0, 45)) then
                    Actions.MapTileHeightSet(PosX, PosY, aRelief);
              end;

              if I = FireworksCircles1Length[P][K] - 1 then
                for PosX := FireworksCircles1[P][K][I].X - FireworksCircles1[P][K][I].Radius to FireworksCircles1[P][K][I].X + FireworksCircles1[P][K][I].Radius do
                for PosY := FireworksCircles1[P][K][I].Y - FireworksCircles1[P][K][I].Radius to FireworksCircles1[P][K][I].Y + FireworksCircles1[P][K][I].Radius do
                  if (((FireworksCircles1[P][K][I].X - PosX) * (FireworksCircles1[P][K][I].X - PosX) + (FireworksCircles1[P][K][I].Y - PosY) * (FireworksCircles1[P][K][I].Y - PosY)) <= FireworksCircles1[P][K][I].Radius * FireworksCircles1[P][K][I].Radius) then
                    if TileOnBattlefield(PosX, PosY) then
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure CheckFireworks2Circles(P: Integer);
var
  aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if FireworksCircles2Length[P][K] > 0 then
        for I := 0 to FireworksCircles2Length[P][K] - 1 do
        begin
          if TileOnBattlefield(FireworksCircles2[P][K][I].X, FireworksCircles2[P][K][I].Y) then
          begin
            if (States.GameTime = FireworksCircles2[P][K][I].AddTime)
            and (FireworksCircles2[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, FireworksCircles2[P][K][I].X, FireworksCircles2[P][K][I].Y, FireworksCircles2[P][K][I].Radius, FireworksCircles2[P][K][I].Obj, False, False, sDeadlyFireworks);

              if not CHANGE_RELIEF then
                Exit;

              for PosX := FireworksCircles2[P][K][I].X - FireworksCircles2[P][K][I].Radius to FireworksCircles2[P][K][I].X + FireworksCircles2[P][K][I].Radius do
              for PosY := FireworksCircles2[P][K][I].Y - FireworksCircles2[P][K][I].Radius to FireworksCircles2[P][K][I].Y + FireworksCircles2[P][K][I].Radius do
              begin
                aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
                if aRelief < 0 then
                  aRelief := -1 * aRelief;
                if (((FireworksCircles2[P][K][I].X - PosX) * (FireworksCircles2[P][K][I].X - PosX) + (FireworksCircles2[P][K][I].Y - PosY) * (FireworksCircles2[P][K][I].Y - PosY)) <= FireworksCircles2[P][K][I].Radius * FireworksCircles2[P][K][I].Radius) then
                  if (TileOnBattlefield(PosX, PosY))
                  and (InRange(States.MapTileHeight(PosX, PosY), 0, 45)) then
                    Actions.MapTileHeightSet(PosX, PosY, aRelief);
              end;

              if I = FireworksCircles2Length[P][K] - 1 then
                for PosX := FireworksCircles2[P][K][I].X - FireworksCircles2[P][K][I].Radius to FireworksCircles2[P][K][I].X + FireworksCircles2[P][K][I].Radius do
                for PosY := FireworksCircles2[P][K][I].Y - FireworksCircles2[P][K][I].Radius to FireworksCircles2[P][K][I].Y + FireworksCircles2[P][K][I].Radius do
                  if (((FireworksCircles2[P][K][I].X - PosX) * (FireworksCircles2[P][K][I].X - PosX) + (FireworksCircles2[P][K][I].Y - PosY) * (FireworksCircles2[P][K][I].Y - PosY)) <= FireworksCircles2[P][K][I].Radius * FireworksCircles2[P][K][I].Radius) then
                  if TileOnBattlefield(PosX, PosY) then  
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure CheckFireworks3Circles(P: Integer);
var
  aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if FireworksCircles3Length[P][K] > 0 then
        for I := 0 to FireworksCircles3Length[P][K] - 1 do
        begin
          if TileOnBattlefield(FireworksCircles3[P][K][I].X, FireworksCircles3[P][K][I].Y) then
          begin
            if (States.GameTime = FireworksCircles3[P][K][I].AddTime)
            and (FireworksCircles3[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, FireworksCircles3[P][K][I].X, FireworksCircles3[P][K][I].Y, FireworksCircles3[P][K][I].Radius, FireworksCircles3[P][K][I].Obj, False, False, sDeadlyFireworks);

              if not CHANGE_RELIEF then
                Exit;

              for PosX := FireworksCircles3[P][K][I].X - FireworksCircles3[P][K][I].Radius to FireworksCircles3[P][K][I].X + FireworksCircles3[P][K][I].Radius do
              for PosY := FireworksCircles3[P][K][I].Y - FireworksCircles3[P][K][I].Radius to FireworksCircles3[P][K][I].Y + FireworksCircles3[P][K][I].Radius do
              begin
                aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
                if aRelief < 0 then
                  aRelief := -1 * aRelief;
                if (((FireworksCircles3[P][K][I].X - PosX) * (FireworksCircles3[P][K][I].X - PosX) + (FireworksCircles3[P][K][I].Y - PosY) * (FireworksCircles3[P][K][I].Y - PosY)) <= FireworksCircles3[P][K][I].Radius * FireworksCircles3[P][K][I].Radius) then
                  if (TileOnBattlefield(PosX, PosY))
                  and (InRange(States.MapTileHeight(PosX, PosY), 0, 45)) then
                    Actions.MapTileHeightSet(PosX, PosY, aRelief);
              end;

              if I = FireworksCircles3Length[P][K] - 1 then
                for PosX := FireworksCircles3[P][K][I].X - FireworksCircles3[P][K][I].Radius to FireworksCircles3[P][K][I].X + FireworksCircles3[P][K][I].Radius do
                for PosY := FireworksCircles3[P][K][I].Y - FireworksCircles3[P][K][I].Radius to FireworksCircles3[P][K][I].Y + FireworksCircles3[P][K][I].Radius do
                  if (((FireworksCircles3[P][K][I].X - PosX) * (FireworksCircles3[P][K][I].X - PosX) + (FireworksCircles3[P][K][I].Y - PosY) * (FireworksCircles3[P][K][I].Y - PosY)) <= FireworksCircles3[P][K][I].Radius * FireworksCircles3[P][K][I].Radius) then
                  if TileOnBattlefield(PosX, PosY) then
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure CheckFireworks4Circles(P: Integer);
var
  aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if FireworksCircles4Length[P][K] > 0 then
        for I := 0 to FireworksCircles4Length[P][K] - 1 do
        begin
          if TileOnBattlefield(FireworksCircles4[P][K][I].X, FireworksCircles4[P][K][I].Y) then
          begin
            if (States.GameTime = FireworksCircles4[P][K][I].AddTime)
            and (FireworksCircles4[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, FireworksCircles4[P][K][I].X, FireworksCircles4[P][K][I].Y, FireworksCircles4[P][K][I].Radius, FireworksCircles4[P][K][I].Obj, False, False, sDeadlyFireworks);

              if not CHANGE_RELIEF then
                Exit;

              for PosX := FireworksCircles4[P][K][I].X - FireworksCircles4[P][K][I].Radius to FireworksCircles4[P][K][I].X + FireworksCircles4[P][K][I].Radius do
              for PosY := FireworksCircles4[P][K][I].Y - FireworksCircles4[P][K][I].Radius to FireworksCircles4[P][K][I].Y + FireworksCircles4[P][K][I].Radius do
              begin
                aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
                if aRelief < 0 then
                  aRelief := -1 * aRelief;
                if (((FireworksCircles4[P][K][I].X - PosX) * (FireworksCircles4[P][K][I].X - PosX) + (FireworksCircles4[P][K][I].Y - PosY) * (FireworksCircles4[P][K][I].Y - PosY)) <= FireworksCircles4[P][K][I].Radius * FireworksCircles4[P][K][I].Radius) then
                  if (TileOnBattlefield(PosX, PosY))
                  and (InRange(States.MapTileHeight(PosX, PosY), 0, 45)) then
                    Actions.MapTileHeightSet(PosX, PosY, aRelief);
              end;

              if I = FireworksCircles4Length[P][K] - 1 then
                for PosX := FireworksCircles4[P][K][I].X - FireworksCircles4[P][K][I].Radius to FireworksCircles4[P][K][I].X + FireworksCircles4[P][K][I].Radius do
                for PosY := FireworksCircles4[P][K][I].Y - FireworksCircles4[P][K][I].Radius to FireworksCircles4[P][K][I].Y + FireworksCircles4[P][K][I].Radius do
                  if (((FireworksCircles4[P][K][I].X - PosX) * (FireworksCircles4[P][K][I].X - PosX) + (FireworksCircles4[P][K][I].Y - PosY) * (FireworksCircles4[P][K][I].Y - PosY)) <= FireworksCircles4[P][K][I].Radius * FireworksCircles4[P][K][I].Radius) then
                    if TileOnBattlefield(PosX, PosY) then
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure CheckFireworks5Circles(P: Integer);
var
  aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if FireworksCircles5Length[P][K] > 0 then
        for I := 0 to FireworksCircles5Length[P][K] - 1 do
        begin
          if TileOnBattlefield(FireworksCircles5[P][K][I].X, FireworksCircles5[P][K][I].Y) then
          begin
            if (States.GameTime = FireworksCircles5[P][K][I].AddTime)
            and (FireworksCircles5[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, FireworksCircles5[P][K][I].X, FireworksCircles5[P][K][I].Y, FireworksCircles5[P][K][I].Radius, FireworksCircles5[P][K][I].Obj, False, False, sDeadlyFireworks);

              if not CHANGE_RELIEF then
                Exit;

              for PosX := FireworksCircles5[P][K][I].X - FireworksCircles5[P][K][I].Radius to FireworksCircles5[P][K][I].X + FireworksCircles5[P][K][I].Radius do
              for PosY := FireworksCircles5[P][K][I].Y - FireworksCircles5[P][K][I].Radius to FireworksCircles5[P][K][I].Y + FireworksCircles5[P][K][I].Radius do
              begin
                aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
                if aRelief < 0 then
                  aRelief := -1 * aRelief;
                if (((FireworksCircles5[P][K][I].X - PosX) * (FireworksCircles5[P][K][I].X - PosX) + (FireworksCircles5[P][K][I].Y - PosY) * (FireworksCircles5[P][K][I].Y - PosY)) <= FireworksCircles5[P][K][I].Radius * FireworksCircles5[P][K][I].Radius) then
                  if (TileOnBattlefield(PosX, PosY))
                  and (InRange(States.MapTileHeight(PosX, PosY), 0, 45)) then
                    Actions.MapTileHeightSet(PosX, PosY, aRelief);
              end;

              if I = FireworksCircles5Length[P][K] - 1 then
                for PosX := FireworksCircles5[P][K][I].X - FireworksCircles5[P][K][I].Radius to FireworksCircles5[P][K][I].X + FireworksCircles5[P][K][I].Radius do
                for PosY := FireworksCircles5[P][K][I].Y - FireworksCircles5[P][K][I].Radius to FireworksCircles5[P][K][I].Y + FireworksCircles5[P][K][I].Radius do
                  if (((FireworksCircles5[P][K][I].X - PosX) * (FireworksCircles5[P][K][I].X - PosX) + (FireworksCircles5[P][K][I].Y - PosY) * (FireworksCircles5[P][K][I].Y - PosY)) <= FireworksCircles5[P][K][I].Radius * FireworksCircles5[P][K][I].Radius) then
                    if TileOnBattlefield(PosX, PosY) then
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure CheckExpCircles(P: Integer);
var
  aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if ExpCirclesLength[P][K] > 0 then
        for I := 0 to ExpCirclesLength[P][K] - 1 do
        begin
          if TileOnBattlefield(ExpCircles[P][K][I].X, ExpCircles[P][K][I].Y) then
          begin
            if (States.GameTime = ExpCircles[P][K][I].AddTime)
            and (ExpCircles[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, ExpCircles[P][K][I].X, ExpCircles[P][K][I].Y, ExpCircles[P][K][I].Radius, ExpCircles[P][K][I].Obj, False, False, sRevengeFromNowhere);

              if not CHANGE_RELIEF then
                Exit;

              for PosX := ExpCircles[P][K][I].X - ExpCircles[P][K][I].Radius to ExpCircles[P][K][I].X + ExpCircles[P][K][I].Radius do
              for PosY := ExpCircles[P][K][I].Y - ExpCircles[P][K][I].Radius to ExpCircles[P][K][I].Y + ExpCircles[P][K][I].Radius do
              begin
                aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
                if aRelief < 0 then
                  aRelief := -1 * aRelief;
                if (((ExpCircles[P][K][I].X - PosX) * (ExpCircles[P][K][I].X - PosX) + (ExpCircles[P][K][I].Y - PosY) * (ExpCircles[P][K][I].Y - PosY)) <= ExpCircles[P][K][I].Radius * ExpCircles[P][K][I].Radius) then
                  if (TileOnBattlefield(PosX, PosY))
                  and (InRange(States.MapTileHeight(PosX, PosY), 0, 45)) then
                    Actions.MapTileHeightSet(PosX, PosY, aRelief);
              end;

              if I = ExpCirclesLength[P][K] - 1 then
                for PosX := ExpCircles[P][K][I].X - ExpCircles[P][K][I].Radius to ExpCircles[P][K][I].X + ExpCircles[P][K][I].Radius do
                for PosY := ExpCircles[P][K][I].Y - ExpCircles[P][K][I].Radius to ExpCircles[P][K][I].Y + ExpCircles[P][K][I].Radius do
                  if (((ExpCircles[P][K][I].X - PosX) * (ExpCircles[P][K][I].X - PosX) + (ExpCircles[P][K][I].Y - PosY) * (ExpCircles[P][K][I].Y - PosY)) <= ExpCircles[P][K][I].Radius * ExpCircles[P][K][I].Radius) then
                    if TileOnBattlefield(PosX, PosY) then
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure CheckKnightCircles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if KnightCirclesLength[P][K] > 0 then
        for I := 0 to KnightCirclesLength[P][K] - 1 do
        begin
          if TileOnBattlefield(KnightCircles[P][K][I].X, KnightCircles[P][K][I].Y) then
          begin
            if (States.GameTime = KnightCircles[P][K][I].AddTime) then
            begin
              SetCircle(P, KnightCircles[P][K][I].X, KnightCircles[P][K][I].Y, KnightCircles[P][K][I].Radius, KnightCircles[P][K][I].Obj, True, False, sDeafeningClatter);
            end;
          end;
        end;
    end;
end;


procedure CheckRogueCircles(P: Integer);
var
  aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if RogueCirclesLength[P][K] > 0 then
        for I := 0 to RogueCirclesLength[P][K] - 1 do
        begin
          if TileOnBattlefield(RogueCircles[P][K][I].X, RogueCircles[P][K][I].Y) then
          begin
            if (States.GameTime = RogueCircles[P][K][I].AddTime)
            and (RogueCircles[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, RogueCircles[P][K][I].X, RogueCircles[P][K][I].Y, RogueCircles[P][K][I].Radius, RogueCircles[P][K][I].Obj, False, False, sMentalBurst);

              if not CHANGE_RELIEF then
                Exit;

              for PosX := RogueCircles[P][K][I].X - RogueCircles[P][K][I].Radius to RogueCircles[P][K][I].X + RogueCircles[P][K][I].Radius do
              for PosY := RogueCircles[P][K][I].Y - RogueCircles[P][K][I].Radius to RogueCircles[P][K][I].Y + RogueCircles[P][K][I].Radius do
              begin
                aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
                if aRelief < 0 then
                aRelief := -1 * aRelief;
                if (((RogueCircles[P][K][I].X - PosX) * (RogueCircles[P][K][I].X - PosX) + (RogueCircles[P][K][I].Y - PosY) * (RogueCircles[P][K][I].Y - PosY)) <= RogueCircles[P][K][I].Radius * RogueCircles[P][K][I].Radius) then
                  if (TileOnBattlefield(PosX, PosY))
                  and (InRange(States.MapTileHeight(PosX, PosY), 0, 45)) then
                    Actions.MapTileHeightSet(PosX, PosY, aRelief);
              end;

              if I = RogueCirclesLength[P][K] - 1 then
                for PosX := RogueCircles[P][K][I].X - RogueCircles[P][K][I].Radius to RogueCircles[P][K][I].X + RogueCircles[P][K][I].Radius do
                for PosY := RogueCircles[P][K][I].Y - RogueCircles[P][K][I].Radius to RogueCircles[P][K][I].Y + RogueCircles[P][K][I].Radius do
                  if (((RogueCircles[P][K][I].X - PosX) * (RogueCircles[P][K][I].X - PosX) + (RogueCircles[P][K][I].Y - PosY) * (RogueCircles[P][K][I].Y - PosY)) <= RogueCircles[P][K][I].Radius * RogueCircles[P][K][I].Radius) then
                    if TileOnBattlefield(PosX, PosY) then
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure CheckStolenRogueCircles(P: Integer);
var
  aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if StolenRogueCirclesLength[P][K] > 0 then
        for I := 0 to StolenRogueCirclesLength[P][K] - 1 do
        begin
          if TileOnBattlefield(StolenRogueCircles[P][K][I].X, StolenRogueCircles[P][K][I].Y) then
          begin
            if (States.GameTime = StolenRogueCircles[P][K][I].AddTime)
            and (StolenRogueCircles[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, StolenRogueCircles[P][K][I].X, StolenRogueCircles[P][K][I].Y, StolenRogueCircles[P][K][I].Radius, StolenRogueCircles[P][K][I].Obj, False, False, sMentalBurst);

              if not CHANGE_RELIEF then
                Exit;

              for PosX := StolenRogueCircles[P][K][I].X - StolenRogueCircles[P][K][I].Radius to StolenRogueCircles[P][K][I].X + StolenRogueCircles[P][K][I].Radius do
              for PosY := StolenRogueCircles[P][K][I].Y - StolenRogueCircles[P][K][I].Radius to StolenRogueCircles[P][K][I].Y + StolenRogueCircles[P][K][I].Radius do
              begin
                aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
                if aRelief < 0 then
                  aRelief := -1 * aRelief;
                if (((StolenRogueCircles[P][K][I].X - PosX) * (StolenRogueCircles[P][K][I].X - PosX) + (StolenRogueCircles[P][K][I].Y - PosY) * (StolenRogueCircles[P][K][I].Y - PosY)) <= StolenRogueCircles[P][K][I].Radius * StolenRogueCircles[P][K][I].Radius) then
                  if (TileOnBattlefield(PosX, PosY))
                  and (InRange(States.MapTileHeight(PosX, PosY), 0, 45)) then
                    Actions.MapTileHeightSet(PosX, PosY, aRelief);
              end;

              if I = StolenRogueCirclesLength[P][K] - 1 then
                for PosX := StolenRogueCircles[P][K][I].X - StolenRogueCircles[P][K][I].Radius to StolenRogueCircles[P][K][I].X + StolenRogueCircles[P][K][I].Radius do
                for PosY := StolenRogueCircles[P][K][I].Y - StolenRogueCircles[P][K][I].Radius to StolenRogueCircles[P][K][I].Y + StolenRogueCircles[P][K][I].Radius do
                  if (((StolenRogueCircles[P][K][I].X - PosX) * (StolenRogueCircles[P][K][I].X - PosX) + (StolenRogueCircles[P][K][I].Y - PosY) * (StolenRogueCircles[P][K][I].Y - PosY)) <= StolenRogueCircles[P][K][I].Radius * StolenRogueCircles[P][K][I].Radius) then
                    if TileOnBattlefield(PosX, PosY) then
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure CheckViseCircles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if ViseCirclesLength[P][K] > 0 then
        for I := 0 to ViseCirclesLength[P][K] - 1 do
        begin
          if TileOnBattlefield(ViseCircles[P][K][I].X, ViseCircles[P][K][I].Y) then
          begin
            if (States.GameTime = ViseCircles[P][K][I].AddTime) then
            begin
              SetCircle(P, ViseCircles[P][K][I].X, ViseCircles[P][K][I].Y, VISE_RADIUS, 255, False, False, sViseOfDeath);
              SetCircle(P, ViseCircles[P][K][I].X, ViseCircles[P][K][I].Y, ViseCircles[P][K][I].Radius, ViseCircles[P][K][I].Obj, False, False, sViseOfDeath);
            end;
          end;
        end;
    end;
end;


procedure CheckGravityCircles(P: Integer);
var
  X, Y, O, U, G, UT, CC, OT, HT: Integer;
begin
  if States.PlayerEnabled(P) then
    if GravityCirclesLength[P] > 0 then
      for CC := 0 to GravityCirclesLength[P] - 1 do
      begin
        if TileOnBattlefield(GravityCircles[P][CC].X, GravityCircles[P][CC].Y) then
        begin
          if (States.GameTime = GravityCircles[P][CC].AddTime) then
          begin
            SetCircle(P, GravityCircles[P][CC].X, GravityCircles[P][CC].Y, GRAVITY_RADIUS, 255, False, True, sGravity);
            SetCircle(P, GravityCircles[P][CC].X, GravityCircles[P][CC].Y, GravityCircles[P][CC].Radius, GravityCircles[P][CC].Obj, False, True, sGravity);
            for X := GravityCircles[P][CC].X - GravityCircles[P][CC].Radius - 1 to GravityCircles[P][CC].X + GravityCircles[P][CC].Radius + 1 do
            for Y := GravityCircles[P][CC].Y - GravityCircles[P][CC].Radius - 1 to GravityCircles[P][CC].Y + GravityCircles[P][CC].Radius + 1 do
            begin
              if (((X - GravityCircles[P][CC].X) * (X - GravityCircles[P][CC].X) + (Y - GravityCircles[P][CC].Y) * (Y - GravityCircles[P][CC].Y)) <= GravityCircles[P][CC].Radius * GravityCircles[P][CC].Radius) then
              begin
                U := States.UnitAt(X, Y);
                if U <> -1 then
                begin
                  O := States.UnitOwner(U);
                  UT := States.UnitType(U);
                  if (InRange(O, 0, 7))
                  and (not Players[O].HeroImmortal) then
                  begin
                    Actions.GroupKillAll(Players[O].Hero, True);
                    Players[O].Hero := Actions.GiveGroup(O, Players[O].HeroType, Players[P].GravityX + States.KaMRandomI(2) - States.KaMRandomI(2), Players[P].GravityY + States.KaMRandomI(2) - States.KaMRandomI(2), States.KaMRandomI(8), 1, 1);
                    Actions.GroupHungerSet(Players[O].Hero, States.UnitMaxHunger);
                    if not Players[O].MovedByGravity then
                    begin
                      Players[O].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
                      Players[O].PlayerStatus := Players[O].PlayerStatus + '|<$72> ' + '[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[]<$71> ' + SkillName(sGravity);
                      Players[O].MovedByGravity := True;
                      Players[O].GravityUser := P;
                      Players[O].GravityTime := States.GameTime + GRAVITY_MOVE_TIME;
                      if Players[O].HeroStunned then
                        Actions.GroupBlockOrders(Players[O].Hero, True);
                    end;
                    Break;
                    Exit;
                  end
                  else
                    if (InRange(O, 8, 11)) then 
                    begin
                      for I := 0 to Length(Zombies) - 1 do
                        if U = Zombies[I].ID then
                        begin
                          OT := Zombies[I].Owner;
                          HT := States.UnitHunger(Zombies[I].ID);
                        end;
                      Actions.GroupKillAll(States.UnitsGroup(U), True);
                      G := Actions.GiveGroup(O, UT, Players[P].GravityX + States.KaMRandomI(2) - States.KaMRandomI(2), Players[P].GravityY + States.KaMRandomI(2) - States.KaMRandomI(2), States.KaMRandomI(8), 1, 1);
                      SetLength(Zombies, Length(Zombies) + 1);
                      Zombies[Length(Zombies) - 1].Owner := OT;
                      Zombies[Length(Zombies) - 1].ID := States.GroupMember(G, 0);
                      Actions.GroupHungerSet(G, HT);
                      Break;
                      Exit;
                    end;
                  if not InRange (O, 0, 11) then
                    Exit;
                end;
              end;
            end;
          end;
        end;
      end;
end;


procedure CheckConcentrationCircles(P: Integer);
var
  aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if ConcentrationCirclesLength[P][K] > 0 then
        for I := 0 to ConcentrationCirclesLength[P][K] - 1 do
        begin
          if TileOnBattlefield(ConcentrationCircles[P][K][I].X, ConcentrationCircles[P][K][I].Y) then
          begin
            if (States.GameTime = ConcentrationCircles[P][K][I].AddTime)
            and (ConcentrationCircles[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, ConcentrationCircles[P][K][I].X, ConcentrationCircles[P][K][I].Y, ConcentrationCircles[P][K][I].Radius, ConcentrationCircles[P][K][I].Obj, False, False, sConcentration);

              if not CHANGE_RELIEF then
                Exit;

              for PosX := ConcentrationCircles[P][K][I].X - ConcentrationCircles[P][K][I].Radius to ConcentrationCircles[P][K][I].X + ConcentrationCircles[P][K][I].Radius do
              for PosY := ConcentrationCircles[P][K][I].Y - ConcentrationCircles[P][K][I].Radius to ConcentrationCircles[P][K][I].Y + ConcentrationCircles[P][K][I].Radius do
              begin
                aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR - 4) - States.KaMRandomI(RELIEF_CHANGE_FACTOR - 4);
                if aRelief < 0 then
                  aRelief := -1 * aRelief;
                if (((ConcentrationCircles[P][K][I].X - PosX) * (ConcentrationCircles[P][K][I].X - PosX) + (ConcentrationCircles[P][K][I].Y - PosY) * (ConcentrationCircles[P][K][I].Y - PosY)) <= ConcentrationCircles[P][K][I].Radius * ConcentrationCircles[P][K][I].Radius) then
                  if (TileOnBattlefield(PosX, PosY))
                  and (InRange(States.MapTileHeight(PosX, PosY), 0, 45)) then
                    Actions.MapTileHeightSet(PosX, PosY, aRelief);
              end;

              if I = ConcentrationCirclesLength[P][K] - 1 then
                for PosX := ConcentrationCircles[P][K][I].X - ConcentrationCircles[P][K][I].Radius to ConcentrationCircles[P][K][I].X + ConcentrationCircles[P][K][I].Radius do
                for PosY := ConcentrationCircles[P][K][I].Y - ConcentrationCircles[P][K][I].Radius to ConcentrationCircles[P][K][I].Y + ConcentrationCircles[P][K][I].Radius do
                  if (((ConcentrationCircles[P][K][I].X - PosX) * (ConcentrationCircles[P][K][I].X - PosX) + (ConcentrationCircles[P][K][I].Y - PosY) * (ConcentrationCircles[P][K][I].Y - PosY)) <= ConcentrationCircles[P][K][I].Radius * ConcentrationCircles[P][K][I].Radius) then
                    if TileOnBattlefield(PosX, PosY) then
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure OnPlayerDefeated(P: Integer);
begin
  if (InRange(P, 0, 7)) then
  begin
    Actions.FogRevealAll(P);
    Actions.GroupKillAll(Players[P].Hero, True);
    Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].TribuneX, Players[P].TribuneY, 4, 1, 1);
    Actions.CinematicStart(P);
    Actions.CinematicPanTo(P, Players[P].TribuneX, Players[P].TribuneY, 0);
    Actions.CinematicEnd(P);
    if Length(Zombies) > 0 then
      for I := 0 to Length(Zombies) - 1 do
        if Zombies[I].Owner = P then
          Actions.UnitKill(Zombies[I].ID, False);
  end;
end;


procedure OnPlayerVictory(P: Integer);
begin
  if (InRange(P, 0, 7)) then
    Actions.FogRevealAll(P);
end;


procedure OnUnitWounded(aID, aAttacker: Integer);
begin
  for I := 0 to Length(Zombies) - 1 do
    if aAttacker = Zombies[I].ID then
    begin
      LastAttacker := Zombies[I].Owner;
      LastAttackerUnitType := States.UnitType(aAttacker);
    end;
end;


procedure OnUnitDied(aID, aKiller: Integer);
var
  O, aX, aY, X, Y: Integer;
begin
  if aID < 0 then
    Exit;

  if States.GameTime > GAME_START_TIME then
  begin
    SortScoresLeft;
    SortScoresRight;
  end;

  O := States.UnitOwner(aID);
  aX := States.UnitPositionX(aID);
  aY := States.UnitPositionY(aID);

  if InRange(O, 0, 7) then
    for X := MIN_X to MAX_X do
    for Y := MIN_Y to MAX_Y do
      Actions.MapTileSet(X, Y, Tiles[X][Y].TileType, Tiles[X][Y].TileDirection);

  if (InRange(O, 0, 7))
  and (InRange(aKiller, 9, 11)) then
  begin

    Players[O].HeroSilentTime := 0;
    if (not Players[O].CaptureMind)
    and (not Players[O].MindStunned) then
      Players[O].HeroStunnedTime := 0;
    Players[O].HeroInFearTime := 0;
    Players[O].PreparingTime := 0;
    Players[O].DDTime := 0;
    Players[O].ReChargeTime := 0;

    if States.GameTime < Players[O].MindTime2 then
    begin
      Players[O].MindTime2 := 0;
      Players[O].WineSkillDelay := 500;
    end;
    
    if TilesRoadLength[O] > 0 then
      if (Players[O].HeroType <> 23)
      or ((Players[O].HeroType = 23)
      and (States.GameTime < Players[O].CrackingStartTime)) then
        for I := 0 to TilesRoadLength[O] - 1 do
          if SetTilesRoadTimes[O][I] > States.GameTime then
            if (TilesRoadObjects[O][I] <> BOWMAN_ROCKET)
            and (TilesRoadObjects[O][I] <> BOWMAN_OBJECT6) then
            begin
              SetTilesRoadTimes[O][I] := 0;
              TilesRoadObjects[O][I] := SKILL_CANCEL_OBJ;
            end;

    if TilesFieldLength[O] > 0 then
      for I := 0 to TilesFieldLength[O] - 1 do
        if SetTilesFieldTimes[O][I] > States.GameTime then
        begin
          SetTilesFieldTimes[O][I] := 0;
          TilesFieldObjects[O][I] := SKILL_CANCEL_OBJ;
        end;

    if TilesWineLength[O] > 0 then
      if ((Players[O].HeroType <> 25)
      and (Players[O].LastUsedSkill <> sCrackingEarth))
      or ((Players[O].HeroType = 25)
      and (Players[O].LastUsedSkill = sCrackingEarth)
      and (States.GameTime < Players[O].CrackingStartTime)) then
        for I := 0 to TilesWineLength[O] - 1 do
          if SetTilesWineTimes[O][I] > States.GameTime then
          begin
            SetTilesWineTimes[O][I] := 0;
            TilesWineObjects[O][I] := SKILL_CANCEL_OBJ;
          end;

  end;

  if InRange(aKiller, 9, 11) then
  begin

    Players[O].TrackStartTime := 0;
    Players[O].TrackStopTime := 0;
    Players[O].SettingTrack := False;
    Players[O].PowerWithinCircleCycles := 0;
    Players[O].PowerWithinCircleTime := 0;

    for I := 0 to 7 do
    begin

      if Players[I].RopeAttacker = O then
        Players[I].RopeAttacker := -1;

      if Players[I].ScoutSilenceGiver = O then
        Players[I].ScoutSilenceGiver := -1;

    end;

    for K := 0 to SPURT_LENGTH - 1 do
      SpurtTimes[O][K] := 0;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to TotemCirclesLength[O][K] - 1 do
        if (TotemCircles[O][K][I].AddTime > States.GameTime)
        and (TotemCircles[O][K][I].Obj <> 255) then
          TotemCircles[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to ConcentrationCirclesLength[O][K] - 1 do
        ConcentrationCircles[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to ExpCirclesLength[O][K] - 1 do
        if (ExpCircles[O][K][I].AddTime > States.GameTime)
        and (ExpCircles[O][K][I].Obj <> 255)  then
          ExpCircles[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to RogueCirclesLength[O][K] - 1 do
        if (RogueCircles[O][K][I].AddTime > States.GameTime)
        and (RogueCircles[O][K][I].Obj <> 255)  then
          RogueCircles[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to StolenRogueCirclesLength[O][K] - 1 do
        if (StolenRogueCircles[O][K][I].AddTime > States.GameTime)
        and (StolenRogueCircles[O][K][I].Obj <> 255)  then
          StolenRogueCircles[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to FireworksCircles1Length[O][K] - 1 do
        if (FireworksCircles1[O][K][I].AddTime > States.GameTime)
        and (FireworksCircles1[O][K][I].Obj <> 255)  then
          FireworksCircles1[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to FireworksCircles2Length[O][K] - 1 do
        if (FireworksCircles2[O][K][I].AddTime > States.GameTime)
        and (FireworksCircles2[O][K][I].Obj <> 255)  then
          FireworksCircles2[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to FireworksCircles3Length[O][K] - 1 do
        if (FireworksCircles3[O][K][I].AddTime > States.GameTime)
        and (FireworksCircles3[O][K][I].Obj <> 255)  then
          FireworksCircles3[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to FireworksCircles4Length[O][K] - 1 do
        if (FireworksCircles4[O][K][I].AddTime > States.GameTime)
        and (FireworksCircles4[O][K][I].Obj <> 255)  then
          FireworksCircles4[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to FireworksCircles5Length[O][K] - 1 do
        if (FireworksCircles5[O][K][I].AddTime > States.GameTime)
        and (FireworksCircles5[O][K][I].Obj <> 255)  then
          FireworksCircles5[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to PowerWithinCirclesLength[O][K] - 1 do
        if (PowerWithinCircles[O][K][I].AddTime > States.GameTime)
        and (PowerWithinCircles[O][K][I].Obj <> 255) then
          PowerWithinCircles[O][K][I].Obj := SKILL_CANCEL_OBJ;

  end;

  for I := 0 to 7 do
  for K := 0 to 3 do
    if ZomboHero[I][K] > 0 then
      if aID = States.GroupMember(ZomboHero[I][K], 0) then
        ZomboHero[I][K] := -1;

  if (InRange(aKiller, 9, 11))
  and (InRange(States.UnitOwner(aID), 0, 7))
  and (aID = States.GroupMember(Players[O].Hero, 0)) then
  begin
    if InRange(LastAttacker, 0, 11) then
    begin
      Players[LastAttacker].Kills := Players[LastAttacker].Kills + 1;
      Players[O].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
      Players[LastAttacker].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
      if LastAttackerUnitType = 14 then
      begin
        Players[O].PlayerStatus := Players[O].PlayerStatus + '|<$75> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + '[]';
        Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$89> ' + '[$' + States.PlayerColorText(O) + ']' + States.PlayerName(O) + '[]';
      end;
      if InRange(LastAttackerUnitType, 15, 27) then
      begin
        Players[O].PlayerStatus := Players[O].PlayerStatus + '|<$76> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + '[]';
        Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$90> ' + '[$' + States.PlayerColorText(O) + ']' + States.PlayerName(O) + '[]';
      end;
      Players[O].RespawnCheckTime := States.GameTime + 10;
      Players[LastAttacker].TotalKills := Players[LastAttacker].TotalKills + 1;
      SetLength(Players[LastAttacker].KillTimes, Length(Players[LastAttacker].KillTimes) + 1);
      Players[LastAttacker].KillTimes[Length(Players[LastAttacker].KillTimes) - 1] := States.GameTime;
        if Length(Players[LastAttacker].KillTimes) >= 4 then
          if (Players[LastAttacker].KillTimes[Length(Players[LastAttacker].KillTimes) - 1] - Players[LastAttacker].KillTimes[Length(Players[LastAttacker].KillTimes) - 4] <= RAMPAGE_CHECK_TIME)
          {and (not Players[LastAttacker].Rampage)} then
          begin
            Actions.PlayWAV(-1, 'Rampage', 1);
            Players[LastAttacker].Rampage := True;
            Players[LastAttacker].KillsCountTime := States.GameTime + KILLS_REFRESH_TIME;
          end;
        if Length(Players[LastAttacker].KillTimes) >= 3 then
          if (Players[LastAttacker].KillTimes[Length(Players[LastAttacker].KillTimes) - 1] - Players[LastAttacker].KillTimes[Length(Players[LastAttacker].KillTimes) - 3] <= TRIPLE_KILL_CHECK_TIME)
          and (not Players[LastAttacker].TripleKill)
          and (not Players[LastAttacker].Rampage) then
          begin
            Actions.PlayWAV(-1, 'TripleKill', 1);
            Players[LastAttacker].TripleKill := True;
            Players[LastAttacker].KillsCountTime := Players[LastAttacker].KillsCountTime + MAX_TIME_BETWEEN_KILLS;
          end;
        if Length(Players[LastAttacker].KillTimes) >= 2 then
          if (Players[LastAttacker].KillTimes[Length(Players[LastAttacker].KillTimes) - 1] - Players[LastAttacker].KillTimes[Length(Players[LastAttacker].KillTimes) - 2] <= DOUBLE_KILL_CHECK_TIME)
          and (not Players[LastAttacker].DoubleKill)
          and (not Players[LastAttacker].TripleKill)
          and (not Players[LastAttacker].Rampage) then
          begin
            Actions.PlayWAV(-1, 'DoubleKill', 1);
            Players[LastAttacker].DoubleKill := True;
            Players[LastAttacker].KillsCountTime := Players[LastAttacker].KillsCountTime + MAX_TIME_BETWEEN_KILLS;
          end;
    end;
    if Players[O].HP > 0 then
    begin 
      Players[O].Hero := -1;
      Players[O].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[O].HeroType, Players[O].TempX, Players[O].TempY, 4, 1, 1);
      Players[O].HeroReborn := True;
      Players[O].RebornTime := States.GameTime + REBORN_TIME;
      if not (Players[O].CaptureMind)
      and not (Players[O].MindStunned) then
        Players[States.UnitOwner(aID)].HP := Players[States.UnitOwner(aID)].HP - 1;
      if Players[O].CaptureMind then
        Players[M[O]].HP := Players[M[O]].HP - 1;
      if Players[O].MindStunned then
        begin
          Players[M2[O]].HP := Players[M2[O]].HP - 1;
          Actions.GroupBlockOrders(Players[O].Hero, True);
          Actions.GroupOrderHalt(Players[O].Hero);
        end;
    end;
    Actions.GroupHungerSet(Players[O].Hero, States.UnitMaxHunger);
    if Players[O].HP = 0 then
    begin
      Actions.FogRevealAll(O);
      Actions.GroupKillAll(Players[O].Hero, True);
      Players[O].Hero := Actions.GiveGroup(O, Players[O].HeroType, Players[O].TribuneX, Players[O].TribuneY, 4, 1, 1);
      Actions.GroupHungerSet(Players[O].Hero, States.UnitMaxHunger);
      Actions.CinematicStart(O);
      Actions.CinematicPanTo(O, Players[O].TribuneX, Players[O].TribuneY, 0);
      Actions.CinematicEnd(O);
    end;
  end;
end;


procedure RandomChoice;
begin
  for I := 0 to 7 do
    if (States.PlayerEnabled(I)) then
      if (not Players[I].HeroChosen)
      and (Players[I].Hero = -1) then
      begin
        Players[I].HeroType := States.KaMRandomI(6) + 18;
        if States.KaMRandomI(5) = 3 then
          Players[I].HeroType := 26;
        if States.KaMRandomI(15) = 8 then
          Players[I].HeroType := 25;
        Players[I].HeroChosen := True;
        Players[I].TempHeroType := Players[I].HeroType;
      end;
end;


procedure SetHeroes;
begin

  for J := 0 to Length(AISoldiers) - 1 do
    if States.GroupOwner(AISoldiers[J]) <> 8 then
      Actions.GroupKillAll(AISoldiers[J], True);

  for I := 4 to 7 do
    if States.PlayerEnabled(I) then
      Actions.PlayerAllianceChange(I, 8, True, False);

  for I := 0 to 7 do
    if Players[I].HeroChosen then
    begin
      Players[I].Hero := Actions.GiveGroup(I, Players[I].HeroType, Players[I].SpawnX, Players[I].SpawnY, Players[I].Direction, 1, 1);
      Actions.GroupHungerSet(Players[I].Hero, States.UnitMaxHunger);
      Players[I].HeroImmortal := True;
      Players[I].HeroImmortalTime := States.GameTime + IMMORTAL_TIME;
      Actions.CinematicStart(I);
      Actions.CinematicPanTo(I, Players[I].SpawnX, Players[I].SpawnY, 0);
      Actions.CinematicEnd(I);
    end;

  for K := 0 to 7 do
    if States.PlayerEnabled(K) then
    begin
      Actions.FogCoverAll(K);
      Actions.FogRevealRect(K, 1, 39, 70, 109);
    end;

  Actions.ShowMsg(-1, '<$62>');

  Actions.ShowMsg(-1, '<$63>');

end;


procedure CheckStatus;
var
  I1, aX, aY: Integer;
begin
  for I1 := 0 to 7 do
    if Players[I1].Hero > 0 then
    begin 

      if Players[I1].HP < 0 then
        Players[I1].HP := 0;

      if Players[I1].HP = 0 then
      begin
        Players[I1].HeroReborn := False;
        Players[I1].RebornTime := 0;
        if not Players[I1].MovedToTribune then
        begin
          Actions.FogRevealAll(I1);
          Actions.CinematicStart(I1);
          Actions.CinematicPanTo(I1, Players[I1].TribuneX, Players[I1].TribuneY, 0);
          Actions.CinematicEnd(I1);
          Actions.GroupHungerset(Players[I1].Hero, States.UnitMaxHunger);
          Actions.GroupBlockOrders(Players[I1].Hero, True);
          Players[I1].MovedToTribune := True;
        end;
      end;

      if (Players[I1].HP <= 0)
      and (not States.FogRevealed(I1, 2, 40)) then
        Actions.FogRevealAll(I1);

      if (Players[I1].HP > 0)
      and (States.FogRevealed(I1, Players[I1].TempX, Players[I1].TempY))
      and (not States.PlayerVictorious(I1)) then
      begin
        Actions.FogCoverAll(I1);
        Actions.FogRevealRect(I1, 1, 39, 70, 109);
      end;

      if States.GameTime = Players[I1].PlayerStatusTime then
        Players[I1].PlayerStatus := '';

      if (States.GameTime = Players[I1].ReChoiceTime)
      and (Players[I1].ReChoice) then
        EndReChoice(I1);

      if Players[I1].HeroStunned then
      begin
        Actions.GroupOrderHalt(Players[I1].Hero);
        Actions.GroupBlockOrders(Players[I1].Hero, True);
        if TileOnBattlefield(States.UnitPositionX(States.GroupMember(Players[I1].Hero, 0)), States.UnitPositionY(States.GroupMember(Players[I1].Hero, 0))) then
          if States.GameTime mod 3 = 1 then
            Actions.MapTileSet(States.UnitPositionX(States.GroupMember(Players[I1].Hero, 0)), States.UnitPositionY(States.GroupMember(Players[I1].Hero, 0)), STUN_ANIMATION, States.KaMRandomI(4));
      end;

      if States.GameTime = Players[I1].RebornTime then
      begin
        Actions.GroupKillAll(Players[I1].Hero, True);
        Players[I1].Hero := Actions.GiveGroup(I1, Players[I1].HeroType, Players[I1].SpawnX, Players[I1].SpawnY, Players[I1].Direction, 1, 1);
        Actions.CinematicStart(I1);
        Actions.CinematicPanTo(I1, Players[I1].SpawnX, Players[I1].SpawnY, 0);
        Actions.CinematicEnd(I1);
        Actions.GroupHungerSet(Players[I1].Hero, States.UnitMaxHunger);
        Players[I1].HeroImmortal := True;
        Players[I1].HeroImmortalTime := States.GameTime + IMMORTAL_TIME;
        Players[I1].HeroReborn := False;

        TilesFieldLength[I1] := TilesFieldLength[I1] + 8;
        SetLength(TilesFieldX[I1], TilesFieldLength[I1]);
        SetLength(TilesFieldY[I1], TilesFieldLength[I1]);
        SetLength(ClearTilesFieldTimes[I1], TilesFieldLength[I1]);
        SetLength(SetTilesFieldTimes[I1], TilesFieldLength[I1]);
        SetLength(TilesFieldObjects[I1], TilesFieldLength[I1]);

        TilesFieldX[I1][Length(TilesFieldX[I1]) - 1] := Players[I1].SpawnX;
        TilesFieldY[I1][Length(TilesFieldY[I1]) - 1] := Players[I1].SpawnY - 1;
        TilesFieldX[I1][Length(TilesFieldX[I1]) - 2] := Players[I1].SpawnX;
        TilesFieldY[I1][Length(TilesFieldY[I1]) - 2] := Players[I1].SpawnY + 1;
        TilesFieldX[I1][Length(TilesFieldX[I1]) - 3] := Players[I1].SpawnX - 1;
        TilesFieldY[I1][Length(TilesFieldY[I1]) - 3] := Players[I1].SpawnY;
        TilesFieldX[I1][Length(TilesFieldX[I1]) - 4] := Players[I1].SpawnX + 1;
        TilesFieldY[I1][Length(TilesFieldY[I1]) - 4] := Players[I1].SpawnY;
        TilesFieldX[I1][Length(TilesFieldX[I1]) - 5] := Players[I1].SpawnX + 1;
        TilesFieldY[I1][Length(TilesFieldY[I1]) - 5] := Players[I1].SpawnY + 1;
        TilesFieldX[I1][Length(TilesFieldX[I1]) - 6] := Players[I1].SpawnX + 1;
        TilesFieldY[I1][Length(TilesFieldY[I1]) - 6] := Players[I1].SpawnY - 1;
        TilesFieldX[I1][Length(TilesFieldX[I1]) - 7] := Players[I1].SpawnX - 1;
        TilesFieldY[I1][Length(TilesFieldY[I1]) - 7] := Players[I1].SpawnY + 1;
        TilesFieldX[I1][Length(TilesFieldX[I1]) - 8] := Players[I1].SpawnX - 1;
        TilesFieldY[I1][Length(TilesFieldY[I1]) - 8] := Players[I1].SpawnY - 1;

        for I := 1 to 8 do
        begin
          TilesFieldObjects[I1][Length(TilesFieldObjects[I1]) - I] := PikeObjects[I1];
          ClearTilesFieldTimes[I1][Length(ClearTilesFieldTimes[I1]) - I] := States.GameTime + 1 + FENCE_TIME;
          SetTilesFieldTimes[I1][Length(SetTilesFieldTimes[I1]) - I] := States.GameTime + 1;

          if (States.MapTileObject(TilesFieldX[I1][Length(TilesFieldX[I1]) - I], TilesFieldY[I1][Length(TilesFieldY[I1]) - I]) = BARB_OBJECT3)
          or (States.MapTileObject(TilesFieldX[I1][Length(TilesFieldX[I1]) - I], TilesFieldY[I1][Length(TilesFieldY[I1]) - I]) = BOWMAN_ROCKET)
          or (States.MapTileObject(TilesFieldX[I1][Length(TilesFieldX[I1]) - I], TilesFieldY[I1][Length(TilesFieldY[I1]) - I]) = BOWMAN_OBJECT5)
          or (InRange(States.MapTileObject(TilesFieldX[I1][Length(TilesFieldX[I1]) - I], TilesFieldY[I1][Length(TilesFieldY[I1]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
            ClearTilesFieldTimes[I1][Length(ClearTilesFieldTimes[I1]) - I] := ClearTilesFieldTimes[I1][Length(ClearTilesFieldTimes[I1]) - I] + CLEANUP_TIME;

        end;

        ClearFieldTilesArrayTime[I1] := ClearTilesFieldTimes[I1][Length(ClearTilesFieldTimes[I1]) - 8] + CLEAR_ARRAY_FACTOR + 2;

      end;

      if States.GameTime = Players[I1].VagaAppearTime then
      begin
        Actions.GroupKillAll(Players[I1].Hero, True);
        Players[I1].Hero := Actions.GiveGroup(I1, 27, Players[I1].VagaX, Players[I1].VagaY, Players[I1].VagaDir, 1, 1);
        Actions.GroupHungerSet(Players[I1].Hero, States.UnitMaxHunger);
        Players[I1].WerewolfTime := States.GameTime + WEREWOLF_TIME;
        if Players[I1].HP > 0 then
        begin
          Actions.FogCoverAll(I1);
          Actions.FogRevealRect(I1, 1, 39, 70, 109);
        end;
      end;

      if States.GameTime = Players[I1].KillsCountTime then
      begin
        Players[I1].DoubleKill := False;
        Players[I1].TripleKill := False;
        Players[I1].Rampage := False;
        SetLength(Players[I1].KillTimes, 0);
        Players[I1].KillsCountTime := Players[I1].KillsCountTime + KILLS_REFRESH_TIME;
      end;

      if States.GameTime = Players[I1].WerewolfTime then
      begin
        Players[I1].VagaX := States.UnitPositionX(States.GroupMember(Players[I1].Hero, 0));
        Players[I1].VagaY := States.UnitPositionY(States.GroupMember(Players[I1].Hero, 0));
        Players[I1].VagaDir := States.UnitDirection(States.GroupMember(Players[I1].Hero, 0));
        Actions.GroupKillAll(Players[I1].Hero, True);
        Players[I1].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[I1].HeroType, Players[I1].TempX, Players[I1].TempY, 4, 1, 1);
        Players[I1].VagaAppearTimeBack := States.GameTime + DELAY_OF_TURNING;
        if Players[I1].HP > 0 then
        begin
          Actions.FogCoverAll(I1);
          Actions.FogRevealRect(I1, 1, 39, 70, 109);
        end;
      end;

      if States.GameTime = Players[I1].VagaAppearTimeBack then  
      begin
        if Players[I1].Hero > 0 then   
        begin
          Actions.GroupKillAll(Players[I1].Hero, True);
          Players[I1].Hero := Actions.GiveGroup(I1, Players[I1].TempHeroType, Players[I1].VagaX, Players[I1].VagaY, Players[I1].VagaDir, 1, 1);
          Players[I1].HeroType := Players[I1].TempHeroType;
          Actions.GroupHungerSet(Players[I1].Hero, States.UnitMaxHunger);
          Players[I1].RoadSkillDelay := 0;
          Players[I1].FieldSkillDelay := 0;
          Players[I1].WineSkillDelay := AXE_WINE_DELAY * (1 - Round(RECHARGE_FACTOR * Byte(Players[I1].ReCharge))) - WEREWOLF_TIME;
          if Players[I1].HP > 0 then
          begin
            Actions.FogCoverAll(I1);
            Actions.FogRevealRect(I1, 1, 39, 70, 109);
          end;
        end;
      end;

      if States.GameTime = Players[I1].PikeAppearTime then  
      begin
        if Players[I1].Hero > 0 then   
        begin
          Actions.GroupKillAll(Players[I1].Hero, True);
          Players[I1].Hero := Actions.GiveGroup(I1, Players[I1].TempHeroType, Players[I1].PikeX, Players[I1].PikeY, Players[I1].PikeDir, 1, 1);
          Players[I1].HeroType := Players[I1].TempHeroType;
          Actions.GroupHungerSet(Players[I1].Hero, States.UnitMaxHunger);
          if Players[I1].HP > 0 then
          begin
            Actions.FogCoverAll(I1);
            Actions.FogRevealRect(I1, 1, 39, 70, 109);
          end;
        end;
      end;

      {if States.GameTime = Players[I1].KnightAppearTime then  
      begin
        if Players[I1].Hero > 0 then   
        begin
          Players[I1].Hero := Actions.GiveGroup(I1, Players[I1].TempHeroType, Players[I1].KnightX, Players[I1].KnightY, Players[I1].KnightDir, 1, 1);
          Players[I1].HeroType := Players[I1].TempHeroType;
          Actions.GroupHungerSet(Players[I1].Hero, States.UnitMaxHunger);
        end;
      end;}

      if (States.PlayerEnabled(I1))
      and (Players[I1].Hero > 0) then
      begin
        if (States.UnitPositionY(States.GroupMember(Players[I1].Hero, 0)) < MIN_Y)
        and (States.GroupOwner(Players[I1].Hero) = I1)
        and (Players[I1].HP > 0) then
        begin
          Actions.GroupKillAll(Players[I1].Hero, True);
          Players[I1].Hero := Actions.GiveGroup(I1, Players[I1].HeroType, Players[I1].SpawnX, Players[I1].SpawnY, Players[I1].Direction, 1, 1);
        end;
      end;

      if States.GameTime = Players[I1].PowerWithinCircleTime then
        DrawPowerWithinCircle(I1);

      if States.GameTime = Players[I1].TrackStartTime then
      begin
        Players[I1].SettingTrack := True;
        Players[I1].TrackStopTime := States.GameTime + TRACK_TIME;
      end;

      if States.GameTime = Players[I1].TrackStopTime then
      begin
        Players[I1].SettingTrack := False;
      end;

      if States.GameTime = Players[I1].FireworkTime then
        for aX := Players[I1].FireworkX - FIREWORKS1_RADIUS - FIREWORKS2_RADIUS - 2 to Players[I1].FireworkX + FIREWORKS1_RADIUS + FIREWORKS2_RADIUS + 2 do
        for aY := Players[I1].FireworkY - FIREWORKS1_RADIUS - FIREWORKS2_RADIUS - 2 to Players[I1].FireworkY + FIREWORKS1_RADIUS + FIREWORKS2_RADIUS + 2 do
          if States.MapTileObject(aX, aY) = AXE_OBJECT2 then
            Actions.MapTileObjectSet(aX, aY, 255);

      if (Players[I1].SettingTrack)
      and ((States.GameTime - Players[I1].TrackStopTime) mod TRACK_FACTOR = 0)
      and (States.GroupOwner(Players[I1].Hero) = I1)
      and (Players[I1].Hero > 0)
      and (Players[I1].HP > 0) then
        if TileOnBattlefield(FieryTrackX(I1), FieryTrackY(I1)) then
        begin
          TilesFieldLength[I1] := TilesFieldLength[I1] + 1;
          SetLength(TilesFieldX[I1], TilesFieldLength[I1]);
          SetLength(TilesFieldY[I1], TilesFieldLength[I1]);
          SetLength(ClearTilesFieldTimes[I1], TilesFieldLength[I1]);
          SetLength(SetTilesFieldTimes[I1], TilesFieldLength[I1]);
          SetLength(TilesFieldObjects[I1], TilesFieldLength[I1]);  
          TilesFieldX[I1][Length(TilesFieldX[I1]) - 1] := FieryTrackX(I1);    
          TilesFieldY[I1][Length(TilesFieldY[I1]) - 1] := FieryTrackY(I1);
          TilesFieldObjects[I1][Length(TilesFieldObjects[I1]) - 1] := VAGA_OBJECT8;    
          ClearTilesFieldTimes[I1][Length(ClearTilesFieldTimes[I1]) - 1] := Players[I1].TrackStopTime + 3;    
          SetTilesFieldTimes[I1][Length(SetTilesFieldTimes[I1]) - 1] := States.GameTime + 1;
          Tiles[TilesFieldX[I1][Length(TilesFieldX[I1]) - 1]][TilesFieldY[I1][Length(TilesFieldY[I1]) - 1]].Owner := I1;
          Tiles[TilesFieldX[I1][Length(TilesFieldX[I1]) - 1]][TilesFieldY[I1][Length(TilesFieldY[I1]) - 1]].Skill := sTrack;
        end;

      if (States.GameTime >= Players[I1].GravityTime)
      and (Players[I1].MovedByGravity) then
        Players[I1].MovedByGravity := False;

      if (States.GameTime >= Players[I1].HeroSilentTime)
      and (Players[I1].HeroSilent) then
        Players[I1].HeroSilent := False;

      if (States.GameTime >= Players[I1].ReChargeTime)
      and (Players[I1].ReCharge) then
        Players[I1].ReCharge := False;

      if (States.GameTime >= Players[I1].PreparingTime)
      and (Players[I1].Preparing) then
        Players[I1].Preparing := False;

      if States.GameTime = Players[I1].ArmorStartTime then
      begin
        Players[I1].HeroImmortal := True;
        Players[I1].HeroImmortalTime := States.GameTime + ARMOR_TIME;
        Players[I1].PlayerStatusTime := States.GameTime + ARMOR_TIME + 5;
        Players[I1].PlayerStatus := Players[I1].PlayerStatus + '|<$70> ' + '[$' + States.PlayerColorText(Players[I1].ArmorGiver) + ']' + States.PlayerName(Players[I1].ArmorGiver) + '[]<$71> ' + SkillName(sSturdyArmor);
      end;

      if States.GameTime = Players[I1].SpurtStartTime then
      begin
        StartSpurt(I1);
        if not Players[I1].HeroImmortal then
        begin
          Players[I1].HeroImmortalTime := (States.GameTime + SPURT_TIME + 5) - 27 - SPURT_AI_FACTOR * Byte(States.PlayerIsAI(I1));
          Players[I1].HeroImmortal := True;
        end;
        Players[I1].Preparing := True;
        Players[I1].PreparingTime := (States.GameTime + SPURT_TIME + 5) - 27 - SPURT_AI_FACTOR * Byte(States.PlayerIsAI(I1));
      end;

      if (States.GameTime = Players[I1].ScoutSilenceStartTime)
      and (InRange(Players[I1].ScoutSilenceGiver, 0, 11)) then
      begin
        Players[I1].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
        Players[I1].PlayerStatus := Players[I1].PlayerStatus + '|<$73> ' + '[$' + States.PlayerColorText(Players[I1].ScoutSilenceGiver) + ']' + States.PlayerName(Players[I1].ScoutSilenceGiver) + '[]<$71> ' + SkillName(sSilence);
        Players[I1].HeroSilent := True;
        Players[I1].HeroSilentTime := States.GameTime + SILENCE_SCOUT_TIME;
      end;

      if States.GameTime = Players[I1].RopeTime then
        if (InRange(Players[I1].RopeAttacker, 0, 7))
        and (States.GroupOwner(Players[I1].Hero) = I1) then
        begin
          Actions.GroupKillAll(Players[I1].Hero, True);
          Players[I1].Hero := Actions.GiveGroup(I1, Players[I1].HeroType, Players[I1].RopeDX
          + States.UnitPositionX(States.GroupMember(Players[Players[I1].RopeAttacker].Hero, 0)), Players[I1].RopeDY
          + States.UnitPositionY(States.GroupMember(Players[Players[I1].RopeAttacker].Hero, 0)), Players[I1].RopeUnitDir, 1, 1);
          Actions.GroupHungerSet(Players[I1].Hero, States.UnitMaxHunger);
          if Players[I1].HeroStunned then
            Actions.GroupBlockOrders(Players[I1].Hero, True);
          Players[I1].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
          Players[I1].PlayerStatus := Players[I1].PlayerStatus + '|<$72> ' + '[$' + States.PlayerColorText(Players[I1].RopeAttacker) + ']' + States.PlayerName(Players[I1].RopeAttacker) + '[]<$71> ' + SkillName(sRopesOfDeath);
        end;

      if (States.GameTime >= Players[I1].RopeTime + ROPE_DELAY)
      and (Players[I1].MovedByRopes) then
        Players[I1].MovedByRopes := False;

      if States.GameTime = Players[I1].SkillTime then
        Players[I1].CastingSkill := False;

      if (States.GameTime >= Players[I1].HeroImmortalTime)
      and (Players[I1].HeroImmortal) then
        Players[I1].HeroImmortal := False;

      if (States.GameTime >= Players[I1].DDTime)
      and (Players[I1].DD) then
        Players[I1].DD := False;

      if (States.GameTime >= Players[I1].HeroPrisonedTime)
      and (Players[I1].HeroPrisoned) then
        Players[I1].HeroPrisoned := False;

      if (ZomboHero[I1][0] = -1)
      and (ZomboHero[I1][1] = -1) 
      and (ZomboHero[I1][2] = -1) 
      and (ZomboHero[I1][3] = -1) then
        Players[I1].InIllusion := False;

      if (States.GameTime >= Players[I1].HeroStunnedTime)
      and (Players[I1].HeroStunned) then
      begin
        Players[I1].HeroStunned := False;
        if Players[I1].Hero > 0 then
        begin
          Actions.GroupBlockOrders(Players[I1].Hero, False);
          Actions.GroupOrderHalt(Players[I1].Hero);
        end;
      end;

      if (Players[I1].HeroInFear)
      and not (Players[I1].HeroStunned) then
      begin
        if Players[I1].Hero > 0 then
        begin
          Actions.GroupOrderWalk(Players[I1].Hero, States.KaMRandomI(48) + 12, States.KaMRandomI(48) + 51, States.KaMRandomI(8));
        end;
      end;

      if (States.GameTime >= Players[I1].HeroInFearTime)
      and (Players[I1].HeroInFear) then
      begin
        Players[I1].HeroInFear := False;
        if Players[I1].Hero > 0 then
        begin
          Actions.GroupBlockOrders(Players[I1].Hero, False);
          Actions.GroupOrderHalt(Players[I1].Hero);
        end;
      end;

      if States.GameTime = Players[I1].MindTime then
      begin
        Actions.GroupKillAll(Players[I1].Hero, True);
        Players[I1].Hero := Actions.GiveGroup(I1, Players[I1].HeroType, Players[I1].MindX2, Players[I1].MindY2, Players[I1].MindDir2, 1, 1);
        Actions.GroupKillAll(Players[M[I1]].Hero, True);
        Players[M[I1]].Hero := Actions.GiveGroup(M[I1], Players[M[I1]].HeroType, Players[I1].MindX, Players[I1].MindY, Players[I1].MindDir, 1, 1);
        Actions.GroupBlockOrders(Players[I1].Hero, True);
        Actions.GroupOrderHalt(Players[I1].Hero); 
        Actions.GroupBlockOrders(Players[M[I1]].Hero, True);
        Actions.GroupOrderHalt(Players[M[I1]].Hero);  
        Players[I1].MindTime2 := States.GameTime + 30;
        Players[M[I1]].HeroStunned := True;
        Players[M[I1]].HeroStunnedTime := States.GameTime + 30;
        Actions.FogCoverAll(I1);
        Actions.FogRevealRect(I1, 1, 39, 70, 109);
        Actions.FogCoverAll(M[I1]);
        Actions.FogRevealRect(M[I1], 1, 39, 70, 109);
      end;

      if States.GameTime = Players[I1].MindTime2 then
      begin
        if Length(Zombies) > 0 then
        for K := 0 to Length(Zombies) - 1 do
          if Zombies[K].Owner = M[I1] then
            Zombies[K].Owner := -1;
        Players[M[I1]].MindStunned := True;
        Players[I1].CaptureMind := True;
        Players[M[I1]].StunnedMindTime := States.GameTime + CAPTURE_MIND_TIME - 30; 
        Players[I1].CaptureMindTime := States.GameTime + CAPTURE_MIND_TIME - 30;
        Players[I1].TempPlayersTeam := Players[I1].PlayersTeam;
        Players[I1].HeroMindType := Players[I1].HeroType;
        Players[M[I1]].HeroMindType := Players[M[I1]].HeroType;
        Players[I1].TempHeroMindType := Players[I1].TempHeroType;
        Players[I1].TempStolenSkill := Players[I1].StolenSkill;
        Players[I1].TempStolenSkillTime := Players[I1].StolenSkillTime;
        Players[I1].TempStolenSkillName := Players[I1].StolenSkillName;
        Players[I1].TempReCharge := Players[I1].ReCharge;
        Players[I1].TempReChargeTime := Players[I1].ReChargeTime;

        Actions.GroupKillAll(Players[I1].Hero, True);
        Players[I1].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[I1].HeroType, Players[I1].TempX, Players[I1].TempY, 4, 1, 1);
        Actions.GroupKillAll(Players[M[I1]].Hero, True);
        Players[M[I1]].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[M[I1]].HeroType, Players[M[I1]].TempX, Players[M[I1]].TempY, 4, 1, 1);
        Players[I1].MindAppearTime := States.GameTime + DELAY_OF_TURNING;
        Actions.FogCoverAll(I1);
        Actions.FogRevealRect(I1, 1, 39, 70, 109);
        Actions.FogCoverAll(M[I1]);
        Actions.FogRevealRect(M[I1], 1, 39, 70, 109);
      end;

      if States.GameTime = Players[I1].MindAppearTime then
      begin
        Actions.FogCoverAll(I1);
        Actions.FogRevealRect(I1, 1, 39, 70, 109);
        Actions.FogCoverAll(M[I1]);
        Actions.FogRevealRect(M[I1], 1, 39, 70, 109);
        if Players[M[I1]].HeroType = 27 then
        begin
          Players[I1].WerewolfTime := Players[M[I1]].WerewolfTime;
          Players[M[I1]].WerewolfTime := 0;
          Players[M[I1]].HeroMindType := 15;
        end;

        Players[I1].HeroType := Players[M[I1]].HeroType
        Actions.GroupKillAll(Players[I1].Hero, True);
        Players[I1].Hero := Actions.GiveGroup(I1, Players[M[I1]].HeroType, Players[I1].MindX, Players[I1].MindY, Players[I1].MindDir, 1, 1);
        Players[I1].TempHeroType := Players[M[I1]].TempHeroType;
        Players[I1].HeroStunned := Players[M[I1]].HeroStunned;
        Players[I1].HeroStunnedTime := Players[M[I1]].HeroStunnedTime;
 
        Players[M[I1]].HeroStunned := True;
        Players[M[I1]].HeroType := Players[I1].HeroMindType;
        Actions.GroupKillAll(Players[M[I1]].Hero, True);
        Players[M[I1]].Hero := Actions.GiveGroup(M[I1], Players[M[I1]].HeroType, Players[I1].MindX2, Players[I1].MindY2, Players[I1].MindDir2, 1, 1);

        Actions.GroupHungerSet(Players[I1].Hero, States.UnitMaxHunger);
        Actions.GroupHungerSet(Players[M[I1]].Hero, States.UnitMaxHunger);
        Actions.GroupBlockOrders(Players[M[I1]].Hero, True);
        Actions.GroupOrderHalt(Players[M[I1]].Hero);  
        Players[I1].HeroImmortal := True;
 
        Players[I1].LastUsedSkill := sMind;
        Players[I1].StolenSkill := Players[M[I1]].StolenSkill;
        Players[I1].StolenSkillTime := Players[M[I1]].StolenSkillTime;
        Players[I1].StolenSkillName := Players[M[I1]].StolenSkillName;
        Players[I1].ReCharge := Players[M[I1]].ReCharge;
        Players[I1].ReChargeTime := Players[M[I1]].ReChargeTime;
        Players[I1].Preparing := Players[M[I1]].Preparing;
        Players[I1].PreparingTime := Players[M[I1]].PreparingTime;
        Players[I1].HeroInFear := Players[M[I1]].HeroInFear;
        Players[I1].HeroInFearTime := Players[M[I1]].HeroInFearTime;
        Players[I1].RoadSkillDelay := Players[M[I1]].RoadSkillDelay;
        Players[I1].FieldSkillDelay := Players[M[I1]].FieldSkillDelay;
        Players[I1].WineSkillDelay := Players[M[I1]].WineSkillDelay;
        if Players[M[I1]].PlayersTeam = 0 then
          Players[I1].PlayersTeam := 1;
        if Players[M[I1]].PlayersTeam = 1 then
          Players[I1].PlayersTeam := 0;
  
        Players[M[I1]].HeroStunnedTime := States.GameTime + CAPTURE_MIND_TIME - 27;
        Players[I1].HeroImmortalTime := States.GameTime + CAPTURE_MIND_TIME - 27;
      end;

      if States.GameTime = Players[I1].CaptureMindTime then
      begin
        Actions.FogCoverAll(I1);
        Actions.FogRevealRect(I1, 1, 39, 70, 109);
        Actions.FogCoverAll(M[I1]);
        Actions.FogRevealRect(M[I1], 1, 39, 70, 109);
        if Players[I1].Hero > 0 then
        begin
          Players[I1].MindX := States.UnitPositionX(States.GroupMember(Players[I1].Hero, 0));
          Players[I1].MindY := States.UnitPositionY(States.GroupMember(Players[I1].Hero, 0));
          Players[I1].MindDir := States.UnitDirection(States.GroupMember(Players[I1].Hero, 0));
          Actions.GroupKillAll(Players[I1].Hero, True);
          Players[I1].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[I1].HeroType, Players[I1].TempX, Players[I1].TempY, 4, 1, 1);
        end;
        if Players[M[I1]].Hero > 0 then
        begin
          if Players[M[I1]].HP > 0 then
          begin
            Players[I1].MindX2 := States.UnitPositionX(States.GroupMember(Players[M[I1]].Hero, 0));
            Players[I1].MindY2 := States.UnitPositionY(States.GroupMember(Players[M[I1]].Hero, 0));
          end;
          if Players[M[I1]].HP <= 0 then
          begin
            Players[I1].MindX2 := States.UnitPositionX(States.GroupMember(Players[I1].Hero, 0));
            Players[I1].MindY2 := States.UnitPositionY(States.GroupMember(Players[I1].Hero, 0));
          end;
          Players[I1].MindDir2 := States.UnitDirection(States.GroupMember(Players[M[I1]].Hero, 0));
          Actions.GroupKillAll(Players[M[I1]].Hero, True);
          Players[M[I1]].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[M[I1]].HeroType, Players[M[I1]].TempX, Players[M[I1]].TempY, 4, 1, 1);
        end;
        Players[I1].MindAppearTimeBack := States.GameTime + DELAY_OF_TURNING;
      end;

      if States.GameTime = Players[I1].MindAppearTimeBack then
      begin
        Actions.FogCoverAll(I1);
        Actions.FogRevealRect(I1, 1, 39, 70, 109);
        Actions.FogCoverAll(M[I1]);
        Actions.FogRevealRect(M[I1], 1, 39, 70, 109);
        if Players[M[I1]].HP = 0 then 
        begin
          Players[I1].MindX2 := Players[I1].MindX;
          Players[I1].MindY2 := Players[I1].MindY;
        end;
        Players[I1].CaptureMind := False;
        Players[M[I1]].MindStunned := False;
        if (Players[I1].Hero > 0)
        and (Players[M[I1]].Hero > 0) then
        begin
          if Players[I1].HeroType = 27 then
          begin
            Players[M[I1]].WerewolfTime := Players[I1].WerewolfTime;
            Players[I1].WerewolfTime := 0;
            Players[M[I1]].HeroMindType := 27;
          end;
          Players[I1].HeroType := Players[I1].HeroMindType;
          Players[M[I1]].HeroType := Players[M[I1]].HeroMindType;
          Players[I1].TempHeroType := Players[I1].TempHeroMindType;
          Actions.GroupKillAll(Players[I1].Hero, True);
          Players[I1].Hero := Actions.GiveGroup(I1, Players[I1].HeroType, Players[I1].MindX2, Players[I1].MindY2, Players[I1].MindDir2, 1, 1);
          Actions.GroupKillAll(Players[M[I1]].Hero, True);
          Players[M[I1]].Hero := Actions.GiveGroup(M[I1], Players[M[I1]].HeroType, Players[I1].MindX, Players[I1].MindY, Players[I1].MindDir, 1, 1);
          Players[M[I1]].RoadSkillDelay := Players[I1].RoadSkillDelay;
          Players[M[I1]].FieldSkillDelay := Players[I1].FieldSkillDelay;
          Players[M[I1]].WineSkillDelay := Players[I1].WineSkillDelay;
          Players[I1].RoadSkillDelay := 0;
          Players[I1].FieldSkillDelay := 0;
          Players[I1].WineSkillDelay := Round(SCOUT_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[I1].ReCharge)));
          Players[M[I1]].LastUsedSkill := Players[I1].LastUsedSkill;
          Players[M[I1]].StolenSkill := Players[I1].StolenSkill;
          Players[M[I1]].StolenSkillTime := Players[I1].StolenSkillTime;
          Players[M[I1]].StolenSkillName := Players[I1].StolenSkillName;
          Players[I1].StolenSkill := Players[I1].TempStolenSkill;
          Players[I1].StolenSkillTime := Players[I1].TempStolenSkillTime;
          Players[I1].StolenSkillName := Players[I1].TempStolenSkillName;
          Players[M[I1]].ReCharge := Players[I1].ReCharge;
          Players[I1].ReCharge := Players[I1].TempReCharge;
          Players[M[I1]].ReChargeTime := Players[I1].ReChargeTime;
          Players[I1].ReChargeTime := Players[I1].TempReChargeTime;
          Players[M[I1]].Preparing := Players[I1].Preparing;
          Players[M[I1]].PreparingTime := Players[I1].PreparingTime;
          if Players[I1].Preparing then
          begin
            Players[I1].Preparing := False;
            Players[I1].PreparingTime := 0;
            Players[I1].HeroStunned := False;
            Players[I1].HeroStunnedTime := 0;
          end;
          if Players[I1].SpurtStartTime < States.GameTime then
            for I := 0 to Players[I1].CurrentSpurtLength - 1 do
              if SpurtTimes[I1][I] > States.GameTime then
                SpurtTimes[I1][I] := 0;
          if Players[I1].SpurtStartTime > States.GameTime then
          begin
            Players[M[I1]].SpurtStartTime := Players[I1].SpurtStartTime;
            Players[M[I1]].CurrentSpurtLength := Players[I1].CurrentSpurtLength;
            Players[I1].SpurtStartTime := 0;
            Players[I1].CurrentSpurtLength := 0;
            for I := 0 to Players[M[I1]].CurrentSpurtLength - 1 do
            begin
              SpurtX[M[I1]][I] := SpurtX[I1][I];
              SpurtY[M[I1]][I] := SpurtY[I1][I];
              SpurtTimes[M[I1]][I] := SpurtTimes[I1][I];
              SpurtDir[M[I1]][I] := SpurtDir[I1][I];
              Tiles[SpurtX[M[I1]][I]][SpurtY[M[I1]][I]].Owner := M[I1];
              SpurtTimes[I1][I] := 0;
            end;
            TilesWineLength[M[I1]] := TilesWineLength[I1];
            SetLength(TilesWineX[M[I1]], TilesWineLength[M[I1]]);
            SetLength(TilesWineY[M[I1]], TilesWineLength[M[I1]]);
            SetLength(TilesWineObjects[M[I1]], TilesWineLength[M[I1]]);
            SetLength(SetTilesWineTimes[M[I1]], TilesWineLength[M[I1]]);
            SetLength(ClearTilesWineTimes[M[I1]], TilesWineLength[M[I1]]);
            for K := 1 to TilesWineLength[M[I1]] - 1 do
            begin
              TilesWineX[M[I1]][K] := TilesWineX[I1][K];
              TilesWineY[M[I1]][K] := TilesWineY[I1][K];
              TilesWineObjects[M[I1]][K] := TilesWineObjects[I1][K];
              SetTilesWineTimes[M[I1]][K] := SetTilesWineTimes[I1][K];
              ClearTilesWineTimes[M[I1]][K] := ClearTilesWineTimes[I1][K];
            end;
            ClearWineTilesArrayTime[M[I1]] := ClearWineTilesArrayTime[I1];
            Players[I1].SpurtStartTime := 0;
          end;
          Players[M[I1]].HeroInFear := Players[I1].HeroInFear;
          Players[M[I1]].HeroInFearTime := Players[I1].HeroInFearTime;
          Players[M[I1]].HeroStunned := Players[I1].HeroStunned;
          Players[M[I1]].HeroStunnedTime := Players[I1].HeroStunnedTime;
          Players[I1].PlayersTeam := Players[I1].TempPlayersTeam;
          Actions.GroupHungerSet(Players[I1].Hero, States.UnitMaxHunger);
          Actions.GroupHungerSet(Players[M[I1]].Hero, States.UnitMaxHunger);
          Players[M[I1]].HeroImmortal := True;
          Players[M[I1]].HeroImmortalTime := States.GameTime + 20;
          if Length(Zombies) > 0 then
          for K := 0 to Length(Zombies) - 1 do
            if Zombies[K].Owner = -1 then
              Zombies[K].Owner := M[I1];
        end;
      end;
    end;
end;


procedure CheckTileRoadObjects(P: Integer);
var
  aRelief: Integer;
begin
  for K := 0 to TilesRoadLength[P] - 1 do
  begin
    if (TilesRoadX[P][K] > 0)
    and (TilesRoadY[P][K] > 0) then
      if TileOnBattlefield(TilesRoadX[P][K], TilesRoadY[P][K])
      and (TilesRoadObjects[P][K] <> SKILL_CANCEL_OBJ) then
      begin

        if (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K] - 1))
        and (TilesRoadObjects[P][K] = BARB_OBJECT3) then
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], BARB_OBJECT3);

        if (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K] - 1))
        and (TilesRoadObjects[P][K] = KNIGHT_OBJECT4) then
        begin
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], KNIGHT_OBJECT4);
          Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].Skill := sRagingSpurt;
          Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].Owner := P;
        end;

        if (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K] - 1))
        and (TilesRoadObjects[P][K] = SCOUT_OBJECT6) then
        begin
          Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].Skill := sBoomerang;
          Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].Owner := P;
        end;

        if (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K] - 1))
        and (TilesRoadObjects[P][K] = CIRCLE_FILL_OBJ) then
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], CIRCLE_FILL_OBJ);

        if (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K] - 1))
        and (TilesRoadObjects[P][K] = WARRIOR_OBJECT5) then
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], WARRIOR_OBJECT5);

        if States.GameTime = ClearTilesRoadTimes[P][K] + CLEAR_ARRAY_FACTOR - 1 then
          Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].Skill := sNone;

        if (InRange(States.GameTime, ClearTilesRoadTimes[P][K], CLEAR_ARRAY_FACTOR - 1 + ClearTilesRoadTimes[P][K]))
        and (States.MapTileObject(TilesRoadX[P][K], TilesRoadY[P][K]) <> 255) then
        begin
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], 255);

          if (CHANGE_RELIEF)
          and (InRange(States.MapTileHeight(TilesRoadX[P][K], TilesRoadY[P][K]), 0, 45)) then
            Actions.MapTileHeightSet(TilesRoadX[P][K], TilesRoadY[P][K], Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].Relief);

        end;

        if (TilesRoadObjects[P][K] = BARB_OBJECT)
        and (States.MapTileObject(TilesRoadX[P][K], TilesRoadY[P][K]) = BARB_OBJECT)
        and (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K]))
        and (States.GameTime mod 3 = 0)
        and (CHANGE_RELIEF)
        and (InRange(States.MapTileHeight(TilesRoadX[P][K], TilesRoadY[P][K]), 0, 45)) then
        begin
          aRelief := Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].Relief + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
          if aRelief < 0 then
            aRelief := -1 * aRelief;
          Actions.MapTileHeightSet(TilesRoadX[P][K], TilesRoadY[P][K], aRelief);
        end;

        if States.GameTime = SetTilesRoadTimes[P][K] then
          if CanPlaceObject(TilesRoadX[P][K], TilesRoadY[P][K]) then
            Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], TilesRoadObjects[P][K]);
      end;
    end;
end;


procedure CheckTileFieldObjects(P: Integer);
var
  aRelief, C: Integer;
begin
  for K := 0 to TilesFieldLength[P] - 1 do
  begin
    if (TilesFieldX[P][K] > 0)
    and (TilesFieldY[P][K] > 0) then
      if TileOnBattlefield(TilesFieldX[P][K], TilesFieldY[P][K])
      and (TilesFieldObjects[P][K] <> SKILL_CANCEL_OBJ) then
      begin

        if (InRange(States.GameTime, SetTilesFieldTimes[P][K], ClearTilesFieldTimes[P][K] - 1))
        and (TilesFieldObjects[P][K] = BOWMAN_OBJECT5) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], BOWMAN_OBJECT5);

        if (InRange(States.GameTime, ClearTilesFieldTimes[P][K], 1 + ClearTilesFieldTimes[P][K]))
        and (TilesFieldObjects[P][K] = BOWMAN_OBJECT5) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], 255);

        if (InRange(States.GameTime, SetTilesFieldTimes[P][K], ClearTilesFieldTimes[P][K] - 1))
        and (TilesFieldObjects[P][K] = BARB_OBJECT3) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], BARB_OBJECT3);

        if (InRange(States.GameTime, SetTilesFieldTimes[P][K], ClearTilesFieldTimes[P][K] - 1))
        and (TilesFieldObjects[P][K] = KNIGHT_OBJECT4) then
        begin
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], KNIGHT_OBJECT4);
          Tiles[TilesFieldX[P][K]][TilesFieldY[P][K]].Skill := sRagingSpurt;
          Tiles[TilesFieldX[P][K]][TilesFieldY[P][K]].Owner := P;
        end;

        if (InRange(States.GameTime, SetTilesFieldTimes[P][K], ClearTilesFieldTimes[P][K] - 1))
        and (TilesFieldObjects[P][K] = CIRCLE_FILL_OBJ) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], CIRCLE_FILL_OBJ);

        if (InRange(States.GameTime, SetTilesFieldTimes[P][K], ClearTilesFieldTimes[P][K] - 1))
        and (TilesFieldObjects[P][K] = WARRIOR_OBJECT5) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], WARRIOR_OBJECT5);

        if States.GameTime = ClearTilesFieldTimes[P][K] + CLEAR_ARRAY_FACTOR - 1 then
          Tiles[TilesFieldX[P][K]][TilesFieldY[P][K]].Skill := sNone;

        if (InRange(States.GameTime, ClearTilesFieldTimes[P][K], 2 + ClearTilesFieldTimes[P][K]))
        and (States.MapTileObject(TilesFieldX[P][K], TilesFieldY[P][K]) <> 255) then
        begin
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], 255);

          if P = 8 then
            if TileOnBattlefield(TilesFieldX[8][K], TilesFieldY[8][K]) then
              Actions.MapTileHeightSet(TilesFieldX[8][K], TilesFieldY[8][K], Tiles[TilesFieldX[8][K]][TilesFieldY[8][K]].Relief);
        end;

        if States.GameTime = SetTilesFieldTimes[P][K] then
        begin
          if CanPlaceObject(TilesFieldX[P][K], TilesFieldY[P][K]) then
            Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], TilesFieldObjects[P][K]);
          if (P = 8)
          and (CHANGE_RELIEF) then
            for C := 0 to 1 + States.KaMRandomI(3) do 
            begin
              aRelief := States.MapTileHeight(TilesFieldX[8][K], TilesFieldY[8][K]) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
              if aRelief < 0 then
                aRelief := -1 * aRelief;
              if TileOnBattlefield(TilesFieldX[8][K], TilesFieldY[8][K]) then
                Actions.MapTileHeightSet(TilesFieldX[8][K], TilesFieldY[8][K], aRelief);
            end;
        end;
      end;
    end;
end;


procedure CheckTileWineObjects(P: Integer);
begin
  for K := 0 to TilesWineLength[P] - 1 do
  begin
    if (TilesWineX[P][K] > 0)
    and (TilesWineY[P][K] > 0) then
      if TileOnBattlefield(TilesWineX[P][K], TilesWineY[P][K])
      and (TilesWineObjects[P][K] <> SKILL_CANCEL_OBJ) then
      begin

        if (InRange(States.GameTime, SetTilesWineTimes[P][K], ClearTilesWineTimes[P][K] - 1))
        and (TilesWineObjects[P][K] = BOWMAN_OBJECT5) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], BOWMAN_OBJECT5);

        if (InRange(States.GameTime, ClearTilesWineTimes[P][K], 1 + ClearTilesWineTimes[P][K]))
        and (TilesWineObjects[P][K] = BOWMAN_OBJECT5) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], 255);

        if (InRange(States.GameTime, SetTilesWineTimes[P][K], ClearTilesWineTimes[P][K] - 1))
        and (TilesWineObjects[P][K] = BARB_OBJECT3) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], BARB_OBJECT3);

        if (InRange(States.GameTime, SetTilesWineTimes[P][K], ClearTilesWineTimes[P][K] - 1))
        and (TilesWineObjects[P][K] = KNIGHT_OBJECT4) then
        begin
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], KNIGHT_OBJECT4);
          Tiles[TilesWineX[P][K]][TilesWineY[P][K]].Skill := sRagingSpurt;
          Tiles[TilesWineX[P][K]][TilesWineY[P][K]].Owner := P;
        end;

        if (InRange(States.GameTime, SetTilesWineTimes[P][K], ClearTilesWineTimes[P][K] - 1))
        and (TilesWineObjects[P][K] = CIRCLE_FILL_OBJ) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], CIRCLE_FILL_OBJ);

        if (InRange(States.GameTime, SetTilesWineTimes[P][K], ClearTilesWineTimes[P][K] - 1))
        and (TilesWineObjects[P][K] = WARRIOR_OBJECT5) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], WARRIOR_OBJECT5);

        if (InRange(States.GameTime, ClearTilesWineTimes[P][K], CLEAR_ARRAY_FACTOR - 1 + ClearTilesWineTimes[P][K]))
        and (States.MapTileObject(TilesWineX[P][K], TilesWineY[P][K]) <> 255) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], 255);

        if States.GameTime = SetTilesWineTimes[P][K] then
          if CanPlaceObject(TilesWineX[P][K], TilesWineY[P][K]) then
            Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], TilesWineObjects[P][K]);

        if States.GameTime = ClearTilesWineTimes[P][K] + CLEAR_ARRAY_FACTOR - 1 then
          Tiles[TilesWineX[P][K]][TilesWineY[P][K]].Skill := sNone;

      end;
    end;
end;


procedure ClearArrays;
begin

  for I := 0 to 11 do
  begin

    if States.GameTime = ClearRoadTilesArrayTime[I] then
    begin
      TilesRoadLength[I] := 1;
      SetLength(TilesRoadX[I], TilesRoadLength[I]);
      SetLength(TilesRoadY[I], TilesRoadLength[I]);
      SetLength(ClearTilesRoadTimes[I], TilesRoadLength[I]);
      SetLength(SetTilesRoadTimes[I], TilesRoadLength[I]);
      SetLength(TilesRoadObjects[I], TilesRoadLength[I]);
    end;

    if States.GameTime = ClearFieldTilesArrayTime[I] then
    begin
      TilesFieldLength[I] := 1;
      SetLength(TilesFieldX[I], TilesFieldLength[I]);
      SetLength(TilesFieldY[I], TilesFieldLength[I]);
      SetLength(ClearTilesFieldTimes[I], TilesFieldLength[I]);
      SetLength(SetTilesFieldTimes[I], TilesFieldLength[I]);
      SetLength(TilesFieldObjects[I], TilesFieldLength[I]);
    end;

    if States.GameTime = ClearWineTilesArrayTime[I] then
    begin
      TilesWineLength[I] := 1;
      SetLength(TilesWineX[I], TilesWineLength[I]);
      SetLength(TilesWineY[I], TilesWineLength[I]);
      SetLength(ClearTilesWineTimes[I], TilesWineLength[I]);
      SetLength(SetTilesWineTimes[I], TilesWineLength[I]);
      SetLength(TilesWineObjects[I], TilesWineLength[I]);
    end;

    if States.GameTime = TimeToClearGravityArray[I] then
    begin
      GravityCirclesLength[I] := 0;
      SetLength(GravityCircles[I], 0);
    end;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin

      if States.GameTime = TimeToClearConcentrationArray[I][K] then
      begin
        ConcentrationCirclesLength[I][K] := 0;
        SetLength(ConcentrationCircles[I][K], 0);
      end;

      if States.GameTime = TimeToClearRageArray[I][K] then
      begin
        RageCirclesLength[I][K] := 0;
        SetLength(RageCircles[I][K], 0);
      end;

      if States.GameTime = TimeToClearTotemArray[I][K] then
      begin
        TotemCirclesLength[I][K] := 0;
        SetLength(TotemCircles[I][K], 0);
      end;

      if States.GameTime = TimeToClearViseArray[I][K] then
      begin
        ViseCirclesLength[I][K] := 0;
        SetLength(ViseCircles[I][K], 0);
      end;

      if States.GameTime = TimeToClearExpArray[I][K] then
      begin
        ExpCirclesLength[I][K] := 0;
        SetLength(ExpCircles[I][K], 0);
      end;

      if States.GameTime = TimeToClearFireworks1Array[I][K] then
      begin
        FireworksCircles1Length[I][K] := 0;
        SetLength(FireworksCircles1[I][K], 0);
      end;

      if States.GameTime = TimeToClearFireworks2Array[I][K] then
      begin
        FireworksCircles2Length[I][K] := 0;
        SetLength(FireworksCircles2[I][K], 0);
      end;

      if States.GameTime = TimeToClearFireworks3Array[I][K] then
      begin
        FireworksCircles3Length[I][K] := 0;
        SetLength(FireworksCircles3[I][K], 0);
      end;

      if States.GameTime = TimeToClearFireworks4Array[I][K] then
      begin
        FireworksCircles4Length[I][K] := 0;
        SetLength(FireworksCircles4[I][K], 0);
      end;

      if States.GameTime = TimeToClearFireworks5Array[I][K] then
      begin
        FireworksCircles5Length[I][K] := 0;
        SetLength(FireworksCircles5[I][K], 0);
      end;

      if States.GameTime = TimeToClearRogueArray[I][K] then
      begin
        RogueCirclesLength[I][K] := 0;
        SetLength(RogueCircles[I][K], 0);
      end;

      if States.GameTime = TimeToClearStolenRogueArray[I][K] then
      begin
        StolenRogueCirclesLength[I][K] := 0;
        SetLength(StolenRogueCircles[I][K], 0);
      end;

      if States.GameTime = TimeToClearPowerWithinArray[I][K] then
      begin
        PowerWithinCirclesLength[I][K] := 0;
        SetLength(PowerWithinCircles[I][K], 0);
      end;

    end;

  end;

end;


procedure CheckEffects(P: Integer);
var
  aX, aY, aU, X, Y, Tile: Integer;
begin
  aU := Players[P].Hero;
  if aU <= 0 then
    Exit;
  if Players[P].HP <= 0 then
    Exit;
  aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
  aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

  if not TileOnBattlefield(aX, aY) then
    Exit;

  for X := aX - 2 to aX + 2 do
  for Y := aY - 2 to aY + 2 do
    if TileOnBattlefield(X, Y) then
    begin
      Tile := States.MapTileType(X, Y);
      if (Tile = IMMORTAL_ANIMATION)
      or (Tile = DOUBLE_ANIMATION)
      or (Tile = RECHARGE_ANIMATION)
      or (Tile = MIND_ANIMATION)
      or (Tile = STUN_ANIMATION)
      or (Tile = FEAR_ANIMATION)
      or (Tile = SILENCE_ANIMATION) then
        Actions.MapTileSet(X, Y, Tiles[X][Y].TileType, Tiles[X][Y].TileDirection);
    end;

  if States.MapTileType(aX, aY) = Tiles[aX][aY].TileType then
  begin
    if Players[P].HeroImmortal then
      Actions.MapTileSet(aX, aY, IMMORTAL_ANIMATION, States.KaMRandomI(4));
    if Players[P].DD then
      Actions.MapTileSet(aX, aY, DOUBLE_ANIMATION, States.KaMRandomI(4));
    if Players[P].ReCharge then
      Actions.MapTileSet(aX, aY, RECHARGE_ANIMATION, States.KaMRandomI(4));
    if Players[P].HeroStunned then
      Actions.MapTileSet(aX, aY, STUN_ANIMATION, States.KaMRandomI(4));
    if Players[P].HeroInFear then
      Actions.MapTileSet(aX, aY, FEAR_ANIMATION, States.KaMRandomI(4));
    if Players[P].HeroSilent then
      Actions.MapTileSet(aX, aY, SILENCE_ANIMATION, States.KaMRandomI(4));
    if Players[P].MindStunned then
      Actions.MapTileSet(aX, aY, MIND_ANIMATION, States.KaMRandomI(4));
  end;

end;


procedure ClearDefence(P: Integer);
var
  aX, aY: Integer;
begin
  for aX := MIN_X to MAX_X do
  for aY := MIN_Y to MAX_Y do
    if States.MapTileObject(aX, aY) = ShieldObjects[P] then
      Actions.MapTileObjectSet(aX, aY, 255);
end;


procedure ClearPikeObj(P: Integer);
var
  aX, aY: Integer;
begin
  for aX := MIN_X to MAX_X do
  for aY := MIN_Y to MAX_Y do
    if States.MapTileObject(aX, aY) = PikeObjects[P] then
      Actions.MapTileObjectSet(aX, aY, 255);
end;


function ObjectIsTree(aX, aY: Integer): Boolean;
begin
  if TileOnBattlefield(aX, aY) then
    Result := ((States.MapTileObject(aX, aY) = 157)
    or (States.MapTileObject(aX, aY) = 158)
    or (States.MapTileObject(aX, aY) = 159)
    or (States.MapTileObject(aX, aY) = 160)
    or (States.MapTileObject(aX, aY) = 172));
end;


function TileHasTreesAround(aX, aY: Integer): Boolean;
begin
  if TileOnBattlefield(aX, aY) then
    Result := ((ObjectIsTree(aX + 1, aY))
    or (ObjectIsTree(aX + 1, aY + 1))
    or (ObjectIsTree(aX + 1, aY - 1))
    or (ObjectIsTree(aX - 1, aY - 1))
    or (ObjectIsTree(aX - 1, aY))
    or (ObjectIsTree(aX - 1, aY + 1))
    or (ObjectIsTree(aX, aY + 1))
    or (ObjectIsTree(aX, aY - 1)));
end;


procedure PlantTrees;
var
 aX, aY: Integer;
begin
  aX := States.KaMRandomI(46) + 13;
  aY := States.KaMRandomI(46) + 52;
  if (CanUseWineFieldSkill(aX, aY))
  and ((aX <> RUNE_X) and (aY <> RUNE_Y1))
  and ((aX <> RUNE_X) and (aY <> RUNE_Y2))
  and (not TileHasTreesAround(aX, aY))
  and (States.MapTileObject(aX, aY) <> BARB_OBJECT3)
  and (States.MapTileObject(aX, aY) <> BOWMAN_OBJECT5)
  and (States.MapTileObject(aX, aY) <> BOWMAN_ROCKET) then
    if (States.KaMRandom < PLANT_TREES_FACTOR)
    and (States.MapTileObject(aX, aY) = 255) then
    begin
      Actions.MapTileObjectSet(aX, aY, 157);
      Tiles[aX][aY].TreeTime := States.GameTime;
    end;

  for aX := MIN_X to MAX_X do
  for aY := MIN_Y to MAX_Y do
    if States.GameTime mod aX * TREES_GROW_FACTOR = 0 then
    begin

      if (States.MapTileObject(aX, aY) = 157)
      and (States.GameTime >= Tiles[aX][aY].TreeTime + TREE_AGE1) then
        Actions.MapTileObjectSet(aX, aY, 158);

      if (States.MapTileObject(aX, aY) = 158)
      and (States.GameTime >= Tiles[aX][aY].TreeTime + TREE_AGE2) then
        Actions.MapTileObjectSet(aX, aY, 159);

      if (States.MapTileObject(aX, aY) = 159)
      and (States.GameTime >= Tiles[aX][aY].TreeTime + TREE_AGE3) then
        Actions.MapTileObjectSet(aX, aY, 160);

      if (States.MapTileObject(aX, aY) = 160)
      and (States.GameTime >= Tiles[aX][aY].TreeTime + TREE_AGE4)
      and (States.KaMRandom < PLANT_TREES_FACTOR/2) then
        Actions.MapTileObjectSet(aX, aY, 172);

  end;

end;


procedure CheckRespawn(P: Integer);
begin
  if (States.PlayerEnabled(P))
  and (States.GameTime >= Players[P].RespawnCheckTime)
  and (Players[P].RespawnCheckTime > 0)
  and (States.GameTime > CHOOSE_HERO_TIMER)
  and (Players[P].HP > 0)
  and (Players[P].Hero = -1) then
  begin
    Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].SpawnX, Players[P].SpawnY, Players[P].Direction, 1, 1);
    Players[P].HeroImmortal := True;
    Players[P].HeroImmortalTime := States.GameTime + IMMORTAL_TIME;
    Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
    Actions.CinematicStart(P);
    Actions.CinematicPanTo(P, Players[P].SpawnX, Players[P].SpawnY, 0);
    Actions.CinematicEnd(P);
    Exit;
  end;
end;


function GroupIsMoving(G: Integer): Boolean;
var
  O: Integer;
begin
  if G <= 0 then
    Exit;
  if States.GroupMember(G, 0) <= 0 then
    Exit;

  O := States.GroupOwner(G);

  if States.GameTime mod MOVEMENT_FACTOR = 0 then
  begin
    NewX[O] := States.UnitPositionX(States.GroupMember(G, 0));
    NewY[O] := States.UnitPositionY(States.GroupMember(G, 0));
  end;

  if States.GameTime mod MOVEMENT_FACTOR = 0 then
  begin
    OldX[O] := States.UnitPositionX(States.GroupMember(G, 0));
    OldY[O] := States.UnitPositionY(States.GroupMember(G, 0));
  end;

  Result := (OldX[O] div MOVEMENT_DISTANCE <> NewX[O] div MOVEMENT_DISTANCE) or (OldY[O] div MOVEMENT_DISTANCE <> NewY[O] div MOVEMENT_DISTANCE);

end;


//AI


procedure RespawnUnit(P: Integer);
begin
  if (States.PlayerEnabled(P))
  and (Players[P].HP > 0)
  and (States.PlayerIsAI(P)) then
  begin
    Actions.GroupKillAll(Players[P].Hero, True);
    Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].SkillCastX, Players[P].SkillCastY, Players[P].SkillCastDir, 1, 1);
    Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
    if (Players[P].HeroStunned)
    or (Players[P].HeroInFear) then
      Actions.GroupBlockOrders(Players[P].Hero, True);
   end;
end;


procedure AvoidDanger(P: Integer);
var
  aX, aY, D: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if not States.PlayerIsAI(I) then
    Exit;

  if (InRange(P, 0, 7))
  and (Players[P].Hero > 0) then
  begin

    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    D := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

    if not Players[P].CastingSkill then
    begin
      case D of

        0: if (TileIsDangerous(P, aX, aY - 2))
           or (TileIsDangerous(P, aX, aY - 1)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(5) - States.KaMRandomI(5), aY + States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        1: if (TileIsDangerous(P, aX + 1, aY - 2))
           or (TileIsDangerous(P, aX + 1, aY - 1))
           or (TileIsDangerous(P, aX + 2, aY - 2))
           or (TileIsDangerous(P, aX + 2, aY - 1)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(5) - States.KaMRandomI(5), aY + States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        2: if (TileIsDangerous(P, aX + 1, aY))
           or (TileIsDangerous(P, aX + 2, aY)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX - States.KaMRandomI(5), aY + States.KaMRandomI(5) - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        3: if (TileIsDangerous(P, aX + 1, aY + 2))
           or (TileIsDangerous(P, aX + 1, aY + 1))
           or (TileIsDangerous(P, aX + 2, aY + 2))
           or (TileIsDangerous(P, aX + 2, aY + 1)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX - States.KaMRandomI(5), aY - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        4: if (TileIsDangerous(P, aX, aY + 2))
           or (TileIsDangerous(P, aX, aY + 1)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(5) - States.KaMRandomI(5), aY - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        5: if (TileIsDangerous(P, aX - 1, aY + 2))
           or (TileIsDangerous(P, aX - 1, aY + 1))
           or (TileIsDangerous(P, aX - 2, aY + 2))
           or (TileIsDangerous(P, aX - 2, aY + 1)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(5), aY - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        6: if (TileIsDangerous(P, aX - 2, aY))
           or (TileIsDangerous(P, aX - 1, aY)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(5), aY + States.KaMRandomI(5) - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        7: if (TileIsDangerous(P, aX - 1, aY - 2))
           or (TileIsDangerous(P, aX - 1, aY - 1))
           or (TileIsDangerous(P, aX - 2, aY - 2))
           or (TileIsDangerous(P, aX - 2, aY - 1)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX - States.KaMRandomI(5), aY - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

      end;

    end;

  end;

end;


procedure AITakeRune(P: Integer);
begin
  if (Players[P].Hero <= 0)
  or (Players[P].CastingSkill)
  or (States.MapTileObject(RUNE_X, RUNE_Y) = 255) then
    Exit;
  if (States.MapTileObject(RUNE_X, RUNE_Y) <> RUNE_REGEN_OBJ)
  or ((Players[P].HP < MAX_HP)
  and (States.MapTileObject(RUNE_X, RUNE_Y) = RUNE_REGEN_OBJ)) then
  begin
    Actions.GroupOrderWalk(Players[P].Hero, RUNE_X, RUNE_Y, States.KaMRandomI(8));
    if (States.KaMRandom < 0.75) then
    begin
      if Players[P].RoadSkillDelay <= 5 then
        Players[P].RoadSkillDelay := Players[P].RoadSkillDelay + States.KaMRandomI(100);
      if Players[P].FieldSkillDelay = 0 then
        Players[P].FieldSkillDelay := Players[P].FieldSkillDelay + States.KaMRandomI(100);
      if Players[P].WineSkillDelay = 0 then
        Players[P].WineSkillDelay := Players[P].WineSkillDelay + States.KaMRandomI(100);
    end;
  end;
end;


procedure AIWalk(P: Integer);
begin

  if States.GameTime mod 80 = 0 then
    if (Players[P].Hero > 0)
    and (not Players[P].CastingSkill) then
      Actions.GroupOrderWalk(Players[P].Hero, States.KaMRandomI(47) + 12, States.KaMRandomI(47) + 51, States.KaMRandomI(8));

end;


procedure AIWalkAfterSkill(P: Integer);
begin

  if Players[P].Hero > 0 then
    if States.GameTime = Players[P].SkillTime then
      Actions.GroupOrderWalk(Players[P].Hero, States.KaMRandomI(47) + 12, States.KaMRandomI(47) + 51, States.KaMRandomI(8));

end;


procedure AIWalkIdle(P: Integer);
begin

  if Players[P].Hero > 0 then
    if (States.GroupIdle(Players[P].Hero))
    and (not Players[P].CastingSkill)
    and (Players[P].HeroType <> 15)
    and (States.PlayerIsAI(P)) then
      Actions.GroupOrderWalk(Players[P].Hero, States.KaMRandomI(47) + 12, States.KaMRandomI(47) + 51, States.KaMRandomI(8));

end;


procedure AITakeHealingBush(P: Integer);
var
  X, Y, aX, aY: Integer;
begin
  if (Players[P].Hero <= 0)
  or (Players[P].CastingSkill)
  or (Players[P].HP = 12)
  or (Players[P].RegenDelay - States.GameTime > 0) then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
  aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

  for X := aX - HEAL_CHECK_RADIUS to aX + HEAL_CHECK_RADIUS do
  for Y := aY - HEAL_CHECK_RADIUS to aY + HEAL_CHECK_RADIUS do
    if TileOnBattlefield(X, Y) then
      if States.MapTileObject(X, Y) = VAGA_OBJECT then
        Actions.GroupOrderWalk(Players[P].Hero, X, Y, States.KaMRandomI(8));
end;


procedure ZombieStormLeft;
var
  GR: array of Integer;
  X1, X2, Y1, Y2, D1, D2, H, Z, DX, DY: Integer;
begin
  GR := States.PlayerGetAllGroups(11);
  if Length(PlayersLeft) > 0 then
    for I := 0 to Length(PlayersLeft) - 1 do
    begin
      H := Players[PlayersLeft[I]].Hero;
      if H > 0 then
      begin
        X1 := States.UnitPositionX(States.GroupMember(Players[PlayersLeft[I]].Hero, 0));
        Y1 := States.UnitPositionY(States.GroupMember(Players[PlayersLeft[I]].Hero, 0));
        D1 := States.UnitDirection(States.GroupMember(Players[PlayersLeft[I]].Hero, 0));
      end;
      if Length(GR) > 0 then
        for K := 0 to Length(GR) - 1 do
        begin
          Z := GR[K];
          if Z > 0 then
          begin
            X2 := States.UnitPositionX(States.GroupMember(Z, 0));
            Y2 := States.UnitPositionY(States.GroupMember(Z, 0));
            D2 := States.UnitDirection(States.GroupMember(Z, 0));
            if States.GroupIdle(Z) then
              Actions.GroupOrderWalk(Z, 25, 75, States.KaMRandomI(8));
          end;
          DX := (X1 - X2) * (X1 - X2);
          DY := (Y1 - Y2) * (Y1 - Y2);
          if (DX + DY <= (STORM_CHECK_RADIUS * STORM_CHECK_RADIUS))
          and ((D1 = D2)
          or (Abs(D1 - D2) = 4))
          and (Z > 0) then
            if (States.GroupType(Z) = 0)
            and (States.KaMRandom < STORM_CHANCE) then
              Actions.GroupOrderStorm(Z);
        end;
     end;
end;


procedure ZombieStormRight;
var
  GL: array of Integer;
  X1, X2, Y1, Y2, D1, D2, H, Z, DX, DY: Integer;
begin
  GL := States.PlayerGetAllGroups(10);
  if Length(PlayersRight) > 0 then
    for I := 0 to Length(PlayersRight) - 1 do
    begin
      H := Players[PlayersRight[I]].Hero;
      if H > 0 then
      begin
        X1 := States.UnitPositionX(States.GroupMember(Players[PlayersRight[I]].Hero, 0));
        Y1 := States.UnitPositionY(States.GroupMember(Players[PlayersRight[I]].Hero, 0));
        D1 := States.UnitDirection(States.GroupMember(Players[PlayersRight[I]].Hero, 0));
      end;
      if Length(GL) > 0 then
        for K := 0 to Length(GL) - 1 do
        begin
          Z := GL[K];
          if Z > 0 then
          begin
            X2 := States.UnitPositionX(States.GroupMember(Z, 0));
            Y2 := States.UnitPositionY(States.GroupMember(Z, 0));
            D2 := States.UnitDirection(States.GroupMember(Z, 0));
            if States.GroupIdle(Z) then
              Actions.GroupOrderWalk(Z, 45, 75, States.KaMRandomI(8));
          end;
          DX := (X1 - X2) * (X1 - X2);
          DY := (Y1 - Y2) * (Y1 - Y2);
          if (DX + DY <= (STORM_CHECK_RADIUS * STORM_CHECK_RADIUS))
          and ((D1 = D2)
          or (Abs(D1 - D2) = 4))
          and (Z > 0) then
            if (States.GroupType(Z) = 0)
            and (States.KaMRandom < STORM_CHANCE) then
              Actions.GroupOrderStorm(Z);
        end;
     end;
end;


function AICanUseSkills(P, UT: Integer): Boolean;
begin
  Result := False;
  if not InRange(UT, 15, 27) then
    Exit;
  if Players[P].Hero <= 0 then
    Exit;
  if States.PlayerEnabled(P) then
    if States.PlayerIsAI(P) then
      if Players[P].Hero > 0 then
        Result := ((Players[P].HeroType = UT)
        and (Players[P].HP > 0)
        and (TileOnBattlefield(States.UnitPositionX(States.GroupMember(Players[P].Hero, 0)), States.UnitPositionY(States.GroupMember(Players[P].Hero, 0))))
        and (not Players[P].HeroInFear)
        and (not Players[P].HeroStunned)
        and (not Players[P].HeroSilent));
end;


function CanUseSkillAgainstUnit(P, U: Integer): Boolean;
begin
  Result := True;
  if InRange(States.UnitOwner(U), 0, 7) then
    Result := not Players[States.UnitOwner(U)].HeroImmortal;  
end;


procedure AISword(P: Integer);
var
  X, Y, aX, aY, uX, uY, O, U: Integer;
begin

  if (States.KaMRandomI(10) > 5)
  and (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    for X := (aX - 7) to (aX + 7) do
    for Y := (aY - 7) to (aY + 7) do
    begin
      U := States.UnitAt(X, Y);
      if U > 0 then
      begin
        O := States.UnitOwner(U);
        if (P <> O)
        and (InRange(O, 0, 7))
        and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
        and (States.KaMRandom > 0.1) then 
        begin
          uX := States.UnitPositionX(U);
          uY := States.UnitPositionY(U);
          if ((uX = aX) and (uY < (aY - 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
          begin
            SpikedEarth(P, aX, aY, 0);
            Exit;
          end;
          if ((uX = aX) and (uY > (aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
          begin
            SpikedEarth(P, aX, aY, 4);
            Exit;
          end;
          if ((uX < (aX - 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
          begin
            SpikedEarth(P, aX, aY, 6);
            Exit;
          end;
          if ((uX > (aX + 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
          begin
            SpikedEarth(P, aX, aY, 2);
            Exit;
          end;
        end;
      end;
    end;
  end;

  if (States.KaMRandomI(10) > 5)
  and (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    ZombieSummon(P, aX + States.KaMRandomI(5) - States.KaMRandomI(5), aY + States.KaMRandomI(5) - States.KaMRandomI(5));
  end;

  if (Players[I].WineSkillDelay = 0)
  and (Players[P].Hero > 0) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    O := States.KaMRandomI(8);
    if (Players[O].Hero > 0) then
      if (Abs(aX - States.UnitPositionX(States.GroupMember(Players[O].Hero, 0))) <= IN_FEAR_RADIUS)
      and (Abs(aY - States.UnitPositionY(States.GroupMember(Players[O].Hero, 0))) <= IN_FEAR_RADIUS)
      and (CanUseWineFieldSkill(X, Y))
      and (P <> O)
      and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
      and (not Players[O].HeroInFear) then
      begin
        Players[O].HeroInFear := True;
        Players[O].HeroInFearTime := States.GameTime + IN_FEAR_TIME;
      end;
  end;

  AIWalk(P);

  if States.GameTime mod AI_RUNE_CHECK_TIME = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AIBarb(P: Integer);
var
  aX, aY, O, U, X, Y, uX, uY, A, E, sX, sY: Integer;
begin

  if (States.KaMRandomI(10) > 5)
  and (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - 7) to (aX + 7) do
      for Y := (aY - 7) to (aY + 7) do
      begin
        U := States.UnitAt(X, Y);
        if U > 0 then
        begin
          O := States.UnitOwner(U);
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1) then 
          begin
            uX := States.UnitPositionX(U);
            uY := States.UnitPositionY(U);
            if ((uX = aX) and (uY < (aY - 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              CrackingEarth(P, aX, aY, 0);
              Exit;
            end;
            if ((uX = aX) and (uY > (aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              CrackingEarth(P, aX, aY, 4);
              Exit;
            end;
            if ((uX < (aX - 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              CrackingEarth(P, aX, aY, 6);
              Exit;
            end;
            if ((uX > (aX + 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              CrackingEarth(P, aX, aY, 2);
              Exit;
            end;
          end;
        end;
      end;
    end;

  if (States.KaMRandomI(10) > 5)
  and (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      A := 0;
      E := 0;
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - RAGE_RADIUS + 1) to (aX + RAGE_RADIUS - 1) do
      for Y := (aY - RAGE_RADIUS + 1) to (aY + RAGE_RADIUS - 1) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0)
        and (not InRange(X, aX - 1, aX + 1))
        and (not InRange(Y, aY - 1, aY + 1)) then
        begin
          O := States.UnitOwner(U);
          if Players[P].PlayersTeam <> Players[O].PlayersTeam then
            E := E + 1;
          if Players[P].PlayersTeam = Players[O].PlayersTeam then
            A := A + 1;
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1)
          and (E > A) then 
          begin
            WaveOfRage(P, aX, aY);
            Exit;
          end;
        end;
      end;
    end;

  if (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      A := 0;
      E := 0;
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - TOTEM_ADD_RADIUS) to (aX + TOTEM_ADD_RADIUS) do
      for Y := (aY - TOTEM_ADD_RADIUS) to (aY + TOTEM_ADD_RADIUS) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0) then
        begin

          sX := X;
          sY := Y;

          if GroupIsMoving(States.UnitsGroup(U)) then
          begin
            case States.UnitDirection(U) of
              0: begin
                   sX := X;
                   sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              1: begin
                   sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              2: begin
                   sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y;
                 end;

              3: begin
                   sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              4: begin
                   sX := X;
                   sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              5: begin
                   sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              6: begin
                   sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y;
                 end;

              7: begin
                   sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

            end;
          end;

          if (not InRange(sX, aX - TOTEM_RADIUS, aX + TOTEM_RADIUS))
          and (not InRange(sY, aY - TOTEM_RADIUS, aY + TOTEM_RADIUS))
          and (CanUseWineFieldSkill(sX, sY)) then
          begin
            O := States.UnitOwner(U);
            if Players[P].PlayersTeam <> Players[O].PlayersTeam then
              E := E + 1;
            if Players[P].PlayersTeam = Players[O].PlayersTeam then
              A := A + 1;
            if (P <> O)
            and (CanUseSkillAgainstUnit(P, U))
            and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
            and (States.KaMRandom > 0.1)
            and (E > A) then 
            begin
              TotemOfAncestors(P, sX, sY);
              Exit;
            end;
          end;
        end;
      end;
    end;

  AIWalk(P);

  if States.GameTime mod AI_RUNE_CHECK_TIME = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AICrossbow(P: Integer);
var
  aX, aY, O, U, X, Y, uX, uY, aX1, aX2, aY1, aY2, sX, sY: Integer;
begin

  if (States.KaMRandomI(10) > 5)
  and (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0)
  and not (Players[P].CastingSkill) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - 10) to (aX + 10) do
      for Y := (aY - 10) to (aY + 10) do
      begin
        U := States.UnitAt(X, Y);
        if U > 0 then
        begin
          O := States.UnitOwner(U);
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1) then 
          begin
            uX := States.UnitPositionX(U);
            uY := States.UnitPositionY(U);
            if ((uX = aX) and (uY < (aY - 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              AccurateShot(P, aX, aY, 0);
              Exit;
            end;
            if ((uX = aX) and (uY > (aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              AccurateShot(P, aX, aY, 4);
              Exit;
            end;
            if ((uX < (aX - 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              AccurateShot(P, aX, aY, 6);
              Exit;
            end;
            if ((uX > (aX + 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              AccurateShot(P, aX, aY, 2);
              Exit;
            end;
          end;
        end;
      end;
    end;

  if (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - BOMB_RADIUS) to (aX + BOMB_RADIUS) do
      for Y := (aY - BOMB_RADIUS) to (aY + BOMB_RADIUS) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0) then
        begin

          sX := X;
          sY := Y;

          if GroupIsMoving(States.UnitsGroup(U)) then
          begin
            case States.UnitDirection(U) of

              0: begin
                   sX := X;
                   sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              1: begin
                   sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              2: begin
                   sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y;
                 end;

              3: begin
                   sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              4: begin
                   sX := X;
                   sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              5: begin
                   sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              6: begin
                   sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y;
                 end;

              7: begin
                   sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

            end;
          end;

          if (CanUseSkillAgainstUnit(P, U))
          and (not InRange(sX, aX - 3, aX + 3))
          and (not InRange(sY, aY - 3, aY + 3))
          and (CanUseWineFieldSkill(X, Y)) then
          begin
            O := States.UnitOwner(U);
            if (P <> O)
            and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
            and (States.KaMRandom > 0.1) then 
            begin
              SuddenDeath(P, sX, sY);
              Exit;
            end;
          end;
        end;
      end;
    end;

  if (States.KaMRandomI(10) > 7)
  and (States.KaMRandom < 0.25)
  and (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (States.GameTime > CHOOSE_HERO_TIMER + 100)
  and not (Players[P].CastingSkill) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

      case States.UnitDirection(States.GroupMember(Players[P].Hero, 0)) of

        0, 1: begin
                aX1 := aX;
                aX2 := aX;
                aY1 := MIN_Y;
                aY2 := aY - 1;
              end;

        4, 5: begin
                aX1 := aX;
                aX2 := aX;
                aY1 := aY + 1;
                aY2 := MAX_Y;
              end;

        2, 3: begin
                aX1 := aX + 1;
                aX2 := MAX_X;
                aY1 := aY;
                aY2 := aY;
              end;

        6, 7: begin
                aX1 := MIN_X;
                aX2 := aX - 1;
                aY1 := aY;
                aY2 := aY;
              end;

      end;

      for X := aX1 to aX2 do
      for Y := aY1 to aY2 do
      begin
        if TileOnBattlefield(X, Y) then
          U := States.UnitAt(X, Y);
        if U > 0 then
        begin
          O := States.UnitOwner(U);
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1) then 
          begin
            uX := States.UnitPositionX(U);
            uY := States.UnitPositionY(U);
            if ((uX = aX) and (uY < (aY - 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 1))) then
            begin
              SniperShot(P, aX, aY, 0);
              Exit;
            end;
            if ((uX = aX) and (uY > (aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 4, 5))) then
            begin
              SniperShot(P, aX, aY, 4);
              Exit;
            end;
            if ((uX < (aX - 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 6, 7))) then
            begin
              SniperShot(P, aX, aY, 6);
              Exit;
            end;
            if ((uX > (aX + 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 2, 3))) then
            begin
              SniperShot(P, aX, aY, 2);
              Exit;
            end;
          end;
        end;
      end;
    end;

  AIWalk(P);

  if States.GameTime mod AI_RUNE_CHECK_TIME = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AIPikeman(P: Integer);
var
  X, Y, aX, aY, U, O, D, A, E: Integer;
begin

  if (States.KaMRandomI(10) > 5)
  and (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      A := 0;
      E := 0;
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      D := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - VISE_RADIUS + 1) to (aX + VISE_RADIUS - 1) do
      for Y := (aY - VISE_RADIUS + 1) to (aY + VISE_RADIUS - 1) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0) then
        begin
          O := States.UnitOwner(U);
          if Players[P].PlayersTeam <> Players[O].PlayersTeam then
            E := E + 1;
          if Players[P].PlayersTeam = Players[O].PlayersTeam then
            A := A + 1;
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1)
          and (E > A) then 
          begin
            ViseOfDeath(P, aX, aY, D);
            Exit;
          end;
        end;
      end;
    end;

  if (States.KaMRandomI(10) > 7)
  and (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      A := 0;
      E := 0;
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - CONCENTRATION_RADIUS + 1) to (aX + CONCENTRATION_RADIUS - 1) do
      for Y := (aY - CONCENTRATION_RADIUS + 1) to (aY + CONCENTRATION_RADIUS - 1) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0)
        and (not InRange(X, aX - 1, aX + 1))
        and (not InRange(Y, aY - 1, aY + 1)) then
        begin
          O := States.UnitOwner(U);
          if Players[P].PlayersTeam <> Players[O].PlayersTeam then
            E := E + 1;
          if Players[P].PlayersTeam = Players[O].PlayersTeam then
            A := A + 1;
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1)
          and (E > A) then 
          begin
            Concentration(P, aX, aY);
            Exit;
          end;
        end;
      end;
    end;

  AIWalk(P);

  if States.GameTime mod AI_RUNE_CHECK_TIME = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AILance(P: Integer);
var
  aX, aY, O, U, X, Y, uX, uY, aX1, aX2, aY1, aY2: Integer;
begin
  if (States.KaMRandomI(10) > 5)
  and (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0)
  and not (Players[P].CastingSkill) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - 8) to (aX + 8) do
      for Y := (aY - 8) to (aY + 8) do
      begin
        U := States.UnitAt(X, Y);
        if U > 0 then
        begin
          O := States.UnitOwner(U);
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1) then 
          begin
            uX := States.UnitPositionX(U);
            uY := States.UnitPositionY(U);
            if ((uX = aX) and (uY < (aY - 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              FieryLance(P, aX, aY, 0);
              Exit;
            end;
            if ((uX = aX) and (uY > (aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              FieryLance(P, aX, aY, 4);
              Exit;
            end;
            if ((uX < (aX - 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              FieryLance(P, aX, aY, 6);
              Exit;
            end;
            if ((uX > (aX + 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              FieryLance(P, aX, aY, 2);
              Exit;
            end;
          end;
        end;
      end;
    end;

  if (Players[P].FieldSkillDelay = 0)
  and (States.KaMRandomI(30 + P) > 4 + P)
  and (Players[P].Hero > 0)
  and not (Players[P].CastingSkill)
  and (States.GameTime > CHOOSE_HERO_TIMER + 50) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      X := aX + States.KaMRandomI(TELEPORT_RADIUS) - States.KaMRandomI(TELEPORT_RADIUS);
      Y := aY + States.KaMRandomI(TELEPORT_RADIUS) - States.KaMRandomI(TELEPORT_RADIUS);
      if (not TileIsDangerous(P, X, Y))
      and (Tiles[X][Y].Skill = sNone) then
      begin
        Teleport(P, X, Y);
        Actions.GroupOrderWalk(Players[P].Hero, States.KaMRandomI(47) + 12, States.KaMRandomI(47) + 51, States.KaMRandomI(8));
      end;
      Exit;
    end;

  if (States.KaMRandomI(10) > 7)
  and (States.KaMRandom < 0.25)
  and (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0)
  and not (Players[P].CastingSkill) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

      case States.UnitDirection(States.GroupMember(Players[P].Hero, 0)) of

        0, 1: begin
                aX1 := aX - 1;
                aX2 := aX + 1;
                aY1 := aY - 20;
                aY2 := aY - 1;
              end;

        4, 5: begin
                aX1 := aX - 1;
                aX2 := aX + 1;
                aY1 := aY + 1;
                aY2 := aY + 20;
              end;

        2, 3: begin
                aX1 := aX + 1;
                aX2 := aX + 20;
                aY1 := aY - 1;
                aY2 := aY + 1;
              end;

        6, 7: begin
                aX1 := aX - 20;
                aX2 := aX - 1;
                aY1 := aY - 1;
                aY2 := aY + 1;
              end;

      end;

      for X := aX1 to aX2 do
      for Y := aY1 to aY2 do
        if TileOnBattlefield(X, Y) then
        begin
          U := States.UnitAt(X, Y);
          if U > 0 then
          begin
            O := States.UnitOwner(U);
            if (P <> O)
            and (CanUseSkillAgainstUnit(P, U))
            and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
            and (States.KaMRandom > 0.1) then 
            begin
              uX := States.UnitPositionX(U);
              uY := States.UnitPositionY(U);
              if ((InRange(uX, aX - 1, aX + 1)) and (uY < aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 1))) then
              begin
                TenThousandsSpears(P, aX, aY, 0);
                Exit;
              end;
              if ((InRange(uX, aX - 1, aX + 1)) and (uY > aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 4, 5))) then
              begin
                TenThousandsSpears(P, aX, aY, 4);
                Exit;
              end;
              if ((uX < aX) and (InRange(uY, aY - 1, aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 6, 7))) then
              begin
                TenThousandsSpears(P, aX, aY, 6);
                Exit;
              end;
              if ((uX > aX) and (InRange(uY, aY - 1, aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 2, 3))) then
              begin
                TenThousandsSpears(P, aX, aY, 2);
                Exit;
              end;
            end;
        end;
      end;
    end;

  AIWalk(P);

  if States.GameTime mod AI_RUNE_CHECK_TIME = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AIWarrior(P: Integer);
var
  aX, aY, O, U, X, Y, uX, uY, aX1, aX2, aY1, aY2, E, A: Integer;
begin

  if (States.KaMRandomI(10) > 7)
  and (States.KaMRandom < 0.25)
  and (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0)
  and not (Players[P].CastingSkill) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

      case States.UnitDirection(States.GroupMember(Players[P].Hero, 0)) of

        0, 1: begin
                aX1 := aX - 1;
                aX2 := aX + 1;
                aY1 := aY - 10;
                aY2 := aY - 1;
              end;

        4, 5: begin
                aX1 := aX - 1;
                aX2 := aX + 1;
                aY1 := aY + 1;
                aY2 := aY + 10;
              end;

        2, 3: begin
                aX1 := aX + 1;
                aX2 := aX + 10;
                aY1 := aY - 1;
                aY2 := aY + 1;
              end;

        6, 7: begin
                aX1 := aX - 10;
                aX2 := aX - 1;
                aY1 := aY - 1;
                aY2 := aY + 1;
              end;

      end;

      for X := aX1 to aX2 do
      for Y := aY1 to aY2 do
        if TileOnBattlefield(X, Y) then
        begin
          U := States.UnitAt(X, Y);
          if U > 0 then
          begin
            O := States.UnitOwner(U);
            if (P <> O)
            and (CanUseSkillAgainstUnit(P, U))
            and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
            and (States.KaMRandom > 0.1) then 
            begin
              uX := States.UnitPositionX(U);
              uY := States.UnitPositionY(U);
              if ((InRange(uX, aX - 1, aX + 1)) and (uY < aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 1))) then
              begin
                FierySnake(P, aX, aY, 0);
                Exit;
              end;
              if ((InRange(uX, aX - 1, aX + 1)) and (uY > aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 4, 5))) then
              begin
                FierySnake(P, aX, aY, 4);
                Exit;
              end;
              if ((uX < aX) and (InRange(uY, aY - 1, aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 6, 7))) then
              begin
                FierySnake(P, aX, aY, 6);
                Exit;
              end;
              if ((uX > aX) and (InRange(uY, aY - 1, aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 2, 3))) then
              begin
                FierySnake(P, aX, aY, 2);
                Exit;
              end;
            end;
        end;
      end;
    end;

  if (States.KaMRandomI(10) > 8)
  and (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - ARMOR_RADIUS + 1) to (aX + ARMOR_RADIUS - 1) do
      for Y := (aY - ARMOR_RADIUS + 1) to (aY + ARMOR_RADIUS - 1) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0)
        and (CanUseWineFieldSkill(X, Y)) then
        begin
          O := States.UnitOwner(U);
          if (P <> -1)
          and (CanUseSkillAgainstUnit(P, U))
          and (not Players[O].HeroImmortal)
          and (Players[P].PlayersTeam = Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1) then 
          begin
            SturdyArmor(P, X, Y);
            Exit;
          end;
        end;
      end;
    end;

  {if (States.KaMRandomI(10) > 7)
  and (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - SILENCE_RADIUS + 1) to (aX + SILENCE_RADIUS - 1) do
      for Y := (aY - SILENCE_RADIUS + 1) to (aY + SILENCE_RADIUS - 1) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0)
        and (not InRange(X, aX - 1, aX + 1))
        and (not InRange(Y, aY - 1, aY + 1)) then
        begin
          O := States.UnitOwner(U);
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1) then 
          begin
            CircleOfSilence(P, aX, aY);
            Exit;
          end;
        end;
      end;
    end;}

  if (States.KaMRandomI(10) > 7)
  and (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      A := 0;
      E := 0;
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - POWER_RADIUS + 1) to (aX + POWER_RADIUS - 1) do
      for Y := (aY - POWER_RADIUS + 1) to (aY + POWER_RADIUS - 1) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0)
        and (not InRange(X, aX - 1, aX + 1))
        and (not InRange(Y, aY - 1, aY + 1)) then
        begin
          O := States.UnitOwner(U);
          if Players[P].PlayersTeam <> Players[O].PlayersTeam then
            E := E + 1;
          if Players[P].PlayersTeam = Players[O].PlayersTeam then
            A := A + 1;
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1)
          and (E > A) then 
          begin
            PowerWithin(P, aX, aY);
            Exit;
          end;
        end;
      end;
    end;

  AIWalk(P);

  if States.GameTime mod AI_RUNE_CHECK_TIME = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AIBowman(P: Integer);
var
  X, Y, aX, aY, aX1, aY1, aX2, aY2, uX, uY, U, O, sX, sY: Integer;
begin

  if (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (States.GameTime mod 50 = 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - 20) to (aX + 20) do
      for Y := (aY - 20) to (aY + 20) do
      begin
        if (TileOnBattlefield(X, Y))
        and (not States.IsRoadAt(8, X, Y)) then
          U := States.UnitAt(X, Y);
        if (U > 0) then
        begin

          sX := X;
          sY := Y;

          if GroupIsMoving(States.UnitsGroup(U)) then
          begin
            case States.UnitDirection(U) of

              0: begin
                   sX := X;
                   sY := Y - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              1: begin
                   sX := X + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              2: begin
                   sX := X + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y;
                 end;

              3: begin
                   sX := X + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              4: begin
                   sX := X;
                   sY := Y + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              5: begin
                   sX := X - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              6: begin
                   sX := X - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y;
                 end;

              7: begin
                   sX := X - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

            end;
          end;

          if CanUseSkillAgainstUnit(P, U) then
          begin
            O := States.UnitOwner(U);
            if (P <> O)
            and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
            and (States.KaMRandom > 0.1) then 
            begin
              LaunchRocket(P, sX, sY);
              Exit;
            end;
          end;
        end;
      end;
    end;

  if (States.KaMRandomI(10) > 8)
  and (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - PRISON_USAGE_RADIUS) to (aX + PRISON_USAGE_RADIUS) do
      for Y := (aY - PRISON_USAGE_RADIUS) to (aY + PRISON_USAGE_RADIUS) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0)
        and (CanUseWineFieldSkill(X, Y)) then
        begin
          O := States.UnitOwner(U);
          if (P <> O)
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (Abs(X - aX) > 3)
          and (Abs(Y - aY) > 3)
          and (States.KaMRandom > 0.1) then 
          begin
            Prison(P, X, Y);
            Exit;
          end;
        end;
      end;
    end;

  if (States.KaMRandomI(10) > 7)
  and (States.KaMRandom < 0.4)
  and (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (States.GameTime > CHOOSE_HERO_TIMER + 100)
  and not (Players[P].CastingSkill) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

      case States.UnitDirection(States.GroupMember(Players[P].Hero, 0)) of

        0, 1: begin
                aX1 := aX;
                aX2 := aX;
                aY1 := aY - 19;
                aY2 := aY - 1;
              end;

        4, 5: begin
                aX1 := aX;
                aX2 := aX;
                aY1 := aY + 1;
                aY2 := aY + 19;
              end;

        2, 3: begin
                aX1 := aX + 1;
                aX2 := aX + 19;
                aY1 := aY;
                aY2 := aY;
              end;

        6, 7: begin
                aX1 := aX - 19;
                aX2 := aX - 1;
                aY1 := aY;
                aY2 := aY;
              end;

      end;

      for X := aX1 to aX2 do
      for Y := aY1 to aY2 do
      begin
        if TileOnBattlefield(X, Y) then
          U := States.UnitAt(X, Y);
        if U > 0 then
        begin
          O := States.UnitOwner(U);
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1) then 
          begin
            uX := States.UnitPositionX(U);
            uY := States.UnitPositionY(U);
            if ((uX = aX) and (uY < (aY - 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 1))) then
            begin
              RevengeFromNowhere(P, aX, aY, 0);
              Exit;
            end;
            if ((uX = aX) and (uY > (aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 4, 5))) then
            begin
              RevengeFromNowhere(P, aX, aY, 4);
              Exit;
            end;
            if ((uX < (aX - 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 6, 7))) then
            begin
              RevengeFromNowhere(P, aX, aY, 6);
              Exit;
            end;
            if ((uX > (aX + 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 2, 3))) then
            begin
              RevengeFromNowhere(P, aX, aY, 2);
              Exit;
            end;
          end;
        end;
      end;
    end;

  AIWalk(P);

  if States.GameTime mod AI_RUNE_CHECK_TIME = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

  Exit;

end;


procedure AIKnight(P: Integer);
var
  X, Y, aX, aY, uX, uY, U, O, A, E, D: Integer;
begin

  if (Players[P].RoadSkillDelay = 0)
  and (Players[P].WineSkillDelay = 0)
  and (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (States.GameTime mod 50 = 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      D := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
      if D mod 2 = 1 then
        Exit;
      Actions.GroupOrderHalt(Players[P].Hero);
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - ROPE_RADIUS) to (aX + ROPE_RADIUS) do
      for Y := (aY - ROPE_RADIUS) to (aY + ROPE_RADIUS) do
      begin
        if TileOnBattlefield(X, Y) then
          if not States.IsRoadAt(8, X, Y) then
            U := States.UnitAt(X, Y);
        if (U > 0) then
        begin
          if CanUseSkillAgainstUnit(P, U) then
          begin
            O := States.UnitOwner(U);
            if (States.UnitType(U) = 19)
            and (Players[O].FieldSkillDelay = 0)
            and (not Players[O].HeroStunned) then
              Exit;
            if (P <> O)
            and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
            and (InRange(O, 0, 7)) then 
            begin
              uX := States.UnitPositionX(U);
              uY := States.UnitPositionY(U);
              DeafeningClatter(P, uX, uY);
              RopesOfDeath(P, uX, uY);
              RagingSpurt(P, X, Y);
              Exit;
            end;
          end;
        end;
      end;
    end;

  if (States.KaMRandom > 0.85)
  and (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - DEAFENING_RADIUS) to (aX + DEAFENING_RADIUS) do
      for Y := (aY - DEAFENING_RADIUS) to (aY + DEAFENING_RADIUS) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0)
        and (CanUseWineFieldSkill(X, Y)) then
        begin
          O := States.UnitOwner(U);
          if Players[P].PlayersTeam <> Players[O].PlayersTeam then
            E := E + 1;
          if Players[P].PlayersTeam = Players[O].PlayersTeam then
            A := A + 1;
          if (P <> O)
          and (InRange(O, 0, 7))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1)
          and (E > A)
          and (States.UnitDirection(States.GroupMember(Players[P].Hero, 0)) mod 2 = 1) then 
          begin
            DeafeningClatter(P, X, Y);
            Exit;
          end;
        end;
      end;
    end;

  AIWalk(P);

  if States.GameTime mod AI_RUNE_CHECK_TIME = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

  Exit;

end;


procedure OnTick;
var
  N: array[0..19] of Integer;
  S1, S2, S3, S4, S5, S6, S7, S8: Integer;  
begin

  if InRange(States.GameTime, GAME_START_TIME + 3, GAME_START_TIME + 10) then
    for K := 0 to 7 do
      if States.PlayerEnabled(K) then
      begin
        Actions.FogCoverAll(K);
        Actions.FogRevealRect(K, 1, 39, 70, 109);
      end;

  if States.GameTime = 1 then
    SetScreen;

  CheckRuneTime;

  CheckRuneCleanup;

  if States.GameTime mod EFFECT_CHECK_FACTOR = 0 then
    for I := 0 to 7 do
      if States.PlayerEnabled(I) then
        CheckEffects(I);

  if States.GameTime mod ZOMBIE_STORM_FACTOR = 0 then
  begin
    ZombieStormLeft;
    ZombieStormRight;
  end;

  if States.GameTime mod RELIEF_REGEN_TIME = 0 then
    RegenRelief;

  if States.GameTime mod TILES_RECHECK_TIME = 0 then
    CheckTileCleanup;

  for I := 0 to 7 do
  begin
    CheckDelays(I);
    CheckStolenSkillTime(I);
  end;

  for N[13] := 0 to 11 do
    if (States.PlayerEnabled(N[13])) then
      if TilesRoadLength[N[13]] > 0 then
        CheckTileRoadObjects(N[13]);

  for N[14] := 0 to 11 do
    if TilesFieldLength[N[14]] > 0 then
      CheckTileFieldObjects(N[14]);

  for N[15] := 0 to 11 do
    if TilesWineLength[N[15]] > 0 then
      CheckTileWineObjects(N[15]);

  for I := 0 to 7 do
    if Players[I].Hero > 0 then
      CheckTiles(I);

  CheckTilesForAI;

  for N[0] := 0 to 7 do
    CheckRageCircles(N[0]);

  for N[1] := 0 to 7 do
    CheckExpCircles(N[1]);

  for N[2] := 0 to 7 do
    CheckConcentrationCircles(N[2]);

  for N[3] := 0 to 7 do
    CheckViseCircles(N[3]);

  for N[4] := 0 to 7 do
    CheckTotemCircles(N[4]);

  for N[5] := 0 to 7 do
    CheckGravityCircles(N[5]);

  for N[6] := 0 to 7 do
    CheckFireworks1Circles(N[6]);

  for N[7] := 0 to 7 do
    CheckFireworks2Circles(N[7]);

  for N[8] := 0 to 7 do
    CheckFireworks3Circles(N[8]);

  for N[9] := 0 to 7 do
    CheckFireworks4Circles(N[9]);

  for N[10] := 0 to 7 do
    CheckFireworks5Circles(N[10]);

  for N[12] := 0 to 7 do
    CheckKnightCircles(N[12]);

  for N[16] := 0 to 7 do
    CheckRogueCircles(N[16]);

  for N[19] := 0 to 7 do
    CheckPowerWithinCircles(N[19]);

  for N[11] := 0 to 7 do
    CheckStolenRogueCircles(N[11]);

  if States.GameTime = CHOOSE_HERO_TIMER then
  begin
    RandomChoice;
    for I := 0 to 7 do
      if States.PlayerEnabled(I) then
         Players[I].TempHero := Actions.GiveGroup(I, Players[I].HeroType, 18, 14, 4, 1, 1);
    for K := 0 to 7 do
      if Players[K].TempHero > 0 then
      begin
        Actions.GroupHungerSet(Players[K].TempHero, States.UnitMaxHunger);
        Actions.GroupOrderWalk(Players[K].TempHero, 30, 18, 6);
        Actions.GroupBlockOrders(Players[K].TempHero, True);
      end;
  end;

  if States.GameTime > GAME_START_TIME then
  begin
    for I := 0 to 7 do
      if Players[I].TempHero > 0 then
        Actions.GroupKillAll(Players[I].TempHero, True);
    TeamInfo[0] := '';
    TeamInfo[1] := '';
    Scores[0] := '';
    Scores[1] := '';

    for I := 0 to 3 do
      if States.PlayerEnabled(I) then
        TeamInfo[0] := TeamInfo[0] + '|[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]' + ReChoiceColor(I) + ' {R} []' + ':' + PlayerInfo(I);

    for I := 4 to 7 do
      if States.PlayerEnabled(I) then
        TeamInfo[1] := TeamInfo[1] + '|[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]' + ReChoiceColor(I) + ' {R} []' + ':' + PlayerInfo(I);

    for I := 0 to Length(SortedPlayersLeft) - 1 do
      Scores[0] := Scores[0] + '|[$' + States.PlayerColorText(SortedPlayersLeft[I]) + ']' + States.PlayerName(SortedPlayersLeft[I]) + '[]: ' + KillsColor(SortedPlayersLeft[I]) + IntToStr(Players[SortedPlayersLeft[I]].Kills) + '[]';

    for I := 0 to Length(SortedPlayersRight) - 1 do
      Scores[1] := Scores[1] + '|[$' + States.PlayerColorText(SortedPlayersRight[I]) + ']' + States.PlayerName(SortedPlayersRight[I]) + '[]: ' + KillsColor(SortedPlayersRight[I]) + IntToStr(Players[SortedPlayersRight[I]].Kills) + '[]';

  end;

  for I := 0 to 3 do
    if (States.PlayerEnabled(I))
    and (Players[I].HeroChosen)
    and (States.GameTime > CHOOSE_HERO_TIMER)
    and (not Players[I].ReChoice) then
    begin
      Actions.OverlayTextSet(I, '<$33> [$ADAF67]' + States.UnitTypeName(Players[I].HeroType) + '[]!'
      + '||<$35>: ' + RoadSkillName(I, Players[I].HeroType) + '. <$34>: ' + IntToStr(Players[I].RoadSkillDelay/10)
      + '|<$36>: ' + FieldSkillName(I, Players[I].HeroType) + '. <$34>: ' + IntToStr(Players[I].FieldSkillDelay/10)
      + '|<$37>: ' + WineSkillName(I, Players[I].HeroType) + '. <$34>: ' + IntToStr(Players[I].WineSkillDelay/10)
      + '|<$39>: ' + HPColor(I) + IntToStr(Players[I].HP) + '[]|' + '|<$45>: ' + IntToStr(RuneTime/10) + '|'
      + StatusText(I) + '|||<$41>:|' + TeamInfo[0] + '|||<$79>:|' + Scores[0]);
    end;

  for I := 4 to 7 do
    if (States.PlayerEnabled(I))
    and (Players[I].HeroChosen)
    and (States.GameTime > CHOOSE_HERO_TIMER)
    and (not Players[I].ReChoice) then
    begin
      Actions.OverlayTextSet(I, '<$33> [$ADAF67]' + States.UnitTypeName(Players[I].HeroType) + '[]!'
      + '||<$35>: ' + RoadSkillName(I, Players[I].HeroType) + '. <$34>: ' + IntToStr(Players[I].RoadSkillDelay/10)
      + '|<$36>: ' + FieldSkillName(I, Players[I].HeroType) + '. <$34>: ' + IntToStr(Players[I].FieldSkillDelay/10)
      + '|<$37>: ' + WineSkillName(I, Players[I].HeroType) + '. <$34>: ' + IntToStr(Players[I].WineSkillDelay/10)
      + '|<$39>: ' + HPColor(I) + IntToStr(Players[I].HP) + '[]|' + '|<$45>: ' + IntToStr(RuneTime/10) + '|'
      + StatusText(I) + '|||<$41>:|' + TeamInfo[1] + '|||<$79>:|' + Scores[1]);
    end;

  for I := 0 to 7 do
    if Players[I].ReChoice then
      Actions.OverlayTextSet(I, '<$64> ' + IntToStr((Players[I].ReChoiceTime - States.GameTime)/10));

  if States.GameTime mod 12000 = 0 then
    AutoFeed;

  CheckStatus;

  if States.GameTime < CHOOSE_HERO_TIMER then
  begin
    Actions.OverlayTextSet(-1, '<$38>: ' + IntToStr((CHOOSE_HERO_TIMER - States.GameTime) / 10) + ' (<$40>)|');
    for I := 0 to 3 do
      if States.PlayerEnabled(I) then
        Actions.OverlayTextAppend(I, TeamChoice[0]);

    for I := 4 to 7 do
      if States.PlayerEnabled(I) then
        Actions.OverlayTextAppend(I, TeamChoice[1]);
  end;

  if States.GameTime = GAME_START_TIME then
    SetHeroes;

  if States.GameTime > GAME_START_TIME then
    CheckVictoryDefeat;

  if States.GameTime > GAME_START_TIME + 10 then
    for I := 0 to 7 do
      if Players[I].Kills > 0 then
        if not FirstBlood then
        begin
          Actions.PlayWAV(-1, 'FirstBlood', 1);
          FirstBlood := True;
        end;

  ClearArrays;

  if States.GameTime mod PLANT_TREES_TIME = 0 then
    PlantTrees;

  for I := 0 to 11 do
    if (States.GameTime mod AVOID_FACTOR = 0)
    and (States.Gametime > CHOOSE_HERO_TIMER) then
      AvoidDanger(I);

  if not DEBUG_MODE then
    for I := 0 to 7 do
      if States.PlayerEnabled(I) then
        if (States.PlayerIsAI(I))
        and (States.GameTime = Players[I].AIChoiceTime) then
          AIHeroChoice(I);

  for S1 := 0 to (Players[0].CurrentSpurtLength - 1) do
    CheckSpurt(0, S1);

  for S2 := 0 to (Players[1].CurrentSpurtLength - 1) do
    CheckSpurt(1, S2);

  for S3 := 0 to (Players[2].CurrentSpurtLength - 1) do
    CheckSpurt(2, S3);

  for S4 := 0 to (Players[3].CurrentSpurtLength - 1) do
    CheckSpurt(3, S4);

  for S5 := 0 to (Players[4].CurrentSpurtLength - 1) do
    CheckSpurt(4, S5);

  for S6 := 0 to (Players[5].CurrentSpurtLength - 1) do
    CheckSpurt(5, S6);

  for S7 := 0 to (Players[6].CurrentSpurtLength - 1) do
    CheckSpurt(6, S7);

  for S8 := 0 to (Players[7].CurrentSpurtLength - 1) do
    CheckSpurt(7, S8);

  for I := 0 to 7 do
    if States.Gametime > CHOOSE_HERO_TIMER then
    begin
      if States.GameTime = Players[I].DefenceTime then
        ClearDefence(I);

      if States.GameTime = Players[I].ClearPikeObjTime then
        ClearPikeObj(I);

      if not Players[I].HeroReborn then
      begin
        if States.GameTime >= Players[I].SkillCastRespawnTime then
          if Players[I].Hero > 0 then
            if States.GroupOwner(Players[I].Hero) = TEMP_PLAYER then
              RespawnUnit(I);

        CheckRespawn(I);

      end;

      AIWalkAfterSkill(I);

      AIWalkIdle(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 16) then
            AISword(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 23) then
            AIBarb(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 18) then
            AICrossbow(I);

      {if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 20) then
            AIPikeman(I);}

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 19) then
            AILance(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 26) then
            AIWarrior(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 17) then
            AIBowman(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 22) then
            AIKnight(I);

    end;

end;