//Script version 1.77 (16 jul 2015)

const

//Skills cooldowns

  LANCE_ROAD_DELAY = 80;
  LANCE_FIELD_DELAY = 80;
  LANCE_WINE_DELAY = 280;

  BARB_ROAD_DELAY = 110;
  BARB_FIELD_DELAY = 180;
  BARB_WINE_DELAY = 300;

  XBOW_ROAD_DELAY = 100;
  XBOW_FIELD_DELAY = 160;
  XBOW_WINE_DELAY = 250;

  SWORD_ROAD_DELAY = 100;
  SWORD_FIELD_DELAY = 130;
  SWORD_WINE_DELAY = 250;

  PIKE_ROAD_DELAY = 160;
  PIKE_FIELD_DELAY = 100;
  PIKE_WINE_DELAY = 350;

  BOWMAN_ROAD_DELAY = 100;
  BOWMAN_FIELD_DELAY = 170;
  BOWMAN_WINE_DELAY = 250;

  AXE_ROAD_DELAY = 180;
  AXE_FIELD_DELAY = 200;
  AXE_WINE_DELAY = 1350;

  VAGA_ROAD_DELAY = 130;
  VAGA_FIELD_DELAY = 170;
  VAGA_WINE_DELAY = 600;

  WARRIOR_ROAD_DELAY = 110;
  WARRIOR_FIELD_DELAY = 160;
  WARRIOR_WINE_DELAY = 350;

  KNIGHT_ROAD_DELAY = 130;
  KNIGHT_FIELD_DELAY = 150;
  KNIGHT_WINE_DELAY = 180;

  ROGUE_ROAD_DELAY = 80;
  ROGUE_FIELD_DELAY = 100;
  ROGUE_WINE_DELAY = 0;

  ROGUE_TOTEM_DELAY = 100;
  ROGUE_FIREWORKS_DELAY = 50;
  ROGUE_REVENGE_DELAY = 25;

  SCOUT_ROAD_DELAY = 100;
  SCOUT_FIELD_DELAY = 150;
  SCOUT_WINE_DELAY = 300;

//Skills parameters

  TELEPORT_RADIUS = 5;
  SACRIFICIAL_RADIUS = 10;
  TOTEM_ADD_RADIUS = 7;
  MILIZOMBIE_RADIUS = 4;
  MAX_MILIZOMBIE = 100;
  IN_FEAR_RADIUS = 5;
  BOMB_RADIUS = 8;
  PRISON_RADIUS = 8;
  GRAVITY_RADIUS1 = 5;
  FIRE_RADIUS = 6;
  WEREWOLF_RADIUS = 6;
  SHOCK_RADIUS = 6;
  REGEN_RADIUS = 4;
  ARMOR_RADIUS = 5;
  ROPE_RADIUS = 5;
  STEAL_RADIUS = 8;
  STONES_RADIUS = 5;
  VAMPIRE_RADIUS = 5;
  MIND_RADIUS = 5;

  RAGE_RADIUS = 5;
  TOTEM_RADIUS = 4;
  CONCENTRATION_RADIUS = 8;
  VISE_RADIUS = 5;
  EXP_RADIUS = 6;
  GRAVITY_RADIUS = 5;
  FIREWORKS1_RADIUS = 5;
  FIREWORKS2_RADIUS = 4;
  VAGA_WAVE_RADIUS = 4;
  SILENCE_RADIUS = 8;
  DEAFENING_RADIUS = 4;
  MENTAL_RADIUS = 4;
  
  RAGE_CYCLES = 1;
  TOTEM_CYCLES = 5;
  CONCENTRATION_CYCLES = 1;
  VISE_CYCLES = 1;
  EXP_CYCLES = 1;
  GRAVITY_CYCLES = 1;
  FIREWORKS1_CYCLES = 1;
  FIREWORKS2_CYCLES = 1;
  VAGA_WAVE_CYCLES = 1;
  DEAFENING_CYCLES = 1;
  SPURT_LENGTH = 12;
  MENTAL_CYCLES = 1;
  MENTAL_DISTANCE = 8;

//Skills speed

  XBOW_ROAD_SPEED = 4;
  XBOW_WINE_SPEED = 5;

  LANCE_ROAD_SPEED = 2.5;
  LANCE_WINE_SPEED = 15;

  BARB_ROAD_SPEED = 0.5;
  BARB_FIELD_SPEED = 1.6;
  BARB_WINE_SPEED = 0.3;

  SWORD_ROAD_SPEED = 0.75;

  PIKE_ROAD_SPEED = 1;
  PIKE_WINE_SPEED = 0.8;

  BOWMAN_WINE_SPEED = 4;
  BOWMAN_PRISON_AI_CHANCE = 0.9;

  AXE_ROAD_SPEED = 1;
  AXE_FIELD_SPEED = 2;

  VAGA_ROAD_SPEED = 0.75;
  VAGA_FIELD_SPEED = 1.5;

  WARRIOR_ROAD_SPEED = 1.75;

  KNIGHT_FIELD_SPEED = 3;
  KNIGHT_WINE_SPEED = 3;

  ROGUE_ROAD_SPEED = 2;

//Skills objects

  LANCE_OBJECT = 21;
  LANCE_OBJECT2 = 18;
  LANCE_OBJECT3 = 19;

  XBOW_OBJECT = 54;
  XBOW_OBJECT2 = 57;
  XBOW_OBJECT3 = 24;

  BARB_OBJECT = 214;
  BARB_OBJECT2 = 210;
  BARB_OBJECT3 = 220;
  BARB_OBJECT4 = 216;
  BARB_OBJECT5 = 218;

  SWORD_OBJECT = 68;
  SWORD_OBJECT1 = 70;

  PIKE_OBJECT = 13;
  PIKE_OBJECT2 = 45;
  PIKE_OBJECT3 = 46;
  PIKE_OBJECT4 = 47;
  PIKE_OBJECT5 = 16;
  PIKE_OBJECT6 = 41;
  PIKE_OBJECT7 = 42;
  PIKE_OBJECT8 = 43;
  PIKE_OBJECT9 = 14;
  PIKE_OBJ_STONE = 8;
  PIKE_OBJ_STONE1 = 61;

  BOWMAN_OBJECT = 58;
  BOWMAN_OBJECT2 = 55;
  BOWMAN_OBJECT3 = 50;
  BOWMAN_OBJECT4 = 24;
  BOWMAN_OBJECT5 = 9;
  BOWMAN_MINE = 254;
  
  AXE_OBJECT = 60;
  AXE_OBJECT2 = 23;
  AXE_OBJECT3 = 5;
  AXE_OBJECT4 = 6;

  VAGA_OBJECT = 7;
  VAGA_OBJECT2 = 196;
  VAGA_OBJECT3 = 62;
  VAGA_OBJECT4 = 60;
  VAGA_OBJECT5 = 6;
  VAGA_OBJECT6 = 73;

  SOS_OBJECT = 182;
  SOS_OBJECT2 = 183;
  SOS_OBJECT3 = 184;
  SOS_OBJECT4 = 185;
  SOS_OBJECT5 = 186;
  SOS_OBJECT6 = 187;
  SOS_OBJECT7 = 188;
  SOS_OBJECT8 = 189;

  WARRIOR_OBJECT = 18;
  WARRIOR_OBJECT2 = 21;
  WARRIOR_OBJECT3 = 24;
  WARRIOR_OBJECT4 = 103;
  WARRIOR_OBJECT5 = 59;
  WARRIOR_OBJECT6 = 219;

  KNIGHT_OBJECT = 62;
  KNIGHT_OBJECT2 = 12;
  KNIGHT_OBJECT3 = 69;
  KNIGHT_OBJECT4 = 181;

  ROGUE_OBJECT = 24;
  ROGUE_OBJECT2 = 192;
  ROGUE_OBJECT3 = 195;
  ROGUE_OBJECT4 = 17;

  SCOUT_OBJECT = 8;
  SCOUT_OBJECT2 = 7;

//Runes

  RUNE_X = 35;
  RUNE_Y1 = 24;
  RUNE_Y2 = 47;
  RUNE_TIMER = 1200;
  RUNE_ZOMBIE_LIFE = 1800;
  RUNE_REGEN_OBJ = 7;
  RUNE_DOUBLE_OBJ = 124;
  RUNE_ILLUSION_OBJ = 203;
  RUNE_IMMORTAL_OBJ = 63;
  RUNE_RECHARGE_OBJ = 88;
  RUNE_IMMORTAL_ANIMATION = 4;
  RUNE_BLOCK_OBJ = 61;
  RUNE_DOUBLE_TIME = 150;
  RUNE_IMMORTAL_TIME = 200;
  RUNE_ILLUSION_TIME = 1800;
  RUNE_RECHARGE_TIME = 600;
 

//Player stats

  IMMORTAL_TIME = 60;
  STUNNED_TIME = 30;
  IN_FEAR_TIME = 80;
  START_HP = 10;
  MAX_HP = 12;
  CHOOSE_HERO_TIMER = 350;
  ZOMBIE_STORM_TIME = 100;
  STORM_CHANCE = 0;
  DEL_MINE_TIME = 1500;
  PRISON_TIME = 70;
  CIRCLE_DEF_TIME = 6;
  WEREWOLF_TIME = 450;
  REGEN_TIME = 40;
  VAGA_TIME = 10;
  REGEN_DELAY = 60;
  CONCENTRATION_TIME = 60;
  SHOCK_TIME = 10;
  SKILL_RESPAWN_TIME = 1;
  ARMOR_TIME = 50;
  ARMOR_DELAY = 15;
  SILENCE_TIME = 120;
  ROPE_DELAY = 14;
  DEAFENING_TIME = 50;
  SPURT_TIME = 25;
  STOLEN_SKILL_TIME = 1200;
  CAPTURE_MIND_TIME = 150;
  MAX_SCOUT_STONES = 5;

//Game mechanics

  DESYNC_FACTOR = 1;
  CLEANUP_TIME = 20;
  PLANT_TREES_TIME = 25;
  PLANT_TREES_FACTOR = 0.8;
  AVOID_FACTOR = 10;
  RECHARGE_FACTOR = 0.25;
  ZOMBIE_ATTACK_FACTOR = 5;
  HEAL_CHECK_RADIUS = 4;
  HEAL_CHECK_TIME = 15;
  DEBUG_MODE = True;

//Battlefield

  SPECTATORS = False;
  MIN_X = 12;
  MAX_X = 59;
  MIN_Y = 12;
  MAX_Y = 59;

type

  aSkill = (sNone,
            sFieryLance, sTeleport, s10kSpears,
            sCrackingEarth, sWaveOfRage, sTotem,
            sSpikedEarth, sZombieSummon, sFear,
            sAccurateShot, sSuddenDeath, sSniperShot,
            sMine, sPrison, sRevengeFromNowhere,
            sGravity, sDeadlyFireworks, sWerewolf,
            sDisorientation, sVagaWave, sRegen,
            sViseOfDeath, sSacrificialTeleport, sConcentration,
            sFierySnake, sSturdyArmor, sCircleOfSilence,
            sRopesOfDeath, sDeafeningClatter, sRagingSpurt,
            sMentalBurst, sSteal, sUniversal, 
            sStones, sVampire, sMind);

type
  aPlayer = Record
    SpawnX: Integer;
    SpawnY: Integer;
    Hero: Integer;
    HeroType: Integer;
    HeroMindType: Integer;
    TempHeroMindType: Integer;
    HeroImmortal: Boolean;
    HeroImmortalTime: Integer;
    HeroChosen: Boolean;
    HP: Integer;
    RoadSkillDelay: Integer;
    FieldSkillDelay: Integer;
    WineSkillDelay: Integer;
    Direction: Integer;
    TribuneX: Integer;
    TribuneY: Integer;
    HeroStunnedTime: Integer;
    HeroStunned: Boolean;
    HeroInFearTime: Integer;
    HeroInFear: Boolean;
    ZombiePlayer: Integer;
    RoadPlayer: Integer;
    DefenceTime: Integer;
    HeroPrisoned: Boolean;
    HeroPrisonedTime: Integer;
    WerewolfTime: Integer;
    VagaX: Integer;
    VagaY: Integer;
    VagaDir: Integer;
    VagaAppearTime: Integer;
    RegenDelay: Integer;
    ClearPikeObjTime: Integer;
    GravityX: Integer;
    GravityY: Integer;
    RespawnCheckTime: Integer;
    DDTime : Integer;
    DD: Boolean;
    InIllusion: Boolean;
    PlayersTeam: Integer;
    CastingSkill: Boolean;
    SkillTime: Integer;
    SkillCastX: Integer;
    SkillCastY: Integer;
    SkillCastDir: Integer;
    SkillCastRespawnTime: Integer;
    ArmorStartTime: Integer;
    HeroSilent: Boolean;
    HeroSilentTime: Integer;
    HeroSilentStartTime: Integer;
    AIChoiceTime: Integer;
    RopeUnitDir: Integer;
    RopeTime: Integer;
    RopeAttacker: Integer;
    RopeDX: Integer;
    RopeDY: Integer;
    Preparing: Boolean;
    PreparingTime: Integer;
    ReCharge: Boolean;
    ReChargeTime: Integer;
    LastUsedSkill: aSkill;
    StolenSkill: aSkill;
    StolenSkillName: ANSIString;
    StolenSkillTime: Integer;
    TempHeroType: Integer;
    CaptureMind: Boolean;
    CaptureMindTime: Integer;
    MindStunned: Boolean;
    Stone: Integer;
    StoneRogue: Boolean;
  end;


type
  aCircle = Record
    AddTime: Integer;
    X: Integer;
    Y: Integer;
    Radius: Integer;
    Obj: Integer;
  end;


type
  aTile = Record
    X: Integer;
    Y: Integer;
    Owner: Integer;
  end;


var
  I, J, K: Integer;
  Players: array[0..11] of aPlayer;
  ClearTilesRoadTimes, SetTilesRoadTimes, TilesRoadX, TilesRoadY, TilesRoadObjects,
  ClearTilesFieldTimes, SetTilesFieldTimes, TilesFieldX, TilesFieldY, TilesFieldObjects,
  ClearTilesWineTimes, SetTilesWineTimes, TilesWineX, TilesWineY, TilesWineObjects: array[0..11] of array of Integer;
  RageCircles, TotemCircles, ConcentrationCircles, ViseCircles, ExpCircles, GravityCircles,
  FireworksCircles1, FireworksCircles2, FireworksCircles3, FireworksCircles4, 
  FireworksCircles5, VagaCircles, KnightCircles, RogueCircles: array[0..11] of array of aCircle;
  TilesRoadLength, TilesFieldLength, TilesWineLength: array[0..11] of Integer;
  RageCirclesLength, TotemCirclesLength, ConcentrationCirclesLength, ViseCirclesLength, ExpCirclesLength,
  GravityCirclesLength, FireworksCircles1Length, FireworksCircles2Length, FireworksCircles3Length, 
  FireworksCircles4Length, FireworksCircles5Length, VagaCirclesLength, KnightCirclesLength, RogueCirclesLength: array[0..11] of Integer;
  TimeToClearRageArray, TimeToClearTotemArray, TimeToClearConcentrationArray,
  TimeToClearViseArray, TimeToClearExpArray, TimeToClearGravityArray, TimeToClearFireworks1Array,
  TimeToClearFireworks2Array, TimeToClearFireworks3Array, TimeToClearFireworks4Array, TimeToClearFireworks5Array,
  TimeToClearVagaArray, TimeToClearKnightArray, TimeToClearRogueArray: array[0..11] of Integer;
  PikeObjects, SOSObjects: array[0..7] of Integer;
  Roads, Tiles: array[MIN_X..MAX_X] of array[MIN_Y..MAX_Y] of aTile;
  TeamChoice: array[0..1] of ANSIString;
  TeamInfo: array[0..1] of ANSIString;
  ClearRoadTilesArrayTime, ClearFieldTilesArrayTime, ClearWineTilesArrayTime: array[0..11] of Integer;
  RuneTime: Integer;
  M, M2: array[0..7] of Integer;
  ZomboHero: array[0..7] of array[0..3] of Integer;
  DeathX, DeathY: Integer;
  AISoldiers: array of Integer;
  SpurtTimes, SpurtX, SpurtY, SpurtDir: array[0..11] of array[0..SPURT_LENGTH - 1] of Integer;
  RUNE_Y: Integer;


function InRange(Value, Min, Max: Integer): Boolean;
begin
  Result := (Value >= Min) and (Value <= Max);
end;


function TileOnBattlefield(X, Y: Integer): Boolean;
begin
  if X <= 0 then
    Exit;
  if Y <= 0 then
    Exit;
  Result := (InRange(X, MIN_X, MAX_X))
  and (InRange(Y, MIN_Y, MAX_Y))
  and (States.MapTileType(X, Y) <> 152)
  and (States.MapTileType(X, Y) <> 202);
end;


function CanPlaceObject(X, Y: Integer): Boolean;
begin
  if X <= 0 then
    Exit;
  if Y <= 0 then
    Exit;

  Result := (TileOnBattlefield(X, Y))
  and (States.MapTileObject(X, Y) <> BARB_OBJECT3)
  and (States.MapTileObject(X, Y) <> BOWMAN_MINE)
  and (States.MapTileObject(X, Y) <> BOWMAN_OBJECT5)
  and (not InRange(States.MapTileObject(X, Y), SOS_OBJECT, SOS_OBJECT8))
  and (not InRange(States.MapTileObject(X, Y), SWORD_OBJECT, VAGA_OBJECT6));

end;


procedure KillUnneeded;
var
  Units: array of Integer;
begin
  for J := 0 to 7 do
  begin
    if States.PlayerEnabled(J) then
      Units := States.PlayerGetAllUnits(J);
    for K := 0 to Length(Units) - 1 do
      Actions.UnitKill(Units[K], True);
  end;

  Actions.UnitKill(States.UnitAt(3, 2), True);
  Actions.UnitKill(States.UnitAt(5, 2), True);
  Actions.UnitKill(States.UnitAt(7, 2), True);

end;


procedure AutoFeed;
var
  UnitsToFeed: array of Integer;
begin
  for I := 0 to 8 do
  begin
    if States.PlayerEnabled(I) then
      UnitsToFeed := States.PlayerGetAllUnits(I);
    for K := 0 to Length(UnitsToFeed) - 1 do
      Actions.UnitHungerSet(UnitsToFeed[K], States.UnitMaxHunger);
  end;
end;


procedure CheckRoadsInfo;
var
  aX, aY: Integer;
begin
  for aX := MIN_X to MAX_X do
  for aY := MIN_Y to MAX_Y do
  begin
    Roads[aX][aY].X := aX;
    Roads[aX][aY].Y := aY;
    Roads[aX][aY].Owner := -1;
  end;
end;


procedure CheckTilesInfo;
var
  aX, aY: Integer;
begin
  for aX := MIN_X to MAX_X do
  for aY := MIN_Y to MAX_Y do
  begin
    Tiles[aX][aY].X := aX;
    Tiles[aX][aY].Y := aY;
    Tiles[aX][aY].Owner := -1;
  end;
end;


procedure AIHeroChoice(P: Integer);
begin
  case States.KaMRandomI(5) of
    0: Players[P].HeroType := 16;
    1: Players[P].HeroType := 23;
    2: Players[P].HeroType := 18;
    3: Players[P].HeroType := 19;
    4: Players[P].HeroType := 26;
  end;

  Players[P].HeroChosen := True;

  if InRange(P, 0, 3) then
    TeamChoice[0] := TeamChoice[0] + '|[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[] <$32> ' + States.UnitTypeName(Players[P].HeroType);
  if InRange(P, 4, 7) then
    TeamChoice[1] := TeamChoice[1] + '|[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[] <$32> ' + States.UnitTypeName(Players[P].HeroType);

end;


procedure OnMissionStart;
begin

  AISoldiers := States.PlayerGetAllGroups(8);

  if States.KaMRandom > 0.5 then
    RUNE_Y := RUNE_Y1
  else
    RUNE_Y := RUNE_Y2;

  CheckRoadsInfo;

  CheckTilesInfo;

  PikeObjects[0] := PIKE_OBJECT;
  PikeObjects[1] := PIKE_OBJECT2;
  PikeObjects[2] := PIKE_OBJECT3;
  PikeObjects[3] := PIKE_OBJECT4;
  PikeObjects[4] := PIKE_OBJECT5;
  PikeObjects[5] := PIKE_OBJECT6;
  PikeObjects[6] := PIKE_OBJECT7;
  PikeObjects[7] := PIKE_OBJECT8;

  SOSObjects[0] := SOS_OBJECT;
  SOSObjects[1] := SOS_OBJECT2;
  SOSObjects[2] := SOS_OBJECT3;
  SOSObjects[3] := SOS_OBJECT4;
  SOSObjects[4] := SOS_OBJECT5;
  SOSObjects[5] := SOS_OBJECT6;
  SOSObjects[6] := SOS_OBJECT7;
  SOSObjects[7] := SOS_OBJECT8;

  for I := 0 to 11 do
  for K := 0 to 11 do
  begin
    if (States.PlayerEnabled(I))
    and (States.PlayerEnabled(K))
    and (I <> K) then
    begin
      Actions.PlayerShareFog(I, K, False);
      Actions.PlayerShareFog(K, I, False);
    end;
  end;

  for I := 0 to 7 do
  for K := 0 to 3 do
    ZomboHero[I][K] := -1;

  for I := 0 to 3 do
    if States.PlayerEnabled(I) then
    begin
      Actions.PlayerAllianceChange(I, 11, True, True);
      Actions.PlayerAllianceChange(11, I, False, False);
    end;

  for I := 4 to 7 do
    if States.PlayerEnabled(I) then
    begin
      Actions.PlayerAllianceChange(I, 10, True, True);
      Actions.PlayerAllianceChange(10, I, False, False);
    end;

  KillUnneeded;

  AutoFeed;

  RuneTime := RUNE_TIMER;

  Actions.ShowMsg(-1, '<$0>');

  for I := 0 to 7 do
  for K := 0 to 7 do
  begin
    if (States.PlayerEnabled(I))
    and (States.PlayerEnabled(K))
    and (I <> K) then
    begin
      Actions.PlayerAllianceChange(I, K, True, True);
      Actions.PlayerAllianceChange(K, I, True, True);
    end;
  end;

  for I := 0 to 11 do
  begin
    RageCirclesLength[I] := 0;
    TotemCirclesLength[I] := 0;
    ConcentrationCirclesLength[I] := 0;
    ViseCirclesLength[I] := 0;
    ExpCirclesLength[I] := 0;
    GravityCirclesLength[I] := 0;
    FireworksCircles1Length[I] := 0;
    FireworksCircles2Length[I] := 0;
    FireworksCircles3Length[I] := 0;
    FireworksCircles4Length[I] := 0;
    FireworksCircles5Length[I] := 0;
    VagaCirclesLength[I] := 0;
    ClearRoadTilesArrayTime[I] := -1;
    TilesRoadLength[I] := 0;
    ClearFieldTilesArrayTime[I] := -1;
    TilesFieldLength[I] := 0;
    ClearWineTilesArrayTime[I] := -1;
    TilesWineLength[I] := 0;
    KnightCirclesLength[I] := 0;
    RogueCirclesLength[I] := 0;
  end;

  for I := 8 to 9 do
    Players[I].PlayersTeam := -1;

  Players[10].PlayersTeam := 0;

  Players[11].PlayersTeam := 1;

  for I := 0 to 7 do
    if States.PlayerEnabled(I) then
      Actions.FogCoverAll(I);

  for I := 0 to 3 do
    if States.PlayerEnabled(I) then
      Actions.FogRevealRect(I, 1, 1, 10, 10);

  for I := 4 to 7 do
    if States.PlayerEnabled(I) then
      Actions.FogRevealRect(I, 60, 1, 70, 10);
 
  with Players[0] do
  begin
    SpawnX := 19;
    SpawnY := 19;
    Hero := -1;
    HeroType := -1;
    HeroImmortal := False;
    HeroChosen := False;
    HP := START_HP;
    RoadSkillDelay := 0;
    FieldSkillDelay := 0;
    WineSkillDelay := 0;
    Direction := 2;
    TribuneX := 3;
    TribuneY := 2;
    HeroImmortalTime := 0;
    HeroStunnedTime := 0;
    HeroStunned := False;
    HeroInFearTime := 0;
    HeroInFear := False;
    ZombiePlayer := 10;
    RoadPlayer := 8;
    DefenceTime := 0;
    HeroPrisoned := False;
    HeroPrisonedTime := 0;
    WerewolfTime := 0;
    VagaX := 0;
    VagaY := 0;
    VagaAppearTime := 0;
    VagaDir := 0;
    RegenDelay := 0;
    ClearPikeObjTime := 0;
    GravityX := 0;
    GravityY := 0;
    RespawnCheckTime := -1;
    DDTime := 0;
    DD := False;
    InIllusion := False;
    PlayersTeam := 0;
    CastingSkill := False;
    SkillTime := 0;
    SkillCastX := 0;
    SkillCastY := 0;
    SkillCastDir := 0;
    SkillCastRespawnTime := 0;
    ArmorStartTime := 0;
    HeroSilent := False;
    HeroSilentTime := 0;
    HeroSilentStartTime := 0;
    AIChoiceTime := 10 + States.KaMRandomI(100) + States.KaMRandomI(200);
    RopeUnitDir := -1;
    RopeAttacker := -1;
    RopeTime := -1;
    RopeDX := -1;
    RopeDY := -1;
    Preparing := False;
    PreparingTime := 0;
    ReCharge := False;
    ReChargeTime := 0;
    LastUsedSkill := sNone;
    StolenSkill := sNone;
    StolenSkillName := '<$57>';
    TempHeroType := -1;
    StolenSkillTime := 0;
    Stone := MAX_SCOUT_STONES;
    CaptureMind := False;
    CaptureMindTime := 0;
    MindStunned := False;
    HeroMindType := -1;
    TempHeroMindType := -1;
    StoneRogue := False;
  end;

  with Players[1] do
  begin
    SpawnX := 19;
    SpawnY := 30;
    Hero := -1;
    HeroType := -1;
    HeroImmortal := False;
    HeroChosen := False;
    HP := START_HP;
    RoadSkillDelay := 0;
    FieldSkillDelay := 0;
    WineSkillDelay := 0;
    Direction := 2;
    TribuneX := 5;
    TribuneY := 2;
    HeroImmortalTime := 0;
    HeroStunnedTime := 0;
    HeroStunned := False;
    HeroInFearTime := 0;
    HeroInFear := False;
    ZombiePlayer := 10;
    RoadPlayer := 8;
    DefenceTime := 0;
    HeroPrisoned := False;
    HeroPrisonedTime := 0;
    WerewolfTime := 0;
    VagaX := 0;
    VagaY := 0;
    VagaAppearTime := 0;
    VagaDir := 0;
    RegenDelay := 0;
    ClearPikeObjTime := 0;
    GravityX := 0;
    GravityY := 0;
    RespawnCheckTime := -1;
    DDTime := 0;
    DD := False;
    InIllusion := False;
    PlayersTeam := 0;
    CastingSkill := False;
    SkillTime := 0;
    SkillCastX := 0;
    SkillCastY := 0;
    SkillCastDir := 0;
    SkillCastRespawnTime := 0;
    ArmorStartTime := 0;
    HeroSilent := False;
    HeroSilentTime := 0;
    HeroSilentStartTime := 0;
    AIChoiceTime := 10 + States.KaMRandomI(100) + States.KaMRandomI(200);
    RopeUnitDir := -1;
    RopeAttacker := -1;
    RopeTime := -1;
    RopeDX := -1;
    RopeDY := -1;
    Preparing := False;
    PreparingTime := 0;
    ReCharge := False;
    ReChargeTime := 0;
    LastUsedSkill := sNone;
    StolenSkill := sNone;
    StolenSkillName := '<$57>';
    TempHeroType := -1;
    StolenSkillTime := 0;
    Stone := MAX_SCOUT_STONES;
    CaptureMind := False;
    CaptureMindTime := 0;
    MindStunned := False;
    HeroMindType := -1;
    TempHeroMindType := -1;
    StoneRogue := False;
  end;

  with Players[2] do
  begin
    SpawnX := 19;
    SpawnY := 41;
    Hero := -1;
    HeroType := -1;
    HeroImmortal := False;
    HeroChosen := False;
    HP := START_HP;
    RoadSkillDelay := 0;
    FieldSkillDelay := 0;
    WineSkillDelay := 0;
    Direction := 2;
    TribuneX := 7;
    TribuneY := 2;
    HeroImmortalTime := 0;
    HeroStunnedTime := 0;
    HeroStunned := False;
    HeroInFearTime := 0;
    HeroInFear := False;
    ZombiePlayer := 10;
    RoadPlayer := 8;
    DefenceTime := 0;
    HeroPrisoned := False;
    HeroPrisonedTime := 0;
    WerewolfTime := 0;
    VagaX := 0;
    VagaY := 0;
    VagaAppearTime := 0;
    VagaDir := 0;
    RegenDelay := 0;
    ClearPikeObjTime := 0;
    GravityX := 0;
    GravityY := 0;
    RespawnCheckTime := -1;
    DDTime := 0;
    DD := False;
    InIllusion := False;
    PlayersTeam := 0;
    CastingSkill := False;
    SkillTime := 0;
    SkillCastX := 0;
    SkillCastY := 0;
    SkillCastDir := 0;
    SkillCastRespawnTime := 0;
    ArmorStartTime := 0;
    HeroSilent := False;
    HeroSilentTime := 0;
    HeroSilentStartTime := 0;
    AIChoiceTime := 10 + States.KaMRandomI(100) + States.KaMRandomI(200);
    RopeUnitDir := -1;
    RopeAttacker := -1;
    RopeTime := -1;
    RopeDX := -1;
    RopeDY := -1;
    Preparing := False;
    PreparingTime := 0;
    ReCharge := False;
    ReChargeTime := 0;
    LastUsedSkill := sNone;
    StolenSkill := sNone;
    StolenSkillName := '<$57>';
    TempHeroType := -1;
    StolenSkillTime := 0;
    Stone := MAX_SCOUT_STONES;
    CaptureMind := False;
    CaptureMindTime := 0;
    MindStunned := False;
    HeroMindType := -1;
    TempHeroMindType := -1;
    StoneRogue := False;
  end;

  with Players[3] do
  begin
    SpawnX := 19;
    SpawnY := 52;
    Hero := -1;
    HeroType := -1;
    HeroImmortal := False;
    HeroChosen := False;
    HP := START_HP;
    RoadSkillDelay := 0;
    FieldSkillDelay := 0;
    WineSkillDelay := 0;
    Direction := 2;
    TribuneX := 9;
    TribuneY := 2;
    HeroImmortalTime := 0;
    HeroStunnedTime := 0;
    HeroStunned := False;
    HeroInFearTime := 0;
    HeroInFear := False;
    ZombiePlayer := 10;
    RoadPlayer := 8;
    DefenceTime := 0;
    HeroPrisoned := False;
    HeroPrisonedTime := 0;
    WerewolfTime := 0;
    VagaX := 0;
    VagaY := 0;
    VagaAppearTime := 0;
    VagaDir := 0;
    RegenDelay := 0;
    ClearPikeObjTime := 0;
    GravityX := 0;
    GravityY := 0;
    RespawnCheckTime := -1;
    DDTime := 0;
    DD := False;
    InIllusion := False;
    PlayersTeam := 0;
    SkillCastX := 0;
    SkillCastY := 0;
    SkillCastDir := 0;
    SkillCastRespawnTime := 0;
    ArmorStartTime := 0;
    HeroSilent := False;
    HeroSilentTime := 0;
    HeroSilentStartTime := 0;
    AIChoiceTime := 10 + States.KaMRandomI(100) + States.KaMRandomI(200);
    RopeUnitDir := -1;
    RopeAttacker := -1;
    RopeTime := -1;
    RopeDX := -1;
    RopeDY := -1;
    Preparing := False;
    PreparingTime := 0;
    ReCharge := False;
    ReChargeTime := 0;
    LastUsedSkill := sNone;
    StolenSkill := sNone;
    StolenSkillName := '<$57>';
    TempHeroType := -1;
    StolenSkillTime := 0;
    Stone := MAX_SCOUT_STONES;
    CaptureMind := False;
    CaptureMindTime := 0;
    MindStunned := False;
    HeroMindType := -1;
    TempHeroMindType := -1;
    StoneRogue := False;
  end;

  with Players[4] do
  begin
    SpawnX := 52;
    SpawnY := 19;
    Hero := -1;
    HeroType := -1;
    HeroImmortal := False;
    HeroChosen := False;
    HP := START_HP;
    RoadSkillDelay := 0;
    FieldSkillDelay := 0;
    WineSkillDelay := 0;
    Direction := 6;
    TribuneX := 62;
    TribuneY := 2;
    HeroImmortalTime := 0;
    HeroStunnedTime := 0;
    HeroStunned := False;
    HeroInFearTime := 0;
    HeroInFear := False;
    ZombiePlayer := 11;
    RoadPlayer := 9;
    DefenceTime := 0;
    HeroPrisoned := False;
    HeroPrisonedTime := 0;
    WerewolfTime := 0;
    VagaX := 0;
    VagaY := 0;
    VagaAppearTime := 0;
    VagaDir := 0;
    RegenDelay := 0;
    ClearPikeObjTime := 0;
    GravityX := 0;
    GravityY := 0;
    RespawnCheckTime := -1;
    DDTime := 0;
    DD := False;
    InIllusion := False;
    PlayersTeam := 1;
    CastingSkill := False;
    SkillTime := 0;
    SkillCastX := 0;
    SkillCastY := 0;
    SkillCastDir := 0;
    SkillCastRespawnTime := 0;
    ArmorStartTime := 0;
    HeroSilent := False;
    HeroSilentTime := 0;
    HeroSilentStartTime := 0;
    AIChoiceTime := 10 + States.KaMRandomI(100) + States.KaMRandomI(200);
    RopeUnitDir := -1;
    RopeAttacker := -1;
    RopeTime := -1;
    RopeDX := -1;
    RopeDY := -1;
    Preparing := False;
    PreparingTime := 0;
    ReCharge := False;
    ReChargeTime := 0;
    LastUsedSkill := sNone;
    StolenSkill := sNone;
    StolenSkillName := '<$57>';
    TempHeroType := -1;
    StolenSkillTime := 0;
    Stone := MAX_SCOUT_STONES;
    CaptureMind := False;
    CaptureMindTime := 0;
    MindStunned := False;
    HeroMindType := -1;
    TempHeroMindType := -1;
    StoneRogue := False;
  end;

  with Players[5] do
  begin
    SpawnX := 52;
    SpawnY := 30;
    Hero := -1;
    HeroType := -1;
    HeroImmortal := False;
    HeroChosen := False;
    HP := START_HP;
    RoadSkillDelay := 0;
    FieldSkillDelay := 0;
    WineSkillDelay := 0;
    Direction := 6;
    TribuneX := 64;
    TribuneY := 2;
    HeroImmortalTime := 0;
    HeroStunnedTime := 0;
    HeroStunned := False;
    HeroInFearTime := 0;
    HeroInFear := False;
    ZombiePlayer := 11;
    RoadPlayer := 9;
    DefenceTime := 0;
    HeroPrisoned := False;
    HeroPrisonedTime := 0;
    WerewolfTime := 0;
    VagaX := 0;
    VagaY := 0;
    VagaAppearTime := 0;
    VagaDir := 0;
    RegenDelay := 0;
    ClearPikeObjTime := 0;
    GravityX := 0;
    GravityY := 0;
    RespawnCheckTime := -1;
    DDTime := 0;
    DD := False;
    InIllusion := False;
    PlayersTeam := 1;
    CastingSkill := False;
    SkillTime := 0;
    SkillCastX := 0;
    SkillCastY := 0;
    SkillCastDir := 0;
    SkillCastRespawnTime := 0;
    ArmorStartTime := 0;
    HeroSilent := False;
    HeroSilentTime := 0;
    HeroSilentStartTime := 0;
    AIChoiceTime := 10 + States.KaMRandomI(100) + States.KaMRandomI(200);
    RopeUnitDir := -1;
    RopeAttacker := -1;
    RopeTime := -1;
    RopeDX := -1;
    RopeDY := -1;
    Preparing := False;
    PreparingTime := 0;
    ReCharge := False;
    ReChargeTime := 0;
    LastUsedSkill := sNone;
    StolenSkill := sNone;
    StolenSkillName := '<$57>';
    TempHeroType := -1;
    StolenSkillTime := 0;
    Stone := MAX_SCOUT_STONES;
    CaptureMind := False;
    CaptureMindTime := 0;
    MindStunned := False;
    HeroMindType := -1;
    TempHeroMindType := -1;
    StoneRogue := False;
  end;

  with Players[6] do
  begin
    SpawnX := 52;
    SpawnY := 41;
    Hero := -1;
    HeroType := -1;
    HeroImmortal := False;
    HeroChosen := False;
    HP := START_HP;
    RoadSkillDelay := 0;
    FieldSkillDelay := 0;
    WineSkillDelay := 0;
    Direction := 6;
    TribuneX := 66;
    TribuneY := 2;
    HeroImmortalTime := 0;
    HeroStunnedTime := 0;
    HeroStunned := False;
    HeroInFearTime := 0;
    HeroInFear := False;
    ZombiePlayer := 11;
    RoadPlayer := 9;
    DefenceTime := 0;
    HeroPrisoned := False;
    HeroPrisonedTime := 0;
    WerewolfTime := 0;
    VagaX := 0;
    VagaY := 0;
    VagaAppearTime := 0;
    VagaDir := 0;
    RegenDelay := 0;
    ClearPikeObjTime := 0;
    GravityX := 0;
    GravityY := 0;
    RespawnCheckTime := -1;
    DDTime := 0;
    DD := False;
    InIllusion := False;
    PlayersTeam := 1;
    CastingSkill := False;
    SkillTime := 0;
    SkillCastX := 0;
    SkillCastY := 0;
    SkillCastDir := 0;
    SkillCastRespawnTime := 0;
    ArmorStartTime := 0;
    HeroSilent := False;
    HeroSilentTime := 0;
    HeroSilentStartTime := 0;
    AIChoiceTime := 10 + States.KaMRandomI(100) + States.KaMRandomI(200);
    RopeUnitDir := -1;
    RopeAttacker := -1;
    RopeTime := -1;
    RopeDX := -1;
    RopeDY := -1;
    Preparing := False;
    PreparingTime := 0;
    ReCharge := False;
    ReChargeTime := 0;
    LastUsedSkill := sNone;
    StolenSkill := sNone;
    StolenSkillName := '<$57>';
    TempHeroType := -1;
    StolenSkillTime := 0;
    Stone := MAX_SCOUT_STONES;
    CaptureMind := False;
    CaptureMindTime := 0;
    MindStunned := False;
    HeroMindType := -1;
    TempHeroMindType := -1;
    StoneRogue := False;
  end;

  with Players[7] do
  begin
    SpawnX := 52;
    SpawnY := 52;
    Hero := -1;
    HeroType := -1;
    HeroImmortal := False;
    HeroChosen := False;
    HP := START_HP;
    RoadSkillDelay := 0;
    FieldSkillDelay := 0;
    WineSkillDelay := 0;
    Direction := 6;
    TribuneX := 68;
    TribuneY := 2;
    HeroImmortalTime := 0;
    HeroStunnedTime := 0;
    HeroStunned := False;
    HeroInFearTime := 0;
    HeroInFear := False;
    ZombiePlayer := 11;
    RoadPlayer := 9;
    DefenceTime := 0;
    HeroPrisoned := False;
    HeroPrisonedTime := 0;
    WerewolfTime := 0;
    VagaX := 0;
    VagaY := 0;
    VagaAppearTime := 0;
    VagaDir := 0;
    RegenDelay := 0;
    ClearPikeObjTime := 0;
    GravityX := 0;
    GravityY := 0;
    RespawnCheckTime := -1;
    DDTime := 0;
    DD := False;
    InIllusion := False;
    PlayersTeam := 1;
    CastingSkill := False;
    SkillTime := 0;
    SkillCastX := 0;
    SkillCastY := 0;
    SkillCastDir := 0;
    SkillCastRespawnTime := 0;
    ArmorStartTime := 0;
    HeroSilent := False;
    HeroSilentTime := 0;
    HeroSilentStartTime := 0;
    AIChoiceTime := 10 + States.KaMRandomI(100) + States.KaMRandomI(200);
    RopeUnitDir := -1;
    RopeAttacker := -1;
    RopeTime := -1;
    RopeDX := -1;
    RopeDY := -1;
    Preparing := False;
    PreparingTime := 0;
    ReCharge := False;
    ReChargeTime := 0;
    LastUsedSkill := sNone;
    StolenSkill := sNone;
    StolenSkillName := '<$57>';
    TempHeroType := -1;
    StolenSkillTime := 0;
    Stone := MAX_SCOUT_STONES;
    CaptureMind := False;
    CaptureMindTime := 0;
    MindStunned := False;
    HeroMindType := -1;
    TempHeroMindType := -1;
    StoneRogue := False;
  end;

end;


function RuneType: Integer;
begin
  case States.KaMRandomI(10) of
    0..2: Result := RUNE_REGEN_OBJ;
    //1:  Result := RUNE_DOUBLE_OBJ;
    3,4:  Result := RUNE_ILLUSION_OBJ;
    5..7: Result := RUNE_IMMORTAL_OBJ;
    8,9:  Result := RUNE_RECHARGE_OBJ;
  end;
end;


procedure GoOutFromRune;
begin
  for I := 0 to 7 do
  begin
    if Players[I].Hero > 0 then
      if States.GroupMember(Players[I].Hero, 0) > 0 then
        if (States.UnitPositionX(States.GroupMember(Players[I].Hero, 0)) = RUNE_X)
        and (States.UnitPositionY(States.GroupMember(Players[I].Hero, 0)) = RUNE_Y) then
          if States.GroupIdle(Players[I].Hero) then

          case States.KaMRandomI(4) of

            0: begin

                 if (States.UnitAt(RUNE_X, RUNE_Y - 1) = -1) then
                   Actions.GroupOrderWalk(Players[I].Hero, RUNE_X, RUNE_Y - 2, 0)

                 else

                 if (States.UnitAt(RUNE_X, RUNE_Y + 1) = -1) then
                   Actions.GroupOrderWalk(Players[I].Hero, RUNE_X, RUNE_Y + 2, 4)

                 else

                 if (States.UnitAt(RUNE_X - 1, RUNE_Y) = -1) then
                   Actions.GroupOrderWalk(Players[I].Hero, RUNE_X - 2, RUNE_Y, 6)

                 else

                 if (States.UnitAt(RUNE_X + 1, RUNE_Y) = -1) then
                   Actions.GroupOrderWalk(Players[I].Hero, RUNE_X + 2, RUNE_Y, 2);

               end;

            1: begin

                 if (States.UnitAt(RUNE_X, RUNE_Y + 1) = -1) then
                   Actions.GroupOrderWalk(Players[I].Hero, RUNE_X, RUNE_Y + 2, 4)

                 else

                 if (States.UnitAt(RUNE_X, RUNE_Y - 1) = -1) then
                   Actions.GroupOrderWalk(Players[I].Hero, RUNE_X, RUNE_Y - 2, 0)

                 else

                 if (States.UnitAt(RUNE_X - 1, RUNE_Y) = -1) then
                   Actions.GroupOrderWalk(Players[I].Hero, RUNE_X - 2, RUNE_Y, 6)

                 else

                 if (States.UnitAt(RUNE_X + 1, RUNE_Y) = -1) then
                   Actions.GroupOrderWalk(Players[I].Hero, RUNE_X + 2, RUNE_Y, 2);

               end;

            2: begin

                 if (States.UnitAt(RUNE_X - 1, RUNE_Y) = -1) then
                   Actions.GroupOrderWalk(Players[I].Hero, RUNE_X - 2, RUNE_Y, 6)

                 else

                 if (States.UnitAt(RUNE_X, RUNE_Y - 1) = -1) then
                   Actions.GroupOrderWalk(Players[I].Hero, RUNE_X, RUNE_Y - 2, 0)

                 else

                 if (States.UnitAt(RUNE_X, RUNE_Y + 1) = -1) then
                   Actions.GroupOrderWalk(Players[I].Hero, RUNE_X, RUNE_Y + 2, 4)

                 else

                 if (States.UnitAt(RUNE_X + 1, RUNE_Y) = -1) then
                   Actions.GroupOrderWalk(Players[I].Hero, RUNE_X + 2, RUNE_Y, 2);

               end;

            3: begin

                 if (States.UnitAt(RUNE_X + 1, RUNE_Y) = -1) then
                   Actions.GroupOrderWalk(Players[I].Hero, RUNE_X + 2, RUNE_Y, 2)

                 else

                 if (States.UnitAt(RUNE_X, RUNE_Y - 1) = -1) then
                   Actions.GroupOrderWalk(Players[I].Hero, RUNE_X, RUNE_Y - 2, 0)

                 else

                 if (States.UnitAt(RUNE_X, RUNE_Y + 1) = -1) then
                   Actions.GroupOrderWalk(Players[I].Hero, RUNE_X, RUNE_Y + 2, 4)

                 else

                 if (States.UnitAt(RUNE_X - 1, RUNE_Y) = -1) then
                   Actions.GroupOrderWalk(Players[I].Hero, RUNE_X - 2, RUNE_Y, 6);

               end;

          end;
  end;
end;


procedure CheckRuneTime;
begin
  if RuneTime > 0 then
    RuneTime := RuneTime - 1;
  if RuneTime = 0 then
  begin
    if States.KaMRandomI(10) > 4 then
      RUNE_Y := RUNE_Y1
    else
      RUNE_Y := RUNE_Y2;
    Actions.MapTileObjectSet(RUNE_X, RUNE_Y1, RUNE_BLOCK_OBJ);
    Actions.MapTileObjectSet(RUNE_X, RUNE_Y2, RUNE_BLOCK_OBJ);
    Actions.MapTileObjectSet(RUNE_X, RUNE_Y, RuneType);
    RuneTime := RUNE_TIMER;
  end;
end;


procedure CheckStolenSkillTime(P: Integer);
begin
  if Players[P].StolenSkillTime = 0 then
  begin
    Players[P].StolenSkill := sNone;
    Players[P].StolenSkillName := '<$57>';
  end;

  if Players[P].StolenSkillTime > 0 then
    Players[P].StolenSkillTime := Players[P].StolenSkillTime - 1;
end;


function RogueStatus(P: Integer): ANSIString;
begin

  if Players[P].HeroType <> 25 then
    Result := ''

  else

  begin

  if Players[P].StolenSkillTime > 0 then
    Result := '|[$56BAC2]<$59>[] ([$EBAEBA]' + Players[P].StolenSkillName + '[]) [$56BAC2]<$60>[] ' + IntToStr(Players[P].StolenSkillTime/10) + '[$56BAC2]. |<$61>[]'

  else

    Result := '';

  end;

end;


function DDStatus(P: Integer): ANSIString;
begin
  if Players[P].DDTime - States.GameTime > 0 then
    Result := '|[$A67F10]<$44>[] (' + IntToStr((Players[P].DDTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function IllusionStatus(P: Integer): ANSIString;
begin
  if Players[P].InIllusion then
    Result := '|[$FCA986]<$43>[]'

  else

    Result := '';
end;


function RegenStatus(P: Integer): ANSIString;
begin
  if Players[P].RegenDelay - States.GameTime > 0 then
    Result := '|[$25FF10]<$1>[] (<$7> ' + IntToStr((Players[P].RegenDelay - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function StunnedStatus(P: Integer): ANSIString;
begin
  if Players[P].HeroStunned then
    Result := '|[$19A5DF]<$2>[] (' + IntToStr((Players[P].HeroStunnedTime - States.GameTime)/10) + ')'

  else

    Result := '';

  if Players[P].Preparing then
    Result := '';

end;


function FearStatus(P: Integer): ANSIString;
begin
  if Players[P].HeroInFear then
    Result := '|[$52AADF]<$3>[] (' + IntToStr((Players[P].HeroInFearTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function ImmortalStatus(P: Integer): ANSIString;
begin
  if Players[P].HeroImmortal then
    Result := '|[$1515DF]<$5>[] (' + IntToStr((Players[P].HeroImmortalTime - States.GameTime)/10) + ')'

  else

    Result := '';

  if Players[P].Preparing then
    Result := '';

end;


function PrisonedStatus(P: Integer): ANSIString;
begin
  if Players[P].HeroPrisoned then
    Result := '|[$51AFEE]<$4>[]'

  else

    Result := '';
end;


function WerewolfStatus(P: Integer): ANSIString;
begin
  if Players[P].WerewolfTime > States.GameTime then
    Result := '|[$5A6FAE]<$6>[] (' + IntToStr((Players[P].WerewolfTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function SilenceStatus(P: Integer): ANSIString;
begin
  if Players[P].HeroSilent then
    Result := '|[$BEBEAA]<$49>[] (' + IntToStr((Players[P].HeroSilentTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function PreparingStatus(P: Integer): ANSIString;
begin
  if Players[P].Preparing then
    Result := '|[$FAC667]<$53>[] (' + IntToStr((Players[P].PreparingTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function ReChargeStatus(P: Integer): ANSIString;
begin
  if Players[P].ReCharge then
    Result := '|[$746CCC]<$54>[] (' + IntToStr((Players[P].ReChargeTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function MindStatus(P: Integer): ANSIString;
begin
  if Players[P].CaptureMind then
    Result := '|[$51AFEE]<$104>[](' + IntToStr((Players[P].CaptureMindTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function MindStunnedStatus(P: Integer): ANSIString;
begin
  if Players[P].MindStunned then
    Result := '|[$51AFEE]<$103>[](' + IntToStr((Players[P].CaptureMindTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function StatusText(P: Integer): ANSIString;
begin
  Result := ImmortalStatus(P) + StunnedStatus(P) + FearStatus(P) + PrisonedStatus(P) + WerewolfStatus(P)
  + RegenStatus(P) + DDStatus(P) {+ IllusionStatus(P)} + SilenceStatus(P) + PreparingStatus(P)
  + ReChargeStatus(P) + RogueStatus(P) + MindStatus(P) + MindStunnedStatus(P);
end;


function HPColor(P: Integer): ANSIString;
begin
  case Players[P].HP of
    9..20: Result := '[$00FF00]';
    7..8:  Result := '[$32CD9B]';
    5..6:  Result := '[$00FFFF]';
    3..4:  Result := '[$008CFF]';
    0..2:  Result := '[$0050FF]';
  end;
end;


procedure CheckDelays(P: Integer);
begin

  if Players[P].RoadSkillDelay > 0 then
    Players[P].RoadSkillDelay := Players[P].RoadSkillDelay - 1;

  if Players[P].FieldSkillDelay > 0 then
    Players[P].FieldSkillDelay := Players[P].FieldSkillDelay - 1;

  if Players[P].WineSkillDelay > 0 then
    Players[P].WineSkillDelay := Players[P].WineSkillDelay - 1;

end;


function CanUseWineFieldSkill(X, Y: Integer): Boolean;
begin
  Result := False;
  if X <= 0 then
    Exit;
  if Y <= 0 then
    Exit;
  if TileOnBattlefield(X, Y) then 
    Result := (States.MapTileType(X, Y) <> 197)
    and (States.MapTileType(X, Y) <> 202)
    and (States.MapTileType(X, Y) <> 206)
    and (States.MapTileType(X, Y) <> 207)
    and (States.MapTileType(X, Y) <> 215)
    and (States.MapTileType(X, Y) <> 223)
    and (States.MapTileType(X, Y) <> 152)
    and (not States.IsRoadAt(8, X, Y));
end;


function CanPlaceMine(aP, aX, aY: Integer): Boolean;
var
  D: Integer;
begin
  D := States.UnitDirection(States.GroupMember(Players[aP].Hero, 0));

  Result := False;
  if aX <= 0 then
    Exit;
  if aY <= 0 then
    Exit;

  if TileOnBattlefield(aX, aY) then
    Result := (((InRange(D, 0, 1)) and (TileOnBattlefield(aX, aY - 1)) and (not States.IsRoadAt(8, aX, aY - 1))
              and (States.MapTileType(aX, aY - 1) <> 223) and (States.MapTileType(aX, aY - 1) <> 202)
              and (States.MapTileObject(aX, aY - 1) <> BOWMAN_MINE) and (States.MapTileObject(aX, aY - 1) <> BOWMAN_OBJECT5)
              and (States.MapTileObject(aX, aY - 1) <> BARB_OBJECT3) and (States.MapTileObject(aX, aY - 1) <> WARRIOR_OBJECT5))

              or ((InRange(D, 2, 3)) and (TileOnBattlefield(aX + 1, aY)) and (not States.IsRoadAt(8, aX + 1, aY))
              and (States.MapTileType(aX + 1, aY) <> 223) and (States.MapTileType(aX + 1, aY) <> 202)
              and (States.MapTileObject(aX + 1, aY) <> BOWMAN_MINE) and (States.MapTileObject(aX + 1, aY) <> BOWMAN_OBJECT5)
              and (States.MapTileObject(aX + 1, aY) <> BARB_OBJECT3) and (States.MapTileObject(aX + 1, aY) <> WARRIOR_OBJECT5))

              or ((InRange(D, 4, 5)) and (TileOnBattlefield(aX, aY + 1)) and (not States.IsRoadAt(8, aX, aY + 1))
              and (States.MapTileType(aX, aY + 1) <> 223) and (States.MapTileType(aX, aY + 1) <> 202)
              and (States.MapTileObject(aX, aY + 1) <> BOWMAN_MINE) and (States.MapTileObject(aX, aY + 1) <> BOWMAN_OBJECT5)
              and (States.MapTileObject(aX, aY + 1) <> BARB_OBJECT3) and (States.MapTileObject(aX, aY + 1) <> WARRIOR_OBJECT5))

              or ((InRange(D, 6, 7)) and (TileOnBattlefield(aX - 1, aY)) and (not States.IsRoadAt(8, aX - 1, aY))
              and (States.MapTileType(aX - 1, aY) <> 223) and (States.MapTileType(aX - 1, aY) <> 202)
              and (States.MapTileObject(aX - 1, aY) <> BOWMAN_MINE) and (States.MapTileObject(aX - 1, aY) <> BOWMAN_OBJECT5)
              and (States.MapTileObject(aX - 1, aY) <> BARB_OBJECT3) and (States.MapTileObject(aX - 1, aY) <> WARRIOR_OBJECT5)));
end;


function RoadSkillName(P, UT: Integer): ANSIString;
begin
  case UT of
    15: Result := '[$4C818B]<$8>[]';
    16: Result := '[$2222B2]<$9>[]';
    17: Result := '[$0000FF]<$10>[]';
    18: Result := '[$00A5FF]<$11>[]';
    19: Result := '[$4782FF]<$12>[]';
    20: Result := '[$B8B8B8]<$13>[]';
    21: Result := '[$FFFFFF]<$99> []<$100> []' + IntToStr(Players[P].Stone) + ')[]';
    22: Result := '[$634BBA]<$50>[]';
    23: Result := '[$499AEE]<$14>[]';
    26: Result := '[$0022FF]<$46>[]';
    27: Result := '[$FF7648]<$15>[]';
    25: Result := '[$ADF346]<$55>[]';
  end;
end;


function FieldSkillName(P, UT: Integer): ANSIString;
begin
  case UT of
    15: Result := '[$00A5FF]<$16>[]';
    16: Result := '[$578B2E]<$17>[]';
    17: Result := '[$8B668B]<$18>[]';
    18: Result := '[$0045FF]<$19>[]';
    19: Result := '[$FFFF97]<$20>[]';
    20: Result := '[$00008B]<$21>[]';
    21: Result := '[$FFFFFF]<$101>[]';
    22: Result := '[$902F9D]<$51>[]';
    23: Result := '[$4040FF]<$22>[]';
    26: Result := '[$528AAF]<$47>[]';
    27: Result := '[$00CDCD]<$23>[]';
    25: Result := '[$CC7854]<$56>[]';
  end;
end;


function WineSkillName(P, UT: Integer): ANSIString;
begin
  case UT of
    15: Result := '[$26368B]<$24>[]';
    16: Result := '[$8B008B]<$25>[]';
    17: Result := '[$00FFFF]<$26>[]';
    18: Result := '[$D30094]<$27>[]';
    19: Result := '[$00C7FF]<$28>[]';
    20: Result := '[$006400]<$29>[]';
    21: Result := '[$FFFFFF]<$102>[]';
    22: Result := '[$2580CE]<$52>[]';
    23: Result := '[$EE677A]<$30>[]';
    26: Result := '[$1707A6]<$48>[]';
    27: Result := '[$00FC7C]<$31>[]';
    25: begin
        if Players[P].StolenSkillName = '<$99>' then
          Result := '[$FFFFFF]<$99> []<$100> []' + IntToStr(Players[P].Stone) + ')[]';
        if Players[P].StolenSkillName <> '<$99>' then
          Result := '[$AE209F]' + Players[P].StolenSkillName + '[]';
        end;
  end;
end;


function HeroDescription(P, UT: Integer): ANSIString;
begin
  case UT of
    15:  Result := '<$207>';
    16:  Result := '<$204>';
    17:  Result := '<$205>';
    18:  Result := '<$203>';
    19:  Result := '<$201>';
    20:  Result := '<$206>';
    21:  Result := '<$211>';
    22:  Result := '<$209>';
    23:  Result := '<$202>';
    25:  Result := '<$210>';
    26:  Result := '<$208>'
    else Result := '';
  end;
end;


procedure SetCircle(P, X, Y, R, aObj: Integer; aDef, aSaveCracking, aNone: Boolean);
var
  X1, X2, Y1, Y2, PosX, PosY: Integer;
begin
  X1 := X - R;
  X2 := X + R;
  Y1 := Y - R;
  Y2 := Y + R;
  for PosX := X1 to X2 do
  for PosY := Y1 to Y2 do
  begin
    if (((X - PosX) * (X - PosX) + (Y - PosY) * (Y - PosY)) <= R * R) then
      if TileOnBattlefield(PosX, PosY)
      and (PosX > 0)
      and (PosY > 0)
      and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT3)
      and (States.MapTileObject(PosX, PosY) <> SWORD_OBJECT)
      and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT)
      and (States.MapTileObject(PosX, PosY) <> BOWMAN_MINE)
      and (States.MapTileObject(PosX, PosY) <> BOWMAN_OBJECT5)
      and (States.MapTileObject(PosX, PosY) <> WARRIOR_OBJECT5)
      and (States.MapTileObject(PosX, PosY) <> ROGUE_OBJECT4)
      and (not InRange(States.MapTileObject(PosX, PosY), SWORD_OBJECT1, VAGA_OBJECT6)) then
        Actions.MapTileObjectSet(PosX, PosY, aObj);
      if not aSaveCracking then
        if States.MapTileObject(PosX, PosY) = BARB_OBJECT then
          Actions.MapTileObjectSet(PosX, PosY, aObj);
  end;

  if aDef then
  begin
    Players[P].DefenceTime := States.GameTime + CIRCLE_DEF_TIME;
    for PosX := X1 to X2 do
    for PosY := Y1 to Y2 do
    begin
      if (((X - PosX) * (X - PosX) + (Y - PosY) * (Y - PosY)) <= ((R - 1) * (R - 1))) then
        if TileOnBattlefield(PosX, PosY)
        and (PosX > 0)
        and (PosY > 0)
        and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT3)
        and (States.MapTileObject(PosX, PosY) <> SWORD_OBJECT)
        and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT)
        and (States.MapTileObject(PosX, PosY) <> BOWMAN_MINE)
        and (States.MapTileObject(PosX, PosY) <> BOWMAN_OBJECT5)
        and (States.MapTileObject(PosX, PosY) <> WARRIOR_OBJECT5)
        and (States.MapTileObject(PosX, PosY) <> ROGUE_OBJECT4)
        and (not InRange(States.MapTileObject(PosX, PosY), SWORD_OBJECT1, VAGA_OBJECT6)) then
          Actions.MapTileObjectSet(PosX, PosY, SOSObjects[P]);
        if not aSaveCracking then
          if States.MapTileObject(PosX, PosY) = BARB_OBJECT then
            Actions.MapTileObjectSet(PosX, PosY, SOSObjects[P]);
    end;
  end;

  if aObj = BARB_OBJECT2 then
    if InRange(States.MapTileObject(PosX, PosY), SOS_OBJECT, SOS_OBJECT8) then
      Actions.MapTileObjectSet(PosX, PosY, SOSObjects[P]);

  if aObj = PikeObjects[P] then
    Players[P].ClearPikeObjTime := States.GameTime + 20;

  if not aDef then
  begin
    for PosX := X1 to X2 do
    for PosY := Y1 to Y2 do
    begin
      if (((X - PosX) * (X - PosX) + (Y - PosY) * (Y - PosY)) <= ((R - 1) * (R - 1))) then
        if TileOnBattlefield(PosX, PosY)
        and (PosX > 0)
        and (PosY > 0)
        and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT3)
        and (States.MapTileObject(PosX, PosY) <> SWORD_OBJECT)
        and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT)
        and (States.MapTileObject(PosX, PosY) <> BOWMAN_MINE)
        and (States.MapTileObject(PosX, PosY) <> BOWMAN_OBJECT5)
        and (States.MapTileObject(PosX, PosY) <> WARRIOR_OBJECT5)
        and (States.MapTileObject(PosX, PosY) <> ROGUE_OBJECT4)
        and (not InRange(States.MapTileObject(PosX, PosY), SWORD_OBJECT1, VAGA_OBJECT6)) then
          Actions.MapTileObjectSet(PosX, PosY, 255);
        if not aSaveCracking then
          if States.MapTileObject(PosX, PosY) = BARB_OBJECT then
            Actions.MapTileObjectSet(PosX, PosY, 255);
    end;
  end;

end;


procedure OnBeacon(P, X, Y: Integer);
begin
  if not DEBUG_MODE then
    Exit;
  if States.UnitAt(X, Y) = -1 then
    Exit;
  if States.GameTime > CHOOSE_HERO_TIMER then
    Exit;

  if InRange(X, 1, 11) then
    for I := 0 to 3 do
      if States.PlayerEnabled(I) then
        if States.PlayerIsAI(I) then
        begin
          Players[I].HeroType := States.UnitType(States.UnitAt(X, Y));
          Players[I].HeroChosen := True;
        end;

  if InRange(X, 60, 70) then
    for I := 4 to 7 do
      if States.PlayerEnabled(I) then
        if States.PlayerIsAI(I) then
        begin
          Players[I].HeroType := States.UnitType(States.UnitAt(X, Y));
          Players[I].HeroChosen := True;
        end;
end;


//Heroes & Skills


//SWORD FIGHTER


procedure SpikedEarth(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 10;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;

    for I := 1 to 4 do    
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := SWORD_OBJECT;
    
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 9;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 11;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 13;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 15;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 1;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 3;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 5;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 7;

    for I := 1 to 4 do
      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_MINE)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
         ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 9 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 45 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 10 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
             end;

      2,3: for X1 := X2 + 2 to X2 + 9 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 45 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 10 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 9 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 45 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 10 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
             end;

      6,7: for X1 := X2 - 2 downto X2 - 9 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 45 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 10 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
    end;

    Players[P].LastUsedSkill := sSpikedEarth;

    Players[P].RoadSkillDelay := Round(SWORD_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := States.GameTime + Round(SWORD_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

  end;
end;


procedure ZombieSummon(P, X, Y: Integer);
var
  X2, Y2, Zombie: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (States.StatArmyCount(Players[P].ZombiePlayer) < MAX_MILIZOMBIE)
  and (Players[P].ZombiePlayer <> - 1) 
  and (TileOnBattlefield(X, Y)) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= MILIZOMBIE_RADIUS)
    and (Abs(Y2 - Y) <= MILIZOMBIE_RADIUS) then
    begin
      Zombie := Actions.GiveGroup(Players[P].ZombiePlayer, 14, X, Y, States.KaMRandomI(8), 1, 1);
      Actions.GroupHungerSet(Zombie, RUNE_ZOMBIE_LIFE);
      Players[P].FieldSkillDelay := Round(SWORD_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      Players[P].LastUsedSkill := sZombieSummon;
    end;
  end;

end;


procedure Fear(P, X, Y: Integer);
var
 X2, Y2, U, O: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= IN_FEAR_RADIUS)
    and (Abs(Y2 - Y) <= IN_FEAR_RADIUS) then
    begin
      U := States.UnitAt(X, Y);
      if U <> - 1 then
        O := States.UnitOwner(U);
      if (U <> - 1)
      and (U = States.GroupMember(Players[O].Hero, 0))
      and (not Players[O].HeroInFear)
      and (O <> P)
      and (Players[P].PlayersTeam <> Players[O].PlayersTeam) then
      begin
        Players[O].HeroInFear := True;
        Players[O].HeroInFearTime := States.GameTime + IN_FEAR_TIME;
        if Players[O].Hero > 0 then
          Actions.GroupBlockOrders(Players[O].Hero, True);
        Players[P].LastUsedSkill := sFear;
        Players[P].WineSkillDelay := Round(SWORD_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      end;
    end;
  end;

end;


//BARBARIAN


procedure CrackingEarth(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 20;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;

    for I := 1 to 4 do
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := BARB_OBJECT;

    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 16;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 17;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 18;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 19;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 1;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 3;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4;

    for I := 1 to 4 do
      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_MINE)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
         ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 9 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 73 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BARB_OBJECT;
             end;

      2,3: for X1 := X2 + 2 to X2 + 9 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 73 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BARB_OBJECT;
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 9 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 73 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BARB_OBJECT;
             end;

      6,7: for X1 := X2 - 2 downto X2 - 9 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 73 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BARB_OBJECT;
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := -1;
    end;

    Players[P].LastUsedSkill := sCrackingEarth;

    Players[P].RoadSkillDelay := Round(BARB_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := States.GameTime + Round(BARB_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

  end;

end;


procedure WaveOfRage(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    RageCirclesLength[P] := RageCirclesLength[P] + RAGE_CYCLES * RAGE_RADIUS;
    SetLength(RageCircles[P], RageCirclesLength[P]);

    for I := RageCirclesLength[P] downto RageCirclesLength[P] - RAGE_CYCLES * RAGE_RADIUS + 1 do
    begin
      RageCircles[P][RageCirclesLength[P] - I].Obj := BARB_OBJECT2;
      RageCircles[P][RageCirclesLength[P] - I].X := X2;
      RageCircles[P][RageCirclesLength[P] - I].Y := Y2;
      RageCircles[P][RageCirclesLength[P] - I].AddTime := States.GameTime + Round(BARB_FIELD_SPEED * (RageCirclesLength[P] - I));
      if I mod RAGE_RADIUS > 0 then
        RageCircles[P][RageCirclesLength[P] - I].Radius := RAGE_RADIUS + 2 - I mod RAGE_RADIUS
      else
        RageCircles[P][RageCirclesLength[P] - I].Radius := 1;
    end; 
       
    for I := 0 to RageCirclesLength[P] - 1 do 
      if I mod RAGE_RADIUS = 1 then
        RageCircles[P][RageCirclesLength[P] - I].Obj := 255;

    Players[P].LastUsedSkill := sWaveOfRage;

    Players[P].FieldSkillDelay := Round(BARB_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    TimeToClearRageArray[P] := States.GameTime + 100;

  end;

end;


procedure TotemOfAncestors(P, X, Y: Integer);
var
  X2, Y2, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0)
  and not (InRange(States.MapTileObject(X, Y), SWORD_OBJECT, VAGA_OBJECT6))
  and not (InRange(States.MapTileObject(X, Y), SOS_OBJECT, SOS_OBJECT8)) then
  begin
    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 37;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= TOTEM_ADD_RADIUS)
    and (Abs(Y2 - Y) <= TOTEM_ADD_RADIUS) then
    begin
      if States.MapTileObject(X, Y) = BOWMAN_MINE then
      begin
        if InRange(Roads[X][Y].Owner, 8, 11) then
          Actions.PlanRemove(Roads[X][Y].Owner, X, Y);
        Actions.MapTileObjectSet(X, Y, 255);
        Roads[X][Y].Owner := -1;
      end;

      TotemCirclesLength[P] := TotemCirclesLength[P] + TOTEM_CYCLES * TOTEM_RADIUS;
      SetLength(TotemCircles[P], TotemCirclesLength[P]);
      TilesWineLength[P] := TilesWineLength[P] + 9;
      SetLength(TilesWineX[P], TilesWineLength[P]);
      SetLength(TilesWineY[P], TilesWineLength[P]);
      SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
      SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
      SetLength(TilesWineObjects[P], TilesWineLength[P]);

      TilesWineX[P][Length(TilesWineX[P]) - 1] := X;
      TilesWineY[P][Length(TilesWineY[P]) - 1] := Y;

      TilesWineX[P][Length(TilesWineX[P]) - 9] := X2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 9] := Y2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2 + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 7] := X2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 6] := X2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 5] := X2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2;
      TilesWineX[P][Length(TilesWineX[P]) - 4] := X2;
      TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2;
      TilesWineX[P][Length(TilesWineX[P]) - 2] := X2;
      TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;

      for I := 2 to 9 do
        TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := BARB_OBJECT5;

      TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := BARB_OBJECT3;

      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 36;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 110;

      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 9] := States.GameTime + 10;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 9] := States.GameTime + 30;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 10;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 30;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 10;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 30;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 10;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 30;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 16;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 36;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 16;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 36;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 16;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 36;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 16;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 36;

      for I := 1 to 9 do
        if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_MINE)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
          ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

      for I := TotemCirclesLength[P] downto TotemCirclesLength[P] - TOTEM_CYCLES * TOTEM_RADIUS + 1 do
      begin
        TotemCircles[P][TotemCirclesLength[P] - I].Obj := BARB_OBJECT4;
        TotemCircles[P][TotemCirclesLength[P] - I].X := X;
        TotemCircles[P][TotemCirclesLength[P] - I].Y := Y;
        TotemCircles[P][TotemCirclesLength[P] - I].AddTime := States.GameTime + 39 + Round((TotemCirclesLength[P] - I) / BARB_WINE_SPEED);
        if I mod TOTEM_RADIUS > 0 then
          TotemCircles[P][TotemCirclesLength[P] - I].Radius := TOTEM_RADIUS + 1 - I mod TOTEM_RADIUS
        else
          TotemCircles[P][TotemCirclesLength[P] - I].Radius := 1;
        end;
        
      for I := 0 to TotemCirclesLength[P] - 1 do 
        if I mod TOTEM_RADIUS = 1 then
          TotemCircles[P][TotemCirclesLength[P] - I].Obj := 255;

      if States.PlayerIsAI(P) then
      begin
        Players[P].SkillCastDir := Direction;
        Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
        Players[P].SkillCastX := X2;
        Players[P].SkillCastY := Y2;
        Actions.GroupKillAll(Players[P].Hero, True);
        Players[P].Hero := -1;
      end;

      Players[P].LastUsedSkill := sTotem;

      Players[P].WineSkillDelay := Round(BARB_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

      TimeToClearTotemArray[P] := States.GameTime + 120;

      ClearWineTilesArrayTime[P] := States.GameTime + Round(BARB_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

    end;

  end;

end;



//LANCE CARRIER


procedure FieryLance(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 29;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;
    TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 4] := LANCE_OBJECT;
    TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 3] := LANCE_OBJECT;
    TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 2] := LANCE_OBJECT2;
    TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := LANCE_OBJECT2;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 19;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 22;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 25;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 28;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 5;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 8;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 11;

    for I := 1 to 4 do
      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_MINE)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
         ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 11 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 29 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := LANCE_OBJECT;
             end;

      2,3: for X1 := X2 + 2 to X2 + 11 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 29 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := LANCE_OBJECT;
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 11 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 29 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := LANCE_OBJECT;
             end;

      6,7: for X1 := X2 - 2 downto X2 - 11 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 29 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := LANCE_OBJECT;
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := -1;
    end;

    Players[P].LastUsedSkill := sFieryLance;

    Players[P].RoadSkillDelay := Round(LANCE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := States.GameTime + Round(LANCE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

  end;

end;


procedure Teleport(P, X, Y: Integer);
var
  X2, Y2, NewDir: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    NewDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= TELEPORT_RADIUS)
    and (Abs(Y2 - Y) <= TELEPORT_RADIUS) then
    begin
      Players[P].LastUsedSkill := sTeleport;
      Players[P].FieldSkillDelay := Round(LANCE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(P, Players[P].TempHeroType, X, Y, NewDir, 1, 1);
      Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
    end;
  end;

end;


procedure TenThousandsSpears(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 60;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

    TilesWineLength[P] := TilesWineLength[P] + 36;
    SetLength(TilesWineX[P], TilesWineLength[P]);
    SetLength(TilesWineY[P], TilesWineLength[P]);
    SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
    SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
    SetLength(TilesWineObjects[P], TilesWineLength[P]);

    TilesWineX[P][Length(TilesWineX[P]) - 36] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 35] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 34] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 33] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 36] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 35] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 34] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 33] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 32] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 31] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 30] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 29] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 32] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 31] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 30] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 29] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 28] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 27] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 26] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 25] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 28] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 27] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 26] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 25] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 24] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 23] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 22] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 21] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 24] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 23] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 22] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 21] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 20] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 19] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 18] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 17] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 20] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 19] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 18] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 17] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 16] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 15] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 14] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 13] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 16] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 15] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 14] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 13] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 12] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 11] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 10] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 9] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 12] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 11] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 10] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 9] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 7] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 6] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 5] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 3] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 36] := LANCE_OBJECT3;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 35] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 34] := LANCE_OBJECT3;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 33] := LANCE_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 36] := States.GameTime + 70;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 35] := States.GameTime + 71;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 34] := States.GameTime + 72;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 33] := States.GameTime + 73;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 36] := States.GameTime + 33;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 35] := States.GameTime + 34;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 34] := States.GameTime + 35;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 33] := States.GameTime + 36;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 32] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 31] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 30] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 29] := LANCE_OBJECT2;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 32] := States.GameTime + 38;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 31] := States.GameTime + 39;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 30] := States.GameTime + 40;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 29] := States.GameTime + 41;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 32] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 31] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 30] := States.GameTime + 3;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 29] := States.GameTime + 4;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 28] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 27] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 26] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 25] := LANCE_OBJECT2;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 28] := States.GameTime + 42;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 27] := States.GameTime + 43;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 26] := States.GameTime + 44;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 25] := States.GameTime + 45;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 28] := States.GameTime + 5;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 27] := States.GameTime + 6;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 26] := States.GameTime + 7;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 25] := States.GameTime + 8;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 24] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 23] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 22] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 21] := LANCE_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 24] := States.GameTime + 46;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 23] := States.GameTime + 47;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 22] := States.GameTime + 48;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 21] := States.GameTime + 49;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 24] := States.GameTime + 9;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 23] := States.GameTime + 10;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 22] := States.GameTime + 11;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 21] := States.GameTime + 12;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 20] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 19] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 18] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 17] := LANCE_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 20] := States.GameTime + 50;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 19] := States.GameTime + 51;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 18] := States.GameTime + 52;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 17] := States.GameTime + 53;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 20] := States.GameTime + 13;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 19] := States.GameTime + 14;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 18] := States.GameTime + 15;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 17] := States.GameTime + 16;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 16] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 15] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 14] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 13] := LANCE_OBJECT2;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 16] := States.GameTime + 54;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 15] := States.GameTime + 55;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 14] := States.GameTime + 56;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 13] := States.GameTime + 57;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 16] := States.GameTime + 17;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 15] := States.GameTime + 18;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 14] := States.GameTime + 19;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 13] := States.GameTime + 20;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 12] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 11] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 10] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 9] := LANCE_OBJECT2;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 12] := States.GameTime + 58;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 11] := States.GameTime + 59;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 10] := States.GameTime + 60;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 9] := States.GameTime + 61;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 12] := States.GameTime + 21;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 11] := States.GameTime + 22;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 10] := States.GameTime + 23;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 9] := States.GameTime + 24;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 8] := LANCE_OBJECT3;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 7] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 6] := LANCE_OBJECT3;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 5] := LANCE_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 62;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 63;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 64;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 65;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 25;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 26;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 37;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 38;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 4] := LANCE_OBJECT3;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 3] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 2] := LANCE_OBJECT3;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 66;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 67;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 68;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 69;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 29;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 30;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 31;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 32;

    for I := 1 to 36 do
      if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_MINE)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

    case Direction of

      0,1: begin
             for Y1 := Y2 - 2 downto Y2 - 22 do
             for X1 := X2 - 1 to X2 + 1 do
               if TileOnBattlefield(X1, Y1) then
               begin
                 Desync := Desync + 1;
                 TilesWineLength[P] := TilesWineLength[P] + 1;
                 SetLength(TilesWineX[P], TilesWineLength[P]);
                 SetLength(TilesWineY[P], TilesWineLength[P]);
                 SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
                 SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
                 SetLength(TilesWineObjects[P], TilesWineLength[P]);
                 TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
                 TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
                 ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 53 + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                 SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 43 + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                 TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;
               end;
           end;

      2,3: begin
             for X1 := X2 + 2 to X2 + 22 do
             for Y1 := Y2 - 1 to Y2 + 1 do
               if TileOnBattlefield(X1, Y1) then
               begin
                 Desync := Desync + 1;
                 TilesWineLength[P] := TilesWineLength[P] + 1;
                 SetLength(TilesWineX[P], TilesWineLength[P]);
                 SetLength(TilesWineY[P], TilesWineLength[P]);
                 SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
                 SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
                 SetLength(TilesWineObjects[P], TilesWineLength[P]);
                 TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
                 TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
                 ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 53 + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                 SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 43 + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                 TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;
               end;
           end;

      4,5: begin
             for Y1 := Y2 + 2 to Y2 + 22 do
             for X1 := X2 - 1 to X2 + 1 do
               if TileOnBattlefield(X1, Y1) then
               begin
                 Desync := Desync + 1;
                 TilesWineLength[P] := TilesWineLength[P] + 1;
                 SetLength(TilesWineX[P], TilesWineLength[P]);
                 SetLength(TilesWineY[P], TilesWineLength[P]);
                 SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
                 SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
                 SetLength(TilesWineObjects[P], TilesWineLength[P]);
                 TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
                 TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
                 ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 53 + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                 SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 43 + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                 TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;
               end;
           end;

      6,7:  begin
             for X1 := X2 - 2 downto X2 - 22 do
             for Y1 := Y2 - 1 to Y2 + 1 do
               if TileOnBattlefield(X1, Y1) then
               begin
                 Desync := Desync + 1;
                 TilesWineLength[P] := TilesWineLength[P] + 1;
                 SetLength(TilesWineX[P], TilesWineLength[P]);
                 SetLength(TilesWineY[P], TilesWineLength[P]);
                 SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
                 SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
                 SetLength(TilesWineObjects[P], TilesWineLength[P]);
                 TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
                 TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
                 ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 53 + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                 SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 43 + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                 TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;
               end;
           end;
      end;

    case Direction of

      0,1: begin
             for Y1 := Y2 - 2 downto Y2 - 22 do
             for X1 := X2 - 1 to X2 + 1 do
               if TileOnBattlefield(X1, Y1) then
               begin
                 Desync := Desync + 1;
                 TilesWineLength[P] := TilesWineLength[P] + 1;
                 SetLength(TilesWineX[P], TilesWineLength[P]);
                 SetLength(TilesWineY[P], TilesWineLength[P]);
                 SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
                 SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
                 SetLength(TilesWineObjects[P], TilesWineLength[P]);
                 TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
                 TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
                 ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 69 + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                 SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 59 + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                 TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;
               end;
           end;

      2,3: begin
             for X1 := X2 + 2 to X2 + 22 do
             for Y1 := Y2 - 1 to Y2 + 1 do
               if TileOnBattlefield(X1, Y1) then
               begin
                 Desync := Desync + 1;
                 TilesWineLength[P] := TilesWineLength[P] + 1;
                 SetLength(TilesWineX[P], TilesWineLength[P]);
                 SetLength(TilesWineY[P], TilesWineLength[P]);
                 SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
                 SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
                 SetLength(TilesWineObjects[P], TilesWineLength[P]);
                 TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
                 TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
                 ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 69 + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                 SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 59 + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                 TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;
               end;
           end;

      4,5: begin
             for Y1 := Y2 + 2 to Y2 + 22 do
             for X1 := X2 - 1 to X2 + 1 do
               if TileOnBattlefield(X1, Y1) then
               begin
                 Desync := Desync + 1;
                 TilesWineLength[P] := TilesWineLength[P] + 1;
                 SetLength(TilesWineX[P], TilesWineLength[P]);
                 SetLength(TilesWineY[P], TilesWineLength[P]);
                 SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
                 SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
                 SetLength(TilesWineObjects[P], TilesWineLength[P]);
                 TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
                 TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
                 ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 69 + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                 SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 59 + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                 TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;
               end;
           end;

      6,7:  begin
             for X1 := X2 - 2 downto X2 - 22 do
             for Y1 := Y2 - 1 to Y2 + 1 do
               if TileOnBattlefield(X1, Y1) then
               begin
                 Desync := Desync + 1;
                 TilesWineLength[P] := TilesWineLength[P] + 1;
                 SetLength(TilesWineX[P], TilesWineLength[P]);
                 SetLength(TilesWineY[P], TilesWineLength[P]);
                 SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
                 SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
                 SetLength(TilesWineObjects[P], TilesWineLength[P]);
                 TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
                 TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
                 ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 69 + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                 SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 59 + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                 TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;
               end;
           end;
      end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := -1;
    end;

    Players[P].LastUsedSkill := s10kSpears;

    Players[P].WineSkillDelay := Round(LANCE_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearWineTilesArrayTime[P] := States.GameTime + Round(LANCE_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

  end;

end;


//CROSSBOWMAN


procedure AccurateShot(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 14;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;

    for I := 1 to 4 do    
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := XBOW_OBJECT2;
    
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 9;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 10;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 11;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 1;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 3;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 5;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 7;

    for I := 1 to 4 do
      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_MINE)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
         ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 13 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 17 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := XBOW_OBJECT3;
             end;

      2,3: for X1 := X2 + 2 to X2 + 13 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 17 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := XBOW_OBJECT3;
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 13 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 17 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := XBOW_OBJECT3;
             end;

      6,7: for X1 := X2 - 2 downto X2 - 13 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 17 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := XBOW_OBJECT3;
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := -1;
    end;

    Players[P].LastUsedSkill := sAccurateShot;

    Players[P].RoadSkillDelay := Round(XBOW_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := States.GameTime + Round(XBOW_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

  end;

end;


procedure SuddenDeath(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 30;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X2 - X) <= BOMB_RADIUS)
    and (Abs(Y2 - Y) <= BOMB_RADIUS) then
    begin
      TilesFieldLength[P] := TilesFieldLength[P] + 13;
      SetLength(TilesFieldX[P], TilesFieldLength[P]);
      SetLength(TilesFieldY[P], TilesFieldLength[P]);
      SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
      SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
      SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
    
      TilesFieldX[P][Length(TilesFieldX[P]) - 4] := X2 + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 3] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 2] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X2 + 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 4] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 3] := Y2 - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 2] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y2 - 1;

      for I := 1 to 4 do    
        TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := XBOW_OBJECT;
    
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 4] := States.GameTime + 17;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 3] := States.GameTime + 21;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 2] := States.GameTime + 25;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 29;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 4] := States.GameTime + 1;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 3] := States.GameTime + 5;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 2] := States.GameTime + 9;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 13;
        
      TilesFieldX[P][Length(TilesFieldX[P]) - 5] := X;
      TilesFieldY[P][Length(TilesFieldY[P]) - 5] := Y;
      TilesFieldX[P][Length(TilesFieldX[P]) - 6] := X;
      TilesFieldY[P][Length(TilesFieldY[P]) - 6] := Y - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 7] := X;
      TilesFieldY[P][Length(TilesFieldY[P]) - 7] := Y + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 8] := X - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 8] := Y;
      TilesFieldX[P][Length(TilesFieldX[P]) - 9] := X + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 9] := Y;
      TilesFieldX[P][Length(TilesFieldX[P]) - 10] := X + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 10] := Y + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 11] := X + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 11] := Y - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 12] := X - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 12] := Y + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 13] := X - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 13] := Y - 1;

      for I := 5 to 13 do
        TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := XBOW_OBJECT3;

      for I := 10 to 13 do
      begin
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := States.GameTime + 64;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - I] := States.GameTime + 34;
      end;

      for I := 6 to 9 do
      begin
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := States.GameTime + 62;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - I] := States.GameTime + 32;
      end;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 5] := States.GameTime + 60;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 5] := States.GameTime + 30;

      for I := 1 to 13 do
        if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_MINE)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
          ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] + CLEANUP_TIME;

      Players[P].LastUsedSkill := sSuddenDeath;

      Players[P].FieldSkillDelay := Round(XBOW_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    end;

    if States.PlayerIsAI(P) then
    begin
      Players[P].SkillCastDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := -1;
    end;

    ClearFieldTilesArrayTime[P] := States.GameTime + Round(XBOW_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

  end;

end;


procedure SniperShot(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 21;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

    TilesWineLength[P] := TilesWineLength[P] + 8;
    SetLength(TilesWineX[P], TilesWineLength[P]);
    SetLength(TilesWineY[P], TilesWineLength[P]);
    SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
    SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
    SetLength(TilesWineObjects[P], TilesWineLength[P]);

    TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 7] := X2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2 + 1; 
    
    TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2;
    TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2;
    TilesWineX[P][Length(TilesWineX[P]) - 6] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 5] := X2; 
    
    TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 + 1;
    
    TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2 - 1;

    for I := 5 to 8 do
      TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := XBOW_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 13;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 14;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 15;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 16;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 3;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 4;
    
    for I := 1 to 4 do
      TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := XBOW_OBJECT2;
    
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 17;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 18;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 19;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 20;
    
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 5;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 6;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 7;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 8;

    for I := 1 to 8 do
      if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_MINE)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 48 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 24 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := XBOW_OBJECT3;
             end;

      2,3: for X1 := X2 + 2 to X2 + 48 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 24 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := XBOW_OBJECT3;
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 48 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 24 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := XBOW_OBJECT3;
             end;

      6,7: for X1 := X2 - 2 downto X2 - 48 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 24 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := XBOW_OBJECT3;
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := -1;
    end;

    Players[P].LastUsedSkill := sSniperShot;

    Players[P].WineSkillDelay := Round(XBOW_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearWineTilesArrayTime[P] := States.GameTime + Round(XBOW_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

  end;

end;


//PIKEMAN


procedure ViseOfDeath(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 29;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

    ViseCirclesLength[P] := ViseCirclesLength[P] + VISE_CYCLES * VISE_RADIUS;
    SetLength(ViseCircles[P], ViseCirclesLength[P]);
    for I := ViseCirclesLength[P] downto ViseCirclesLength[P] - VISE_CYCLES * VISE_RADIUS + 1 do
    begin
      ViseCircles[P][ViseCirclesLength[P] - I].Obj := PikeObjects[P];
      ViseCircles[P][ViseCirclesLength[P] - I].X := X2;
      ViseCircles[P][ViseCirclesLength[P] - I].Y := Y2;
      ViseCircles[P][ViseCirclesLength[P] - I].AddTime := States.GameTime + Round(PIKE_ROAD_SPEED * I);
      ViseCircles[P][ViseCirclesLength[P] - I].Radius := VISE_RADIUS - I mod VISE_RADIUS;
      if I mod VISE_RADIUS = 0 then
        ViseCircles[P][ViseCirclesLength[P] - I].Radius := 0;
    end;

    case Direction of

      0,1: for Y1 := Y2 - 3 downto Y2 - 10 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 28 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := PIKE_OBJECT9;
             end;

      2,3: for X1 := X2 + 3 to X2 + 10 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 28 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := PIKE_OBJECT9;
             end;

      4,5: for Y1 := Y2 + 3 to Y2 + 10 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 28 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := PIKE_OBJECT9;
             end;

      6,7: for X1 := X2 - 3 downto X2 - 10 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 28 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := PIKE_OBJECT9;
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := -1;
    end;

    Players[P].LastUsedSkill := sViseOfDeath;

    Players[P].RoadSkillDelay := Round(PIKE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    TimeToClearViseArray[P] := States.GameTime + Round(PIKE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := States.GameTime + Round(PIKE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

  end;

end;


procedure SacrificialTeleport(P, X, Y: Integer);
var
  X2, Y2, NewDir: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (Players[P].Hero > 0)
  and (Players[P].HP >= 2)
  and (TileOnBattlefield(X, Y)) then
  begin
    NewDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= SACRIFICIAL_RADIUS)
    and (Abs(Y2 - Y) <= SACRIFICIAL_RADIUS) then
    begin
      Players[P].LastUsedSkill := sSacrificialTeleport;
      Players[P].FieldSkillDelay := Round(PIKE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      Actions.GroupKillAll(Players[P].Hero, False);
      if not Players[P].CaptureMind then
        Players[P].HP := Players[P].HP - 1;
      if Players[P].CaptureMind then
        Players[M[P]].HP := Players[M[P]].HP - 1;  
      Players[P].Hero := Actions.GiveGroup(P, Players[P].TempHeroType, X, Y, NewDir, 1, 1);
      Actions.GroupHungerset(Players[P].Hero, States.UnitMaxHunger);
    end;
  end;

end;


procedure Concentration(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (Players[P].Hero > 0)
  and (TileOnBattlefield(X, Y)) then
  begin
    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 80;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    Actions.GroupOrderHalt(Players[P].Hero);
    Actions.GroupBlockOrders(Players[P].Hero, True);
    Players[P].HeroStunned := True;
    Players[P].HeroStunnedTime := States.GameTime + CONCENTRATION_TIME + 5;
    if not Players[P].HeroImmortal then
    begin
      Players[P].HeroImmortalTime := States.GameTime + CONCENTRATION_TIME + 5;
      Players[P].HeroImmortal := True;
    end;
    Players[P].Preparing := True;
    Players[P].PreparingTime := States.GameTime + CONCENTRATION_TIME + 5;

    TilesWineLength[P] := TilesWineLength[P] + 32;
    SetLength(TilesWineX[P], TilesWineLength[P]);
    SetLength(TilesWineY[P], TilesWineLength[P]);
    SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
    SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
    SetLength(TilesWineObjects[P], TilesWineLength[P]);

    TilesWineX[P][Length(TilesWineX[P]) - 32] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 31] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 30] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 29] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 32] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 31] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 30] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 29] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 28] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 27] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 26] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 25] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 28] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 27] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 26] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 25] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 24] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 23] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 22] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 21] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 24] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 23] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 22] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 21] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 20] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 19] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 18] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 17] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 20] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 19] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 18] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 17] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 16] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 15] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 14] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 13] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 16] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 15] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 14] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 13] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 12] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 11] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 10] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 9] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 12] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 11] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 10] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 9] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 7] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 6] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 5] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 3] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 32] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 31] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 30] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 29] := PIKE_OBJ_STONE1;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 32] := States.GameTime + 60;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 31] := States.GameTime + 60;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 30] := States.GameTime + 60;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 29] := States.GameTime + 60;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 32] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 31] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 30] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 29] := States.GameTime + 1;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 28] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 27] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 26] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 25] := PIKE_OBJ_STONE1;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 28] := States.GameTime + 60;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 27] := States.GameTime + 60;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 26] := States.GameTime + 60;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 25] := States.GameTime + 60;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 28] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 27] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 26] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 25] := States.GameTime + 1;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 24] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 23] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 22] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 21] := PIKE_OBJ_STONE;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 24] := States.GameTime + 60;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 23] := States.GameTime + 60;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 22] := States.GameTime + 60;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 21] := States.GameTime + 60;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 24] := States.GameTime + 15;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 23] := States.GameTime + 15;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 22] := States.GameTime + 15;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 21] := States.GameTime + 15;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 20] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 19] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 18] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 17] := PIKE_OBJ_STONE;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 20] := States.GameTime + 60;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 19] := States.GameTime + 60;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 18] := States.GameTime + 60;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 17] := States.GameTime + 60;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 20] := States.GameTime + 15;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 19] := States.GameTime + 15;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 18] := States.GameTime + 15;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 17] := States.GameTime + 15;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 16] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 15] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 14] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 13] := PIKE_OBJ_STONE1;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 16] := States.GameTime + 75;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 15] := States.GameTime + 75;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 14] := States.GameTime + 75;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 13] := States.GameTime + 75;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 16] := States.GameTime + 30;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 15] := States.GameTime + 30;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 14] := States.GameTime + 30;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 13] := States.GameTime + 30;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 12] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 11] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 10] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 9] := PIKE_OBJ_STONE1;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 12] := States.GameTime + 75;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 11] := States.GameTime + 75;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 10] := States.GameTime + 75;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 9] := States.GameTime + 75;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 12] := States.GameTime + 30;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 11] := States.GameTime + 30;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 10] := States.GameTime + 30;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 9] := States.GameTime + 30;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 8] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 7] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 6] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 5] := PIKE_OBJ_STONE;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 75;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 75;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 75;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 75;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 45;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 45;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 45;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 45;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - 4] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 3] := PIKE_OBJ_STONE;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 2] := PIKE_OBJ_STONE1;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := PIKE_OBJ_STONE;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 75;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 75;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 75;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 75;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 45;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 45;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 45;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 45;

    for I := 1 to 32 do
      if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_MINE)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

    ConcentrationCirclesLength[P] := ConcentrationCirclesLength[P] + CONCENTRATION_CYCLES * CONCENTRATION_RADIUS;
    SetLength(ConcentrationCircles[P], ConcentrationCirclesLength[P]);
    for I := ConcentrationCirclesLength[P] downto ConcentrationCirclesLength[P] - CONCENTRATION_CYCLES * CONCENTRATION_RADIUS + 1 do
    begin
      ConcentrationCircles[P][ConcentrationCirclesLength[P] - I].Obj := PikeObjects[P];
      ConcentrationCircles[P][ConcentrationCirclesLength[P] - I].X := X2;
      ConcentrationCircles[P][ConcentrationCirclesLength[P] - I].Y := Y2;
      ConcentrationCircles[P][ConcentrationCirclesLength[P] - I].AddTime := States.GameTime + 60 + Round((ConcentrationCirclesLength[P] - I) / PIKE_WINE_SPEED);
      if I mod CONCENTRATION_RADIUS > 0 then
        ConcentrationCircles[P][ConcentrationCirclesLength[P] - I].Radius := CONCENTRATION_RADIUS + 1 - I mod CONCENTRATION_RADIUS
      else
        ConcentrationCircles[P][ConcentrationCirclesLength[P] - I].Radius := 1;
    end;

    for I := 0 to ConcentrationCirclesLength[P] - 1 do 
      if I mod CONCENTRATION_RADIUS = 1 then
        ConcentrationCircles[P][ConcentrationCirclesLength[P] - I].Obj := 255;

    Players[P].LastUsedSkill := sConcentration;

    Players[P].WineSkillDelay := Round(PIKE_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    TimeToClearConcentrationArray[P] := States.GameTime + 200;

    ClearWineTilesArrayTime[P] := States.GameTime + 200;

  end;

end;


//VAGA-VAGA


procedure Disorientation(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    {if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 11;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;}

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X2 - X) <= SHOCK_RADIUS)
    and (Abs(Y2 - Y) <= SHOCK_RADIUS) then
    begin
      TilesRoadLength[P] := TilesRoadLength[P] + 9;
      SetLength(TilesRoadX[P], TilesRoadLength[P]);
      SetLength(TilesRoadY[P], TilesRoadLength[P]);
      SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
      SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
      SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
        
      TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
      TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
      TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X;
      TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y - 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X;
      TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y + 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X - 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y;
      TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X + 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y;
      TilesRoadX[P][Length(TilesRoadX[P]) - 6] := X + 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 6] := Y + 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 7] := X + 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 7] := Y - 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 8] := X - 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 8] := Y + 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 9] := X - 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 9] := Y - 1;

      for I := 1 to 9 do
        TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := VAGA_OBJECT6;

      for I := 6 to 9 do
      begin
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := States.GameTime + 10;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - I] := States.GameTime + 6;
      end;

      for I := 2 to 5 do
      begin
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := States.GameTime + 8;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - I] := States.GameTime + 4;
      end;

      ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 6;
      SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 2;

      for I := 1 to 9 do
        if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_MINE)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

      Players[P].LastUsedSkill := sDisorientation;

      Players[P].RoadSkillDelay := Round(VAGA_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    end;

  end;

end;


procedure VagaWave(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    VagaCirclesLength[P] := VagaCirclesLength[P] + VAGA_WAVE_CYCLES * VAGA_WAVE_RADIUS;
    SetLength(VagaCircles[P], VagaCirclesLength[P]);
    for I := VagaCirclesLength[P] downto VagaCirclesLength[P] - VAGA_WAVE_CYCLES * VAGA_WAVE_RADIUS + 1 do
    begin
      VagaCircles[P][VagaCirclesLength[P] - I].Obj := VAGA_OBJECT2;
      VagaCircles[P][VagaCirclesLength[P] - I].X := X2;
      VagaCircles[P][VagaCirclesLength[P] - I].Y := Y2;
      VagaCircles[P][VagaCirclesLength[P] - I].AddTime := States.GameTime + Round(VAGA_FIELD_SPEED * (VagaCirclesLength[P] - I));
      if I mod VAGA_WAVE_RADIUS > 0 then
        VagaCircles[P][VagaCirclesLength[P] - I].Radius := VAGA_WAVE_RADIUS + 2 - I mod VAGA_WAVE_RADIUS
      else
        VagaCircles[P][VagaCirclesLength[P] - I].Radius := 1;
    end;        
    for I := 0 to VagaCirclesLength[P] - 1 do 
      if I mod VAGA_WAVE_RADIUS = 1 then
        VagaCircles[P][VagaCirclesLength[P] - I].Obj := 255;

    Players[P].LastUsedSkill := sVagaWave;

    Players[P].FieldSkillDelay := Round(VAGA_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    TimeToClearVagaArray[P] := States.GameTime + 100;

  end;

end;


procedure Regen(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= REGEN_RADIUS)
    and (Abs(Y2 - Y) <= REGEN_RADIUS) then
    begin

      if States.PlayerIsAI(P) then
      begin
        Players[P].CastingSkill := True;
        Players[P].SkillTime := States.GameTime + 20;
        Actions.GroupOrderHalt(Players[P].Hero);
      end;

      TilesWineLength[P] := TilesWineLength[P] + 13;
      SetLength(TilesWineX[P], TilesWineLength[P]);
      SetLength(TilesWineY[P], TilesWineLength[P]);
      SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
      SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
      SetLength(TilesWineObjects[P], TilesWineLength[P]);
    
      TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 + 1;
    
      TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2 - 1;

      for I := 1 to 4 do 
        TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := VAGA_OBJECT5;
  
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 10;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 12;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 14;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 16;
    
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 1;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 3;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 5;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 7;
        
      TilesWineX[P][Length(TilesWineX[P]) - 5] := X;
      TilesWineY[P][Length(TilesWineY[P]) - 5] := Y;
      TilesWineX[P][Length(TilesWineX[P]) - 6] := X;
      TilesWineY[P][Length(TilesWineY[P]) - 6] := Y - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 7] := X;
      TilesWineY[P][Length(TilesWineY[P]) - 7] := Y + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 8] := X - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 8] := Y;
      TilesWineX[P][Length(TilesWineX[P]) - 9] := X + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 9] := Y;
      TilesWineX[P][Length(TilesWineX[P]) - 10] := X + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 10] := Y + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 11] := X + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 11] := Y - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 12] := X - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 12] := Y + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 13] := X - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 13] := Y - 1;

      for I := 5 to 13 do
      begin
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := States.GameTime + 70;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - I] := States.GameTime + 20;
        TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := VAGA_OBJECT;
      end;

      for I := 1 to 13 do
        if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_MINE)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
          ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

      Players[P].LastUsedSkill := sRegen;

      Players[P].WineSkillDelay := Round(VAGA_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

      ClearWineTilesArrayTime[P] := States.GameTime + Round(VAGA_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

    end;

  end;

end;


//AXE FIGHTER


procedure Gravity(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero <> -1) then
  begin
    {if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 10;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;}

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X2 - X) <= GRAVITY_RADIUS1)
    and (Abs(Y2 - Y) <= GRAVITY_RADIUS1) then
    begin
      Players[P].GravityX := X;
      Players[P].GravityY := Y;
      GravityCirclesLength[P] := GravityCirclesLength[P] + GRAVITY_CYCLES * GRAVITY_RADIUS;
      SetLength(GravityCircles[P], GravityCirclesLength[P]);
      for I := GravityCirclesLength[P] downto GravityCirclesLength[P] - GRAVITY_CYCLES * GRAVITY_RADIUS + 1 do
      begin
        GravityCircles[P][GravityCirclesLength[P] - I].Obj := AXE_OBJECT;
        GravityCircles[P][GravityCirclesLength[P] - I].X := X;
        GravityCircles[P][GravityCirclesLength[P] - I].Y := Y;
        GravityCircles[P][GravityCirclesLength[P] - I].AddTime := States.GameTime + Round(AXE_ROAD_SPEED * I);
        GravityCircles[P][GravityCirclesLength[P] - I].Radius := GRAVITY_RADIUS - I mod GRAVITY_RADIUS;
        if I mod GRAVITY_RADIUS = 0 then
          GravityCircles[P][GravityCirclesLength[P] - I].Radius := 0;
      end;

    Players[P].LastUsedSkill := sGravity;

    Players[P].RoadSkillDelay := Round(AXE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    TimeToClearGravityArray[P] := States.GameTime + Round(AXE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

    end;

  end;

end;


procedure DeadlyFireworks(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X2 - X) <= FIRE_RADIUS)
    and (Abs(Y2 - Y) <= FIRE_RADIUS) then
    begin

      if States.PlayerIsAI(P) then
      begin
        Players[P].CastingSkill := True;
        Players[P].SkillTime := States.GameTime + 40;
        Actions.GroupOrderHalt(Players[P].Hero);
      end;

      TilesFieldLength[P] := TilesFieldLength[P] + 15;
      SetLength(TilesFieldX[P], TilesFieldLength[P]);
      SetLength(TilesFieldY[P], TilesFieldLength[P]);
      SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
      SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
      SetLength(TilesFieldObjects[P], TilesFieldLength[P]);

      for I := 13 to 15 do
      begin
        TilesFieldX[P][Length(TilesFieldX[P]) - I] := X;
        TilesFieldY[P][Length(TilesFieldX[P]) - I] := Y;
        TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := AXE_OBJECT4;
      end;

      TilesFieldX[P][Length(TilesFieldX[P]) - 12] := X2 + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 11] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 10] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 9] := X2 + 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 12] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 11] := Y2 - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 10] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 9] := Y2 - 1;
    
      TilesFieldX[P][Length(TilesFieldX[P]) - 8] := X2 + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 7] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 6] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 5] := X2 + 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 8] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 7] := Y2 - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 6] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 5] := Y2 - 1;

      TilesFieldX[P][Length(TilesFieldX[P]) - 4] := X2 + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 3] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 2] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X2 + 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 4] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 3] := Y2 - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 2] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y2 - 1;

      for I := 1 to 12 do    
        TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := AXE_OBJECT3;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 15] := States.GameTime + 39;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 14] := States.GameTime + 23;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 13] := States.GameTime + 8;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 15] := States.GameTime + 31;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 14] := States.GameTime + 15;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 13] := States.GameTime + 1;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 12] := States.GameTime + 39;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 11] := States.GameTime + 39;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 10] := States.GameTime + 39;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 9] := States.GameTime + 39;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 12] := States.GameTime + 31;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 11] := States.GameTime + 31;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 10] := States.GameTime + 31;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 9] := States.GameTime + 31;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 8] := States.GameTime + 23;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 7] := States.GameTime + 23;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 6] := States.GameTime + 23;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 5] := States.GameTime + 23;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 8] := States.GameTime + 15;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 7] := States.GameTime + 15;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 6] := States.GameTime + 15;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 5] := States.GameTime + 15;
    
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 4] := States.GameTime + 8;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 3] := States.GameTime + 8;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 2] := States.GameTime + 8;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 8;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 4] := States.GameTime + 1;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 3] := States.GameTime + 1;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 2] := States.GameTime + 1;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 1;

      for I := 1 to 15 do
        if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_MINE)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
           ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] + CLEANUP_TIME;

      FireworksCircles1Length[P] := FireworksCircles1Length[P] + FIREWORKS1_CYCLES * FIREWORKS1_RADIUS;
      SetLength(FireworksCircles1[P], FireworksCircles1Length[P]);
      for I := FireworksCircles1Length[P] downto FireworksCircles1Length[P] - FIREWORKS1_CYCLES * FIREWORKS1_RADIUS + 1 do
      begin
        FireworksCircles1[P][FireworksCircles1Length[P] - I].Obj := AXE_OBJECT2;
        FireworksCircles1[P][FireworksCircles1Length[P] - I].X := X;
        FireworksCircles1[P][FireworksCircles1Length[P] - I].Y := Y;
        FireworksCircles1[P][FireworksCircles1Length[P] - I].AddTime := States.GameTime + 40 + Round(AXE_FIELD_SPEED * (FireworksCircles1Length[P] - I));
        if I mod FIREWORKS1_RADIUS > 0 then
          FireworksCircles1[P][FireworksCircles1Length[P] - I].Radius := FIREWORKS1_RADIUS - I mod FIREWORKS1_RADIUS
        else
          FireworksCircles1[P][FireworksCircles1Length[P] - I].Radius := 0;
      end;        
      for I := 0 to FireworksCircles1Length[P] - 1 do 
        if I mod FIREWORKS1_RADIUS = 1 then
          FireworksCircles1[P][FireworksCircles1Length[P] - I].Obj := 255;

      FireworksCircles2Length[P] := FireworksCircles2Length[P] + FIREWORKS2_CYCLES * FIREWORKS2_RADIUS;
      SetLength(FireworksCircles2[P], FireworksCircles2Length[P]);
      for I := FireworksCircles2Length[P] downto FireworksCircles2Length[P] - FIREWORKS2_CYCLES * FIREWORKS2_RADIUS + 1 do
      begin
        FireworksCircles2[P][FireworksCircles2Length[P] - I].Obj := AXE_OBJECT2;
        FireworksCircles2[P][FireworksCircles2Length[P] - I].X := X + FIREWORKS1_RADIUS;
        FireworksCircles2[P][FireworksCircles2Length[P] - I].Y := Y;
        FireworksCircles2[P][FireworksCircles2Length[P] - I].AddTime := States.GameTime + 48 + Round(AXE_FIELD_SPEED * (FireworksCircles2Length[P] - I));
        if I mod FIREWORKS2_RADIUS > 0 then
          FireworksCircles2[P][FireworksCircles2Length[P] - I].Radius := FIREWORKS2_RADIUS - I mod FIREWORKS2_RADIUS
        else
          FireworksCircles2[P][FireworksCircles2Length[P] - I].Radius := 0;
      end;        
      for I := 0 to FireworksCircles2Length[P] - 1 do 
        if I mod FIREWORKS2_RADIUS = 1 then
          FireworksCircles2[P][FireworksCircles2Length[P] - I].Obj := 255;

      FireworksCircles3Length[P] := FireworksCircles3Length[P] + FIREWORKS2_CYCLES * FIREWORKS2_RADIUS;
      SetLength(FireworksCircles3[P], FireworksCircles3Length[P]);
      for I := FireworksCircles3Length[P] downto FireworksCircles3Length[P] - FIREWORKS2_CYCLES * FIREWORKS2_RADIUS + 1 do
      begin
        FireworksCircles3[P][FireworksCircles3Length[P] - I].Obj := AXE_OBJECT2;
        FireworksCircles3[P][FireworksCircles3Length[P] - I].X := X - FIREWORKS1_RADIUS;
        FireworksCircles3[P][FireworksCircles3Length[P] - I].Y := Y;
        FireworksCircles3[P][FireworksCircles3Length[P] - I].AddTime := States.GameTime + 48 + Round(AXE_FIELD_SPEED * (FireworksCircles3Length[P] - I));
        if I mod FIREWORKS2_RADIUS > 0 then
          FireworksCircles3[P][FireworksCircles3Length[P] - I].Radius := FIREWORKS2_RADIUS - I mod FIREWORKS2_RADIUS
        else
          FireworksCircles3[P][FireworksCircles3Length[P] - I].Radius := 0;
      end;        
      for I := 0 to FireworksCircles3Length[P] - 1 do 
        if I mod FIREWORKS2_RADIUS = 1 then
          FireworksCircles3[P][FireworksCircles3Length[P] - I].Obj := 255;

      FireworksCircles4Length[P] := FireworksCircles4Length[P] + FIREWORKS2_CYCLES * FIREWORKS2_RADIUS;
      SetLength(FireworksCircles4[P], FireworksCircles4Length[P]);
      for I := FireworksCircles4Length[P] downto FireworksCircles4Length[P] - FIREWORKS2_CYCLES * FIREWORKS2_RADIUS + 1 do
      begin
        FireworksCircles4[P][FireworksCircles4Length[P] - I].Obj := AXE_OBJECT2;
        FireworksCircles4[P][FireworksCircles4Length[P] - I].X := X;
        FireworksCircles4[P][FireworksCircles4Length[P] - I].Y := Y + FIREWORKS1_RADIUS;
        FireworksCircles4[P][FireworksCircles4Length[P] - I].AddTime := States.GameTime + 48 + Round(AXE_FIELD_SPEED * (FireworksCircles4Length[P] - I));
        if I mod FIREWORKS2_RADIUS > 0 then
          FireworksCircles4[P][FireworksCircles4Length[P] - I].Radius := FIREWORKS2_RADIUS - I mod FIREWORKS2_RADIUS
        else
          FireworksCircles4[P][FireworksCircles4Length[P] - I].Radius := 0;
      end;        
      for I := 0 to FireworksCircles4Length[P] - 1 do 
        if I mod FIREWORKS2_RADIUS = 1 then
          FireworksCircles4[P][FireworksCircles4Length[P] - I].Obj := 255;

      FireworksCircles5Length[P] := FireworksCircles5Length[P] + FIREWORKS2_CYCLES * FIREWORKS2_RADIUS;
      SetLength(FireworksCircles5[P], FireworksCircles5Length[P]);
      for I := FireworksCircles5Length[P] downto FireworksCircles5Length[P] - FIREWORKS2_CYCLES * FIREWORKS2_RADIUS + 1 do
      begin
        FireworksCircles5[P][FireworksCircles5Length[P] - I].Obj := AXE_OBJECT2;
        FireworksCircles5[P][FireworksCircles5Length[P] - I].X := X;
        FireworksCircles5[P][FireworksCircles5Length[P] - I].Y := Y - FIREWORKS1_RADIUS;
        FireworksCircles5[P][FireworksCircles5Length[P] - I].AddTime := States.GameTime + 48 + Round(AXE_FIELD_SPEED * (FireworksCircles5Length[P] - I));
        if I mod FIREWORKS2_RADIUS > 0 then
          FireworksCircles5[P][FireworksCircles5Length[P] - I].Radius := FIREWORKS2_RADIUS - I mod FIREWORKS2_RADIUS
      else
        FireworksCircles5[P][FireworksCircles5Length[P] - I].Radius := 0;
      end;        
      for I := 0 to FireworksCircles5Length[P] - 1 do 
        if I mod FIREWORKS2_RADIUS = 1 then
          FireworksCircles5[P][FireworksCircles5Length[P] - I].Obj := 255;

      if States.PlayerIsAI(P) then
      begin
        Players[P].SkillCastDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
        Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
        Players[P].SkillCastX := X2;
        Players[P].SkillCastY := Y2;
        Actions.GroupKillAll(Players[P].Hero, True);
      end;

      Players[P].LastUsedSkill := sDeadlyFireworks;

      Players[P].FieldSkillDelay := Round(AXE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

      TimeToClearFireworks1Array[P] := States.GameTime + Round(AXE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      TimeToClearFireworks2Array[P] := States.GameTime + Round(AXE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      TimeToClearFireworks3Array[P] := States.GameTime + Round(AXE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      TimeToClearFireworks4Array[P] := States.GameTime + Round(AXE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      TimeToClearFireworks5Array[P] := States.GameTime + Round(AXE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

      ClearFieldTilesArrayTime[P] := States.GameTime + Round(AXE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

    end;

  end;

end;


procedure Werewolf(P, X, Y: Integer);
var
  X2, Y2, NewDir: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    NewDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= WEREWOLF_RADIUS)
    and (Abs(Y2 - Y) <= WEREWOLF_RADIUS) then
    begin
      Players[P].WineSkillDelay := 0;
      Players[P].RoadSkillDelay := 0;
      Players[P].FieldSkillDelay := 0;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].VagaX := X2;
      Players[P].VagaY := Y2;
      Players[P].VagaDir := NewDir;
      Players[P].VagaAppearTime := States.GameTime + VAGA_TIME;
      Players[P].TempHeroType := Players[P].HeroType;
      Players[P].HeroType := 27;
      Players[P].LastUsedSkill := sWerewolf;
    end;
  end;

end;


//BOWMAN


procedure CatchTheBomb(P, X, Y, Dir: Integer);
var
  X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 12;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

    if not (CanPlaceMine(P, X2, Y2)) then
      Exit;

    TilesRoadLength[P] := TilesRoadLength[P] + 5;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;

    for I := 1 to 4 do
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := BOWMAN_OBJECT;

    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 6;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 7;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 8;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 9;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 1;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 3;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4;

    for I := 1 to 4 do
    begin
      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_MINE)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
      begin
         SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - I] := 0;
         ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;
         TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := BOWMAN_OBJECT5;
      end;
    end;

    case Direction of

      0,1: begin
             if (States.MapTileObject(X2, Y2 - 1) <> BARB_OBJECT3)
             and (States.MapTileObject(X2, Y2 - 1) <> BOWMAN_OBJECT5) then
             begin
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2 - 1;
               Actions.PlanAddRoad(Players[P].RoadPlayer, X2, Y2 - 1);
               Roads[X2][Y2 - 1].Owner := Players[P].RoadPlayer;
               Players[P].LastUsedSkill := sMine;
               Players[P].RoadSkillDelay := Round(BOWMAN_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := States.GameTime + 10 + DEL_MINE_TIME;

               if (States.PlayerIsAI(P))
               and (Players[P].HP > 0) then
               begin
                 Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
                 Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
                 Players[P].SkillCastDir := Dir;
                 Players[P].SkillCastX := X2;
                 Players[P].SkillCastY := Y2;
                 Actions.GroupKillAll(Players[P].Hero, True);
                 Players[P].Hero := -1;
               end;

             end;
           end;

      2,3: begin
             if (States.MapTileObject(X2 + 1, Y2) <> BARB_OBJECT3)
             and (States.MapTileObject(X2 + 1, Y2) <> BOWMAN_OBJECT5) then
             begin
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2 + 1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2;
               Actions.PlanAddRoad(Players[P].RoadPlayer, X2 + 1, Y2);
               Roads[X2 + 1][Y2].Owner := Players[P].RoadPlayer;
               Players[P].LastUsedSkill := sMine;
               Players[P].RoadSkillDelay := Round(BOWMAN_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := States.GameTime + 10 + DEL_MINE_TIME;

               if (States.PlayerIsAI(P))
               and (Players[P].HP > 0) then
               begin
                 Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
                 Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
                 Players[P].SkillCastDir := Dir;
                 Players[P].SkillCastX := X2;
                 Players[P].SkillCastY := Y2;
                 Actions.GroupKillAll(Players[P].Hero, True);
                 Players[P].Hero := -1;
               end;

             end;
           end;

      4,5: begin
             if (States.MapTileObject(X2, Y2 + 1) <> BARB_OBJECT3)
             and (States.MapTileObject(X2, Y2 + 1) <> BOWMAN_OBJECT5) then
             begin
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2 + 1;
               Actions.PlanAddRoad(Players[P].RoadPlayer, X2, Y2 + 1);
               Roads[X2][Y2 + 1].Owner := Players[P].RoadPlayer;
               Players[P].LastUsedSkill := sMine;
               Players[P].RoadSkillDelay := Round(BOWMAN_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := States.GameTime + 10 + DEL_MINE_TIME;

               if (States.PlayerIsAI(P))
               and (Players[P].HP > 0) then
               begin
                 Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
                 Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
                 Players[P].SkillCastDir := Dir;
                 Players[P].SkillCastX := X2;
                 Players[P].SkillCastY := Y2;
                 Actions.GroupKillAll(Players[P].Hero, True);
                 Players[P].Hero := -1;
               end;

             end;
           end;

      6,7: begin
             if (States.MapTileObject(X2 - 1, Y2) <> BARB_OBJECT3)
             and (States.MapTileObject(X2 - 1, Y2) <> BOWMAN_OBJECT5) then
             begin
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2 - 1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2;
               Actions.PlanAddRoad(Players[P].RoadPlayer, X2 - 1, Y2);
               Roads[X2 - 1][Y2].Owner := Players[P].RoadPlayer;
               Players[P].LastUsedSkill := sMine;
               Players[P].RoadSkillDelay := Round(BOWMAN_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := States.GameTime + 10 + DEL_MINE_TIME;

               if (States.PlayerIsAI(P))
               and (Players[P].HP > 0) then
               begin
                 Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
                 Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
                 Players[P].SkillCastDir := Dir;
                 Players[P].SkillCastX := X2;
                 Players[P].SkillCastY := Y2;
                 Actions.GroupKillAll(Players[P].Hero, True);
                 Players[P].Hero := -1;
               end;

             end;
           end;               
    end;      

      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - 5], TilesRoadY[P][Length(TilesRoadY[P]) - 5]) <> BARB_OBJECT3)
      and (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - 5], TilesRoadY[P][Length(TilesRoadY[P]) - 5]) <> BOWMAN_OBJECT5) then
      begin
        TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := BOWMAN_MINE;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 10;
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + DEL_MINE_TIME;
      end;

  end;

end;


procedure Prison(P, X, Y: Integer);
var
  X2, Y2, zX, zY, O, U: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X2 - X) <= PRISON_RADIUS)
    and (Abs(Y2 - Y) <= PRISON_RADIUS) then
    begin
      U := States.UnitAt(X, Y);

      if U > 0 then
        O := States.UnitOwner(U);

      if U > 0 then
      begin
        if (InRange(O, 8, 11))
        and (States.UnitType(U) > 14) then
          Exit;
      end;

      if (InRange(O, 0, 7))
      and (Players[O].HeroImmortal) then
        Exit;

      if (U <> - 1) then
      begin
        if (U = States.GroupMember(Players[O].Hero, 0)) then
        begin
          Actions.GroupOrderHalt(Players[O].Hero);
          Players[O].HeroPrisoned := True;
          Players[O].HeroPrisonedTime := States.GameTime + PRISON_TIME + 2;
          TilesFieldLength[P] := TilesFieldLength[P] + 25;
          SetLength(TilesFieldX[P], TilesFieldLength[P]);
          SetLength(TilesFieldY[P], TilesFieldLength[P]);
          SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
          SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
          SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
        end;

        if (States.UnitType(U) = 14) then
        begin
          for zX := X - 2 to X  + 2 do
          for zY := Y - 2 to Y  + 2 do
          begin
            U := States.UnitAt(zX, zY);
            if U > 0 then
              Actions.GroupOrderHalt(States.UnitsGroup(U));
          end;

          TilesFieldLength[P] := TilesFieldLength[P] + 25;
          SetLength(TilesFieldX[P], TilesFieldLength[P]);
          SetLength(TilesFieldY[P], TilesFieldLength[P]);
          SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
          SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
          SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
       end;

          TilesFieldX[P][Length(TilesFieldX[P]) - 25] := X;

          TilesFieldY[P][Length(TilesFieldY[P]) - 25] := Y;

          for I := 20 to 24 do
            TilesFieldX[P][Length(TilesFieldX[P]) - I] := X - 2;

          TilesFieldX[P][Length(TilesFieldX[P]) - 19] := X - 1;
          TilesFieldX[P][Length(TilesFieldX[P]) - 18] := X - 1;

          TilesFieldX[P][Length(TilesFieldX[P]) - 17] := X;
          TilesFieldX[P][Length(TilesFieldX[P]) - 16] := X;

          TilesFieldX[P][Length(TilesFieldX[P]) - 15] := X + 1;
          TilesFieldX[P][Length(TilesFieldX[P]) - 14] := X + 1;

          for I := 9 to 13 do
            TilesFieldX[P][Length(TilesFieldX[P]) - I] := X + 2;

          TilesFieldX[P][Length(TilesFieldX[P]) - 8] := X - 1;
          TilesFieldX[P][Length(TilesFieldX[P]) - 7] := X;
          TilesFieldX[P][Length(TilesFieldX[P]) - 6] := X + 1;
          TilesFieldX[P][Length(TilesFieldX[P]) - 5] := X + 1;
          TilesFieldX[P][Length(TilesFieldX[P]) - 4] := X + 1;
          TilesFieldX[P][Length(TilesFieldX[P]) - 3] := X;
          TilesFieldX[P][Length(TilesFieldX[P]) - 2] := X - 1;
          TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X - 1;
    
          TilesFieldY[P][Length(TilesFieldY[P]) - 24] := Y + 2;
          TilesFieldY[P][Length(TilesFieldY[P]) - 23] := Y + 1;
          TilesFieldY[P][Length(TilesFieldY[P]) - 22] := Y;
          TilesFieldY[P][Length(TilesFieldY[P]) - 21] := Y - 1;
          TilesFieldY[P][Length(TilesFieldY[P]) - 20] := Y - 2;

          TilesFieldY[P][Length(TilesFieldY[P]) - 19] := Y - 2;
          TilesFieldY[P][Length(TilesFieldY[P]) - 18] := Y + 2;

          TilesFieldY[P][Length(TilesFieldY[P]) - 17] := Y - 2;
          TilesFieldY[P][Length(TilesFieldY[P]) - 16] := Y + 2;

          TilesFieldY[P][Length(TilesFieldY[P]) - 15] := Y - 2;
          TilesFieldY[P][Length(TilesFieldY[P]) - 14] := Y + 2;

          TilesFieldY[P][Length(TilesFieldY[P]) - 13] := Y - 2;
          TilesFieldY[P][Length(TilesFieldY[P]) - 12] := Y - 1;
          TilesFieldY[P][Length(TilesFieldY[P]) - 11] := Y;
          TilesFieldY[P][Length(TilesFieldY[P]) - 10] := Y + 1;
          TilesFieldY[P][Length(TilesFieldY[P]) - 9] := Y + 2;

          TilesFieldY[P][Length(TilesFieldY[P]) - 8] := Y + 1;
          TilesFieldY[P][Length(TilesFieldY[P]) - 7] := Y + 1;
          TilesFieldY[P][Length(TilesFieldY[P]) - 6] := Y + 1;
          TilesFieldY[P][Length(TilesFieldY[P]) - 5] := Y;
          TilesFieldY[P][Length(TilesFieldY[P]) - 4] := Y - 1;
          TilesFieldY[P][Length(TilesFieldY[P]) - 3] := Y - 1;
          TilesFieldY[P][Length(TilesFieldY[P]) - 2] := Y - 1;
          TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y;

          for I := 1 to 25 do
            if (not States.IsRoadAt(0, TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]))
            and (not States.IsRoadAt(1, TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I])) 
            and (not States.IsRoadAt(2, TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I])) 
            and (not States.IsRoadAt(3, TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I])) 
            and (not States.IsRoadAt(4, TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I])) 
            and (not States.IsRoadAt(5, TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I])) 
            and (not States.IsRoadAt(6, TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I])) 
            and (not States.IsRoadAt(7, TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I])) then
            begin
              ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := States.GameTime + PRISON_TIME;
              SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - I] := States.GameTime + 2;
              TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := BOWMAN_OBJECT5;
              if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BARB_OBJECT3)
              or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_MINE)
              or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_OBJECT5)
              or (InRange(States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
                ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] + CLEANUP_TIME;
            end;

        Players[P].LastUsedSkill := sPrison;

        Players[P].FieldSkillDelay := Round(BOWMAN_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

        ClearFieldTilesArrayTime[P] := States.GameTime + Round(BOWMAN_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

      end;

    end;

  end;

end;


procedure RevengeFromNowhere(P, X, Y, Dir: Integer);
var
  X2, Y2, X1, Y1, Direction, Desync: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 17;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

    ExpCirclesLength[P] := ExpCirclesLength[P] + EXP_CYCLES * EXP_RADIUS;
    SetLength(ExpCircles[P], ExpCirclesLength[P]);
    TilesWineLength[P] := TilesWineLength[P] + 9;
    SetLength(TilesWineX[P], TilesWineLength[P]);
    SetLength(TilesWineY[P], TilesWineLength[P]);
    SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
    SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
    SetLength(TilesWineObjects[P], TilesWineLength[P]);

    TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 7] := X2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2 + 1; 
    
    TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2;
    TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2;
    TilesWineX[P][Length(TilesWineX[P]) - 6] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 5] := X2; 
    
    TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 + 1;
    
    TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2 - 1;

    for I := 5 to 8 do
      TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := BOWMAN_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 13;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 14;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 15;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 16;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 3;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 4;
    
    for I := 1 to 4 do
      TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := BOWMAN_OBJECT2;
    
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 17;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 18;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 19;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 20;
    
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 5;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 6;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 7;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 8;

    for I := 1 to 9 do
      if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
        if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_MINE)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
          ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 18 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 24 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := BOWMAN_OBJECT3;
             end;

      2,3: for X1 := X2 + 2 to X2 + 18 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 24 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := BOWMAN_OBJECT3;
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 18 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 24 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := BOWMAN_OBJECT3;
             end;

      6,7: for X1 := X2 - 2 downto X2 - 18 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 24 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := BOWMAN_OBJECT3;
             end;
    end; 

    for I := ExpCirclesLength[P] downto ExpCirclesLength[P] - EXP_CYCLES * EXP_RADIUS + 1 do
    begin
      ExpCircles[P][ExpCirclesLength[P] - I].Obj := BOWMAN_OBJECT4;

      case Direction of 
      
      2,3,6,7: begin
                 ExpCircles[P][ExpCirclesLength[P] - I].X := X1;
                 ExpCircles[P][ExpCirclesLength[P] - I].Y := Y2;
               end;

      0,1,4,5: begin
                 ExpCircles[P][ExpCirclesLength[P] - I].X := X2;
                 ExpCircles[P][ExpCirclesLength[P] - I].Y := Y1;
               end;
      end;

    ExpCircles[P][ExpCirclesLength[P] - I].AddTime := States.GameTime + 28 + 2 * (ExpCirclesLength[P] - I);
    if I mod EXP_RADIUS > 0 then
      ExpCircles[P][ExpCirclesLength[P] - I].Radius := EXP_RADIUS + 1 - I mod EXP_RADIUS
    else
      ExpCircles[P][ExpCirclesLength[P] - I].Radius := 1;
    end;
        
    for I := 0 to ExpCirclesLength[P] - 1 do 
      if I mod EXP_RADIUS = 1 then
        ExpCircles[P][ExpCirclesLength[P] - I].Obj := 255;

    TimeToClearExpArray[P] := States.GameTime + Round(BOWMAN_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    Players[P].LastUsedSkill := sRevengeFromNowhere;

    Players[P].WineSkillDelay := Round(BOWMAN_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearWineTilesArrayTime[P] := States.GameTime + Round(BOWMAN_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := -1;
    end;

  end;

end;


//WARRIOR


procedure FierySnake(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, DX1, DX2, DX3, DY1, DY2, DY3, Direction, R: Integer;
  Place: Boolean;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;
    DX1 := 0;
    DX2 := 0;
    DX3 := 0;
    DY1 := 0;
    DY2 := 0;
    DY3 := 0;

    R := States.KaMRandomI(2);

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 17;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
  
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;

    for I := 1 to 4 do
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := WARRIOR_OBJECT + 3 * Byte(States.KaMRandom > 0.65);
    
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 10;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 12;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 14;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 4;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 6;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8;

    for I := 1 to 4 do
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
        if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_MINE)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    case Direction of

      0,1: begin
             for Y1 := Y2 - 2 downto Y2 - 13 do
             for X1 := X2 - 1 to X2 + 1 do
             begin
               if X1 = X2 - 1 then
                 DX1 := DX1 + 1;                  

               if X1 = X2 then
                 DX2 := DX2 + 1;

               if X1 = X2 + 1 then
                 DX3 := DX3 + 1;

               if TileOnBattlefield(X1, Y1) then
               begin
                 Desync := Desync + 1;

                 if R = 0 then
                   Place := ((X1 = X2 - 1)
                   and (DX1 mod 4 = 0))
                   or ((X1 = X2)
                   and (DX2 mod 2 = 1))
                   or ((X1 = X2 + 1)
                   and (DX3 mod 4 = 2));

                 if R = 1 then
                   Place := ((X1 = X2 - 1)
                   and (DX1 mod 4 = 2))
                   or ((X1 = X2)
                   and (DX2 mod 2 = 1))
                   or ((X1 = X2 + 1)
                   and (DX3 mod 4 = 0));

                 if Place then
                 begin
                   TilesRoadLength[P] := TilesRoadLength[P] + 1;
                   SetLength(TilesRoadX[P], TilesRoadLength[P]);
                   SetLength(TilesRoadY[P], TilesRoadLength[P]);
                   SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                   TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                   TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                   ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 48 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := WARRIOR_OBJECT3 - (States.KaMRandomI(2) + 1) * 3 * Byte(States.KaMRandomI(3) = 0);
                 end;
               end;
             end;
           end;

      2,3: begin
             for X1 := X2 + 2 to X2 + 13 do
             for Y1 := Y2 - 1 to Y2 + 1 do
             begin
               if Y1 = Y2 - 1 then
                 DY1 := DY1 + 1;

               if Y1 = Y2 then
                 DY2 := DY2 + 1;

               if Y1 = Y2 + 1 then
                 DY3 := DY3 + 1;

               if TileOnBattlefield(X1, Y1) then
               begin
                 Desync := Desync + 1;

                 if R = 0 then
                   Place := ((Y1 = Y2 - 1)
                   and (DY1 mod 4 = 0))
                   or ((Y1 = Y2)
                   and (DY2 mod 2 = 1))
                   or ((Y1 = Y2 + 1)
                   and (DY3 mod 4 = 2));

                 if R = 1 then
                   Place := ((Y1 = Y2 - 1)
                   and (DY1 mod 4 = 2))
                   or ((Y1 = Y2)
                   and (DY2 mod 2 = 1))
                   or ((Y1 = Y2 + 1)
                   and (DY3 mod 4 = 0));

                 if Place then
                 begin
                   TilesRoadLength[P] := TilesRoadLength[P] + 1;
                   SetLength(TilesRoadX[P], TilesRoadLength[P]);
                   SetLength(TilesRoadY[P], TilesRoadLength[P]);
                   SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                   TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                   TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                   ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 48 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := WARRIOR_OBJECT3 - (States.KaMRandomI(2) + 1) * 3 * Byte(States.KaMRandomI(3) = 0);
                 end;
               end;
             end;
           end;

      4,5: begin
             for Y1 := Y2 + 2 to Y2 + 13 do
             for X1 := X2 - 1 to X2 + 1 do
             begin
               if X1 = X2 - 1 then
                 DX1 := DX1 + 1;

               if X1 = X2 then
                 DX2 := DX2 + 1;

               if X1 = X2 + 1 then
                 DX3 := DX3 + 1;

               if TileOnBattlefield(X1, Y1) then
               begin
                 Desync := Desync + 1;

                 if R = 0 then
                   Place := ((X1 = X2 - 1)
                   and (DX1 mod 4 = 0))
                   or ((X1 = X2)
                   and (DX2 mod 2 = 1))
                   or ((X1 = X2 + 1)
                   and (DX3 mod 4 = 2));

                 if R = 1 then
                   Place := ((X1 = X2 - 1)
                   and (DX1 mod 4 = 2))
                   or ((X1 = X2)
                   and (DX2 mod 2 = 1))
                   or ((X1 = X2 + 1)
                   and (DX3 mod 4 = 0));

                 if Place then
                 begin
                   TilesRoadLength[P] := TilesRoadLength[P] + 1;
                   SetLength(TilesRoadX[P], TilesRoadLength[P]);
                   SetLength(TilesRoadY[P], TilesRoadLength[P]);
                   SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                   TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                   TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                   ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 48 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := WARRIOR_OBJECT3 - (States.KaMRandomI(2) + 1) * 3 * Byte(States.KaMRandomI(3) = 0);
                 end;
               end;
             end;
           end;

      6,7:  begin
             for X1 := X2 - 2 downto X2 - 13 do
             for Y1 := Y2 - 1 to Y2 + 1 do
             begin
               if Y1 = Y2 - 1 then
                 DY1 := DY1 + 1;

               if Y1 = Y2 then
                 DY2 := DY2 + 1;

               if Y1 = Y2 + 1 then
                 DY3 := DY3 + 1;

               if TileOnBattlefield(X1, Y1) then
               begin
                 Desync := Desync + 1;

                 if R = 0 then
                   Place := ((Y1 = Y2 - 1)
                   and (DY1 mod 4 = 0))
                   or ((Y1 = Y2)
                   and (DY2 mod 2 = 1))
                   or ((Y1 = Y2 + 1)
                   and (DY3 mod 4 = 2));

                 if R = 1 then
                   Place := ((Y1 = Y2 - 1)
                   and (DY1 mod 4 = 2))
                   or ((Y1 = Y2)
                   and (DY2 mod 2 = 1))
                   or ((Y1 = Y2 + 1)
                   and (DY3 mod 4 = 0));

                 if Place then
                 begin
                   TilesRoadLength[P] := TilesRoadLength[P] + 1;
                   SetLength(TilesRoadX[P], TilesRoadLength[P]);
                   SetLength(TilesRoadY[P], TilesRoadLength[P]);
                   SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                   TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                   TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                   ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 48 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := WARRIOR_OBJECT3 - (States.KaMRandomI(2) + 1) * 3 * Byte(States.KaMRandomI(3) = 0);
                 end;
               end;
             end;
           end;
      end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := -1;
    end;

    Players[P].LastUsedSkill := sFierySnake;

    Players[P].RoadSkillDelay := Round(WARRIOR_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := States.GameTime + Round(WARRIOR_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

  end;

end;  


procedure SturdyArmor(P, X, Y: Integer);
var
 X2, Y2, U, O: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= ARMOR_RADIUS)
    and (Abs(Y2 - Y) <= ARMOR_RADIUS) then
    begin
      U := States.UnitAt(X, Y);
      if U > 0 then
        O := States.UnitOwner(U);
      if (U > 0)
      and (U = States.GroupMember(Players[O].Hero, 0))
      and (not Players[O].HeroImmortal)
      and (Players[P].PlayersTeam = Players[O].PlayersTeam) then
      begin
        TilesFieldLength[P] := TilesFieldLength[P] + 4;
        SetLength(TilesFieldX[P], TilesFieldLength[P]);
        SetLength(TilesFieldY[P], TilesFieldLength[P]);
        SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
  
        TilesFieldX[P][Length(TilesFieldX[P]) - 4] := X2;
        TilesFieldX[P][Length(TilesFieldX[P]) - 3] := X2;
        TilesFieldX[P][Length(TilesFieldX[P]) - 2] := X2 - 1;
        TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X2 + 1;
    
        TilesFieldY[P][Length(TilesFieldY[P]) - 4] := Y2 + 1;
        TilesFieldY[P][Length(TilesFieldY[P]) - 3] := Y2 - 1;
        TilesFieldY[P][Length(TilesFieldY[P]) - 2] := Y2;
        TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y2;

        for I := 1 to 4 do
          TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := WARRIOR_OBJECT4;
    
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 4] := States.GameTime + 11;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 3] := States.GameTime + 12;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 2] := States.GameTime + 13;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 14;
    
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 4] := States.GameTime + 1;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 3] := States.GameTime + 2;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 2] := States.GameTime + 3;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 4;

        for I := 1 to 4 do
          if TileOnBattlefield(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) then
            if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BARB_OBJECT3)
             or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_MINE)
             or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_OBJECT5)
             or (InRange(States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
               ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] + CLEANUP_TIME;

        Players[O].ArmorStartTime := States.GameTime + ARMOR_DELAY;
        Players[P].LastUsedSkill := sSturdyArmor;
        Players[P].FieldSkillDelay := Round(WARRIOR_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
        ClearFieldTilesArrayTime[P] := States.GameTime + Round(WARRIOR_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

      end;
    end;
  end;
end;


procedure CircleOfSilence(P, X, Y: Integer);
var
  aX, aY, X1, Y1, X2, Y2, X3, Y3, G, O, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X1 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y1 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    X2 := X1 - SILENCE_RADIUS;
    X3 := X1 + SILENCE_RADIUS;
    Y2 := Y1 - SILENCE_RADIUS;
    Y3 := Y1 + SILENCE_RADIUS;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 18;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    end;

    TilesWineLength[P] := TilesWineLength[P] + 8;
    SetLength(TilesWineX[P], TilesWineLength[P]);
    SetLength(TilesWineY[P], TilesWineLength[P]);
    SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
    SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
    SetLength(TilesWineObjects[P], TilesWineLength[P]);

    TilesWineX[P][Length(TilesWineX[P]) - 8] := X1 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 7] := X1 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 6] := Y1 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 5] := Y1 + 1; 
    
    TilesWineY[P][Length(TilesWineY[P]) - 8] := Y1;
    TilesWineY[P][Length(TilesWineY[P]) - 7] := Y1;
    TilesWineX[P][Length(TilesWineX[P]) - 6] := X1;
    TilesWineX[P][Length(TilesWineX[P]) - 5] := X1; 
    
    TilesWineX[P][Length(TilesWineX[P]) - 4] := X1 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 3] := X1 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 2] := X1 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 1] := X1 + 1;
    
    TilesWineY[P][Length(TilesWineY[P]) - 4] := Y1 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 3] := Y1 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 2] := Y1 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1 - 1;

    for I := 1 to 8 do
      TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := WARRIOR_OBJECT6;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 13;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 14;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 15;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 16;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 3;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 4;
      
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 17;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 18;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 19;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 20;
    
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 5;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 6;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 7;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 8;

    for I := 1 to 8 do
      if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_MINE)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;


    for aX := X2 to X3 do
    for aY := Y2 to Y3 do
    begin
      if (TileOnBattlefield(aX, aY))      
      and (((X1 - aX) * (X1 - aX) + (Y1 - aY) * (Y1 - aY)) <= SILENCE_RADIUS * SILENCE_RADIUS)
      and (((X1 - aX) * (X1 - aX) + (Y1 - aY) * (Y1 - aY)) > (SILENCE_RADIUS - 2) * (SILENCE_RADIUS - 2)) then
      begin
        TilesWineLength[P] := TilesWineLength[P] + 1;
        SetLength(TilesWineX[P], TilesWineLength[P]);
        SetLength(TilesWineY[P], TilesWineLength[P]);
        SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
        SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
        SetLength(TilesWineObjects[P], TilesWineLength[P]);
        TilesWineX[P][Length(TilesWineX[P]) - 1] := aX;
        TilesWineY[P][Length(TilesWineY[P]) - 1] := aY;
        if (States.MapTileObject(aX, aY) <> BARB_OBJECT3)
        and (States.MapTileObject(aX, aY) <> BOWMAN_MINE) then
        begin
          ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 21 + SILENCE_TIME;
          SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 21;
          TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := WARRIOR_OBJECT5;
        end;
      end;
    end;

    for aX := X2 to X3 do
    for aY := Y2 to Y3 do
    begin
      if (TileOnBattlefield(aX, aY))      
      and (((X1 - aX) * (X1 - aX) + (Y1 - aY) * (Y1 - aY)) <= (SILENCE_RADIUS) * (SILENCE_RADIUS)) then
      begin
        G := States.GroupAt(aX, aY);
        if G > 0 then
        begin
          O := States.GroupOwner(G);
          if (G = Players[O].Hero)
          and (Players[O].PlayersTeam <> Players[P].PlayersTeam) then
            Players[O].HeroSilentStartTime := States.GameTime + 1;
        end;
      end;
    end;

    if States.PlayerIsAI(P) then
    begin
      Players[P].SkillCastDir := Direction;
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastX := X1;
      Players[P].SkillCastY := Y1;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := -1;
    end;

    Players[P].LastUsedSkill := sCircleOfSilence;

    Players[P].WineSkillDelay := Round(WARRIOR_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearWineTilesArrayTime[P] := States.GameTime + Round(WARRIOR_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

  end;

end;


//KNIGHT


procedure RopesOfDeath(P, X, Y: Integer);
var
  X2, Y2, U, O, D: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    D := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= ROPE_RADIUS)
    and (Abs(Y2 - Y) <= ROPE_RADIUS) then
    begin
      U := States.UnitAt(X, Y);
      if U <> - 1 then
        O := States.UnitOwner(U);
      if (U <> - 1)
      and (InRange(O, 0, 7))
      and (O <> P)
      and (not Players[O].HeroImmortal)
      and (U = States.GroupMember(Players[O].Hero, 0)) then
      begin
        TilesRoadLength[P] := TilesRoadLength[P] + 4;
        SetLength(TilesRoadX[P], TilesRoadLength[P]);
        SetLength(TilesRoadY[P], TilesRoadLength[P]);
        SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
        SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
        SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
  
        TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2;
        TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2;
        TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
        TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
        TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
        TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
        TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2;
        TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;

        for I := 1 to 4 do
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := KNIGHT_OBJECT;
    
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 10;
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 11;
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 12;
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 13;
    
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 1;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 2;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 3;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4;

        for I := 1 to 4 do
          if TileOnBattleField(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
            if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
             or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_MINE)
             or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
             or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

        Players[O].RopeTime := States.GameTime + ROPE_DELAY;
        Players[O].RopeAttacker := P;
        Players[O].RopeUnitDir := States.UnitDirection(States.GroupMember(Players[O].Hero, 0));
        case D of

          0: begin
               Players[O].RopeDX := 0;
               Players[O].RopeDY := -1;
             end;

          1: begin
               Players[O].RopeDX := 1;
               Players[O].RopeDY := -1;
             end;

          2: begin
               Players[O].RopeDX := 1;
               Players[O].RopeDY := 0;
             end;

          3: begin
               Players[O].RopeDX := 1;
               Players[O].RopeDY := 1;
             end;

          4: begin
               Players[O].RopeDX := 0;
               Players[O].RopeDY := 1;
             end;

          5: begin
               Players[O].RopeDX := -1;
               Players[O].RopeDY := 1;
             end;

          6: begin
               Players[O].RopeDX := -1;
               Players[O].RopeDY := 0;
             end;

          7: begin
               Players[O].RopeDX := -1;
               Players[O].RopeDY := -1;
             end;

        end;

        Players[P].LastUsedSkill := sRopesOfDeath;
        Players[P].RoadSkillDelay := Round(KNIGHT_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
        ClearRoadTilesArrayTime[P] := States.GameTime + Round(KNIGHT_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

      end;
    end;
  end;
end;


procedure DeafeningClatter(P, X, Y: Integer);
var
  X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    KnightCirclesLength[P] := KnightCirclesLength[P] + DEAFENING_CYCLES * DEAFENING_RADIUS;
    SetLength(KnightCircles[P], KnightCirclesLength[P]);
    for I := KnightCirclesLength[P] downto KnightCirclesLength[P] - DEAFENING_CYCLES * DEAFENING_RADIUS + 1 do
    begin
      KnightCircles[P][KnightCirclesLength[P] - I].Obj := KNIGHT_OBJECT3;
      KnightCircles[P][KnightCirclesLength[P] - I].X := X2;
      KnightCircles[P][KnightCirclesLength[P] - I].Y := Y2;
      KnightCircles[P][KnightCirclesLength[P] - I].AddTime := States.GameTime + Round(KNIGHT_FIELD_SPEED * (KnightCirclesLength[P] - I));
      if I mod DEAFENING_RADIUS > 0 then
        KnightCircles[P][KnightCirclesLength[P] - I].Radius := DEAFENING_RADIUS + 2 - I mod DEAFENING_RADIUS
      else
        KnightCircles[P][KnightCirclesLength[P] - I].Radius := 1;
    end;        
    for I := 0 to KnightCirclesLength[P] - 1 do 
      if I mod DEAFENING_RADIUS = 1 then
        KnightCircles[P][KnightCirclesLength[P] - I].Obj := 255;

    Players[P].LastUsedSkill := sDeafeningClatter;

    Players[P].FieldSkillDelay := Round(KNIGHT_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    TimeToClearKnightArray[P] := States.GameTime + 100;

  end;

end;


procedure RagingSpurt(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      //Players[P].CastingSkill := True;
      //Players[P].SkillTime := States.GameTime + 80;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    Actions.GroupOrderHalt(Players[P].Hero);
    Players[P].HeroStunnedTime := States.GameTime + SPURT_TIME + 5;
    Actions.GroupBlockOrders(Players[P].Hero, True);
    Players[P].HeroStunned := True;
    if not Players[P].HeroImmortal then
    begin
      Players[P].HeroImmortalTime := States.GameTime + SPURT_TIME + 5;
      Players[P].HeroImmortal := True;
    end;
    Players[P].Preparing := True;
    Players[P].PreparingTime := States.GameTime + SPURT_TIME + 5;

    if not States.PlayerIsAI(P) then
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

    TilesWineLength[P] := TilesWineLength[P] + 8;
    SetLength(TilesWineX[P], TilesWineLength[P]);
    SetLength(TilesWineY[P], TilesWineLength[P]);
    SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
    SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
    SetLength(TilesWineObjects[P], TilesWineLength[P]);

    TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 7] := X2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2 + 1; 
    
    TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2;
    TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2;
    TilesWineX[P][Length(TilesWineX[P]) - 6] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 5] := X2; 
    
    TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 + 1;
    
    TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2 - 1;

    for I := 1 to 8 do
      TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := KNIGHT_OBJECT2;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 10;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 11;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 12;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 13;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 3;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 4;    
  
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 14;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 15;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 16;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 17;
    
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 5;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 6;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 7;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 8;

    for I := 1 to 8 do
      if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_MINE)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
      or (InRange(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

    case Direction of

      0,1: for Y1 := Y2 - 1 downto Y2 - SPURT_LENGTH do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 19 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := KNIGHT_OBJECT4;
               SpurtTimes[P][Desync - 1] := States.GameTime + 19 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
               SpurtX[P][Desync - 1] := X2;
               SpurtY[P][Desync - 1] := Y1;
               SpurtDir[P][Desync - 1] := 0;
             end;

      2,3: for X1 := X2 + 1 to X2 + SPURT_LENGTH do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 19 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := KNIGHT_OBJECT4;
               SpurtTimes[P][Desync - 1] := States.GameTime + 19 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
               SpurtX[P][Desync - 1] := X1;
               SpurtY[P][Desync - 1] := Y2;
               SpurtDir[P][Desync - 1] := 2;
             end;

      4,5: for Y1 := Y2 + 1 to Y2 + SPURT_LENGTH do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 19 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := KNIGHT_OBJECT4;
               SpurtTimes[P][Desync - 1] := States.GameTime + 19 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
               SpurtX[P][Desync - 1] := X2;
               SpurtY[P][Desync - 1] := Y1;
               SpurtDir[P][Desync - 1] := 4;
             end;

      6,7: for X1 := X2 - 1 downto X2 - SPURT_LENGTH do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 19 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := KNIGHT_OBJECT4;
               SpurtTimes[P][Desync - 1] := States.GameTime + 19 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
               SpurtX[P][Desync - 1] := X1;
               SpurtY[P][Desync - 1] := Y2;
               SpurtDir[P][Desync - 1] := 6;
             end;
        end;

    {if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := -1;
    end;}

    Players[P].LastUsedSkill := sRagingSpurt;

    Players[P].WineSkillDelay := Round(KNIGHT_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearWineTilesArrayTime[P] := States.GameTime + Round(KNIGHT_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

  end;

end;


procedure CheckSpurt(P, Step: Integer);
begin
  if (States.GameTime = SpurtTimes[P][Step] + 1)
  and (States.GameTime > CHOOSE_HERO_TIMER) then
  begin
    Actions.GroupKillAll(Players[P].Hero, True);
    Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, SpurtX[P][Step], SpurtY[P][Step], SpurtDir[P][Step], 1, 1);
    Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
  end;
end;


//SCOUT


procedure Stones(P, X, Y: Integer);
var
 X2, Y2, U: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    U := States.UnitAt(X, Y);
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= STONES_RADIUS)
    and (Abs(Y2 - Y) <= STONES_RADIUS)
    and (CanPlaceObject(X, Y))
    and (States.MapTileObject(X, Y) <> SCOUT_OBJECT2)
    and (U = - 1) then
    begin
      Players[P].Stone := Players[P].Stone - 1;
      TilesRoadLength[P] := TilesRoadLength[P] + 1;
      SetLength(TilesRoadX[P], TilesRoadLength[P]);
      SetLength(TilesRoadY[P], TilesRoadLength[P]);
      SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
      SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
      SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
         
      TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X; 
      TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;

      if (not States.IsRoadAt(0, TilesRoadX[P][Length(TilesRoadX[P]) - 1], TilesRoadY[P][Length(TilesRoadY[P]) - 1]))
      and (not States.IsRoadAt(1, TilesRoadX[P][Length(TilesRoadX[P]) - 1], TilesRoadY[P][Length(TilesRoadY[P]) - 1])) 
      and (not States.IsRoadAt(2, TilesRoadX[P][Length(TilesRoadX[P]) - 1], TilesRoadY[P][Length(TilesRoadY[P]) - 1])) 
      and (not States.IsRoadAt(3, TilesRoadX[P][Length(TilesRoadX[P]) - 1], TilesRoadY[P][Length(TilesRoadY[P]) - 1])) 
      and (not States.IsRoadAt(4, TilesRoadX[P][Length(TilesRoadX[P]) - 1], TilesRoadY[P][Length(TilesRoadY[P]) - 1])) 
      and (not States.IsRoadAt(5, TilesRoadX[P][Length(TilesRoadX[P]) - 1], TilesRoadY[P][Length(TilesRoadY[P]) - 1])) 
      and (not States.IsRoadAt(6, TilesRoadX[P][Length(TilesRoadX[P]) - 1], TilesRoadY[P][Length(TilesRoadY[P]) - 1])) 
      and (not States.IsRoadAt(7, TilesRoadX[P][Length(TilesRoadX[P]) - 1], TilesRoadY[P][Length(TilesRoadY[P]) - 1])) then
      begin
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 50;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 1;
        TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT;
        if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - 1], TilesRoadY[P][Length(TilesRoadY[P]) - 1]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - 1], TilesRoadY[P][Length(TilesRoadY[P]) - 1]) = BOWMAN_MINE)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - 1], TilesRoadY[P][Length(TilesRoadY[P]) - 1]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - 1], TilesRoadY[P][Length(TilesRoadY[P]) - 1]), SWORD_OBJECT, VAGA_OBJECT6)) then
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEANUP_TIME;

        Players[P].LastUsedSkill := sStones;

        if (Players[P].Stone = 0) and (not Players[P].StoneRogue = True) then
        begin
          Players[P].RoadSkillDelay := Round(SCOUT_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
          ClearRoadTilesArrayTime[P] := States.GameTime + Round(SCOUT_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;
          Players[P].Stone := MAX_SCOUT_STONES;
          Players[P].StoneRogue := False;
        end;
      end;
    end;
  end;
end;


procedure Vampire(P, X, Y: Integer);
var
  X2, Y2, U, O, hX, hY: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if not TileOnBattlefield(X, Y) then
    Exit;

  if States.UnitAt(X, Y) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= VAMPIRE_RADIUS)
    and (Abs(Y2 - Y) <= VAMPIRE_RADIUS) then
    begin

      hX := MIN_X - 1;
      hY := MIN_Y - 1;

      while (States.UnitAt(hX, hY) > 0)
      or (States.MapTileObject(hX, hY) = SCOUT_OBJECT2)
      or (not TileOnBattlefield(hX, hY))
      or (not CanPlaceObject(hX, hY)) do
      begin
        hX := X + States.KaMRandomI(3) - States.KaMRandomI(3);
        hY := Y + States.KaMRandomI(3) - States.KaMRandomI(3);
      end;

      U := States.UnitAt(X, Y);

      if U > 0 then
      begin
        O := States.UnitOwner(U);
        if (Players[P].PlayersTeam = Players[O].PlayersTeam)
        and (P <> O) then
          Exit;
        if (InRange(O, 0, 7)) then
          if (U = States.GroupMember(Players[O].Hero, 0))
          and (not Players[O].HeroImmortal)
          and ((Players[P].PlayersTeam <> Players[O].PlayersTeam)
          or ((P = O) 
          and (Players[P].HP >= 2))) then
          begin
            TilesFieldLength[P] := TilesFieldLength[P] + 1;
            SetLength(TilesFieldX[P], TilesFieldLength[P]);
            SetLength(TilesFieldY[P], TilesFieldLength[P]);
            SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
            SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
            SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
           
            TilesFieldX[P][Length(TilesFieldX[P]) - 1] := hX;
            TilesFieldY[P][Length(TilesFieldY[P]) - 1] := hY;

            ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 175;
            SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 1;
            TilesFieldObjects[P][Length(TilesFieldObjects[P]) - 1] := SCOUT_OBJECT2;

            if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - 1], TilesFieldY[P][Length(TilesFieldY[P]) - 1]) = BARB_OBJECT3)
            or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - 1], TilesFieldY[P][Length(TilesFieldY[P]) - 1]) = BOWMAN_MINE)
            or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - 1], TilesFieldY[P][Length(TilesFieldY[P]) - 1]) = BOWMAN_OBJECT5)
            or (InRange(States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - 1], TilesFieldY[P][Length(TilesFieldY[P]) - 1]), SWORD_OBJECT, VAGA_OBJECT6)) then
              ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] + CLEANUP_TIME;

            if (not Players[O].MindStunned) and (not Players[O].CaptureMind) then
              Players[O].HP := Players[O].HP - 1;
            if Players[O].CaptureMind then
              Players[M[P]].HP := Players[M[P]].HP - 1;
            if Players[O].MindStunned then
              Players[P].HP := Players[P].HP - 1;
          end;

        if (InRange(O, 8, 11))
        and (Players[O].PlayersTeam <> Players[P].PlayersTeam) then
          Actions.UnitKill(U, False);

        Players[P].LastUsedSkill := sVampire;
        Players[P].FieldSkillDelay := Round(SCOUT_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

      end;
    end;
  end;
end;


procedure Mind(P, X, Y: Integer);
var
 X2, Y2, U, O, DirP, DirO: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= MIND_RADIUS)
    and (Abs(Y2 - Y) <= MIND_RADIUS) then
    begin
      U := States.UnitAt(X, Y);
      if U <> - 1 then
        O := States.UnitOwner(U);
      if (U <> - 1)
      and (U = States.GroupMember(Players[O].Hero, 0))
      and (not Players[O].HeroInFear)
      and (not Players[O].MindStunned)
      and (not Players[P].CaptureMind)
      and (O <> P)
      and (Players[P].PlayersTeam <> Players[O].PlayersTeam) then
      begin
        M[P] := O;
        M2[O] := P;

        if Players[P].HeroType = 27 then
          Players[O].WerewolfTime := Players[P].WerewolfTime;

        if Players[O].HeroType = 27 then
          Players[P].WerewolfTime := Players[O].WerewolfTime;

        DirP := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
        DirO := States.UnitDirection(States.GroupMember(Players[O].Hero, 0));    
        Players[P].HeroMindType := Players[P].HeroType;
        Players[O].HeroMindType := Players[O].HeroType;
        Players[P].TempHeroMindType := Players[P].TempHeroType;

        Players[P].CaptureMind := True;
        Actions.GroupKillAll(Players[P].Hero, True);
        Players[P].HeroType := Players[O].HeroType
        Players[P].Hero := Actions.GiveGroup(P, Players[O].HeroType, X, Y, DirO, 1, 1);
        Players[P].TempHeroType := Players[O].HeroType;

        Players[O].HeroStunned := True;
        Players[O].MindStunned := True;
        Actions.GroupKillAll(Players[O].Hero, True);
        Players[O].HeroType := Players[P].HeroMindType;
        Players[O].Hero := Actions.GiveGroup(O, Players[O].HeroType, X2, Y2, DirP, 1, 1);

        Players[O].CaptureMindTime := States.GameTime + CAPTURE_MIND_TIME; 
        Players[P].CaptureMindTime := States.GameTime + CAPTURE_MIND_TIME; 
        Players[O].HeroStunnedTime := States.GameTime + CAPTURE_MIND_TIME;
        Players[P].HeroImmortalTime := States.GameTime + CAPTURE_MIND_TIME;

        Actions.GroupBlockOrders(Players[O].Hero, True);
        Actions.GroupOrderHalt(Players[O].Hero);  
        Players[P].HeroImmortal := True;

        Players[P].LastUsedSkill := sMind;
        Players[P].RoadSkillDelay := Players[O].RoadSkillDelay;
        Players[P].FieldSkillDelay := Players[O].FieldSkillDelay;
        Players[P].WineSkillDelay := Players[O].WineSkillDelay;
      end;
    end;
  end;
end;


//ROGUE


procedure MentalBurst(P, X, Y, Dir: Integer);
var
  X2, Y2, Direction, Desync: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 17;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

    if (InRange(Direction, 0, 1))
    and (not TileOnBattlefield(X2, Y2 - MENTAL_DISTANCE)) then
      Exit;

    if (InRange(Direction, 2, 3))
    and (not TileOnBattlefield(X2 + MENTAL_DISTANCE, Y2)) then
      Exit;

    if (InRange(Direction, 4, 5))
    and (not TileOnBattlefield(X2, Y2 + MENTAL_DISTANCE)) then
      Exit;

    if (InRange(Direction, 6, 7))
    and (not TileOnBattlefield(X2 - MENTAL_DISTANCE, Y2)) then
      Exit;

    RogueCirclesLength[P] := RogueCirclesLength[P] + MENTAL_CYCLES * MENTAL_RADIUS;
    SetLength(RogueCircles[P], RogueCirclesLength[P]);
    TilesRoadLength[P] := TilesRoadLength[P] + 5;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);

    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;
   
    for I := 1 to 4 do
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := ROGUE_OBJECT2;
    
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 10;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 12;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 14;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 4;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 6;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8;

    for I := 1 to 5 do
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
        if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_MINE)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
        or (InRange(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    for I := RogueCirclesLength[P] downto RogueCirclesLength[P] - MENTAL_CYCLES * MENTAL_RADIUS + 1 do
    begin
      RogueCircles[P][RogueCirclesLength[P] - I].Obj := ROGUE_OBJECT;

      case Direction of 
      
      0,1: begin
             RogueCircles[P][RogueCirclesLength[P] - I].X := X2;
             RogueCircles[P][RogueCirclesLength[P] - I].Y := Y2 - MENTAL_DISTANCE;
             TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2;    
             TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2 - MENTAL_DISTANCE;
             SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
             ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
             TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := ROGUE_OBJECT4;
             TimeToClearRogueArray[P] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
             Players[P].LastUsedSkill := sMentalBurst;
             Players[P].RoadSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
             ClearRoadTilesArrayTime[P] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;
           end;

      2,3: begin
             RogueCircles[P][RogueCirclesLength[P] - I].X := X2 + MENTAL_DISTANCE;
             RogueCircles[P][RogueCirclesLength[P] - I].Y := Y2;
             TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2 + MENTAL_DISTANCE;    
             TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2;
             SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
             ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
             TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := ROGUE_OBJECT4;
             TimeToClearRogueArray[P] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
             Players[P].LastUsedSkill := sMentalBurst;
             Players[P].RoadSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
             ClearRoadTilesArrayTime[P] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;
           end;

      4,5: begin
             RogueCircles[P][RogueCirclesLength[P] - I].X := X2;
             RogueCircles[P][RogueCirclesLength[P] - I].Y := Y2 + MENTAL_DISTANCE;
             TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2;    
             TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2 + MENTAL_DISTANCE;
             SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
             ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
             TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := ROGUE_OBJECT4;
             TimeToClearRogueArray[P] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
             Players[P].LastUsedSkill := sMentalBurst;
             Players[P].RoadSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
             ClearRoadTilesArrayTime[P] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;
           end;

      6,7: begin
             RogueCircles[P][RogueCirclesLength[P] - I].X := X2 - MENTAL_DISTANCE;
             RogueCircles[P][RogueCirclesLength[P] - I].Y := Y2;
             TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2 - MENTAL_DISTANCE;    
             TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2;
             SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
             ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
             TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := ROGUE_OBJECT4;
             TimeToClearRogueArray[P] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
             Players[P].LastUsedSkill := sMentalBurst;
             Players[P].RoadSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
             ClearRoadTilesArrayTime[P] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;
           end;

      end;

    RogueCircles[P][RogueCirclesLength[P] - I].AddTime := States.GameTime + 20 + Round(ROGUE_ROAD_SPEED * (RogueCirclesLength[P] - I));
    if I mod MENTAL_RADIUS > 0 then
      RogueCircles[P][RogueCirclesLength[P] - I].Radius := MENTAL_RADIUS + 1 - I mod MENTAL_RADIUS
    else
      RogueCircles[P][RogueCirclesLength[P] - I].Radius := 1;
    end;
        
    for I := 0 to RogueCirclesLength[P] - 1 do 
      if I mod MENTAL_RADIUS = 1 then
        RogueCircles[P][RogueCirclesLength[P] - I].Obj := 255;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := -1;
    end;

  end;

end;


procedure StealSkill(P, X, Y: Integer);
var
  X2, Y2, U, O: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= STEAL_RADIUS)
    and (Abs(Y2 - Y) <= STEAL_RADIUS) then
    begin
      U := States.UnitAt(X, Y);
      if U <> - 1 then
        O := States.UnitOwner(U);
      if (U <> - 1)
      and (U = States.GroupMember(Players[O].Hero, 0))
      and (not Players[O].HeroImmortal)
      and (Players[P].PlayersTeam <> Players[O].PlayersTeam) then
      begin
        TilesFieldLength[P] := TilesFieldLength[P] + 4;
        SetLength(TilesFieldX[P], TilesFieldLength[P]);
        SetLength(TilesFieldY[P], TilesFieldLength[P]);
        SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
  
        TilesFieldX[P][Length(TilesFieldX[P]) - 4] := X2;
        TilesFieldX[P][Length(TilesFieldX[P]) - 3] := X2;
        TilesFieldX[P][Length(TilesFieldX[P]) - 2] := X2 - 1;
        TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X2 + 1;
    
        TilesFieldY[P][Length(TilesFieldY[P]) - 4] := Y2 + 1;
        TilesFieldY[P][Length(TilesFieldY[P]) - 3] := Y2 - 1;
        TilesFieldY[P][Length(TilesFieldY[P]) - 2] := Y2;
        TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y2;

        for I := 1 to 4 do
          TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := ROGUE_OBJECT3;
    
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 4] := States.GameTime + 11;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 3] := States.GameTime + 12;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 2] := States.GameTime + 13;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 14;
    
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 4] := States.GameTime + 1;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 3] := States.GameTime + 2;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 2] := States.GameTime + 3;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 4;

        for I := 1 to 4 do
          if TileOnBattlefield(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) then
            if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BARB_OBJECT3)
             or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_MINE)
             or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_OBJECT5)
             or (InRange(States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]), SWORD_OBJECT, VAGA_OBJECT6)) then
               ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] + CLEANUP_TIME;

        Players[P].StolenSkill := Players[O].LastUsedSkill;

        case Players[P].StolenSkill of

          sFieryLance: Players[P].StolenSkillName := '<$12>';
          sTeleport: Players[P].StolenSkillName := '<$20>';
          s10kSpears: Players[P].StolenSkillName := '<$28>';

          sCrackingEarth: Players[P].StolenSkillName := '<$14>';
          sWaveOfRage: Players[P].StolenSkillName := '<$22>';
          sTotem: Players[P].StolenSkillName := '<$30>';

          sSpikedEarth: Players[P].StolenSkillName := '<$9>';
          sZombieSummon: Players[P].StolenSkillName := '<$17>';
          sFear: Players[P].StolenSkillName := '<$25>';

          sAccurateShot: Players[P].StolenSkillName := '<$11>';
          sSuddenDeath: Players[P].StolenSkillName := '<$19>';
          sSniperShot: Players[P].StolenSkillName := '<$27>';

          sGravity: Players[P].StolenSkillName := '<$8>';
          sDeadlyFireworks: Players[P].StolenSkillName := '<$16>';
          sWerewolf: Players[P].StolenSkillName := '<$24>';

          sDisorientation: Players[P].StolenSkillName := '<$15>';
          sVagaWave: Players[P].StolenSkillName := '<$23>';
          sRegen: Players[P].StolenSkillName := '<$31>';

          sViseOfDeath: Players[P].StolenSkillName := '<$13>';
          sSacrificialTeleport: Players[P].StolenSkillName := '<$21>';
          sConcentration: Players[P].StolenSkillName := '<$29>';

          sMine: Players[P].StolenSkillName := '<$10>';
          sPrison: Players[P].StolenSkillName := '<$18>';
          sRevengeFromNowhere: Players[P].StolenSkillName := '<$26>';

          sFierySnake: Players[P].StolenSkillName := '<$46>';
          sSturdyArmor: Players[P].StolenSkillName := '<$47>';
          sCircleOfSilence: Players[P].StolenSkillName := '<$48>';

          sRopesOfDeath: Players[P].StolenSkillName := '<$50>';
          sDeafeningClatter: Players[P].StolenSkillName := '<$51>';
          sRagingSpurt: Players[P].StolenSkillName := '<$52>';

          sMentalBurst: Players[P].StolenSkillName := '<$55>';
          sSteal: Players[P].StolenSkillName := '<$56>';
          sUniversal: Players[P].StolenSkillName := '<$57>';

          sStones: Players[P].StolenSkillName := '<$99>';
          sVampire: Players[P].StolenSkillName := '<$101>';
          sMind: Players[P].StolenSkillName := '<$102>';

          sNone: Players[P].StolenSkillName := '<$58>';

        end;

        Players[P].LastUsedSkill := sSteal;
        Players[P].FieldSkillDelay := Round(ROGUE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

        if Players[P].StolenSkill = sTotem then
          Players[P].WineSkillDelay := ROGUE_TOTEM_DELAY

        else

        if Players[P].StolenSkill = sDeadlyFireworks then
          Players[P].WineSkillDelay := ROGUE_FIREWORKS_DELAY

        else

        if Players[P].StolenSkill = sRevengeFromNowhere then
          Players[P].WineSkillDelay := ROGUE_REVENGE_DELAY

        else

        if (Players[P].StolenSkill <> sRevengeFromNowhere)
        and (Players[P].StolenSkill <> sDeadlyFireworks)
        and (Players[P].StolenSkill <> sTotem) then
          Players[P].WineSkillDelay := ROGUE_WINE_DELAY;

        if Players[P].StolenSkill <> sNone then
          Players[P].StolenSkillTime := STOLEN_SKILL_TIME;

        ClearFieldTilesArrayTime[P] := States.GameTime + Round(WARRIOR_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;

      end;
    end;
  end;
end;


procedure UseStolenSkill(P, X, Y, Dir: Integer);
var
  X2, Y2, Direction, Desync, TempRoadSkillDelay, TempFieldSkillDelay, U, O: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    TempRoadSkillDelay := 0;
    TempFieldSkillDelay := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 17;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    U := States.UnitAt(X, Y);
    if U > 0 then
      O := States.UnitOwner(U);

    if not States.PlayerIsAI(P) then
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

    case Players[P].StolenSkill of

      sFieryLance: begin
                     TempRoadSkillDelay := Players[P].RoadSkillDelay;
                     FieryLance(P, X, Y, -1);
                     Players[P].RoadSkillDelay := TempRoadSkillDelay;
                     Players[P].WineSkillDelay := Round(LANCE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                   end;

      sTeleport: if (Abs(X - X2) <= TELEPORT_RADIUS)
                 and (Abs(Y - Y2) <= TELEPORT_RADIUS) then
                 begin
                   TempFieldSkillDelay := Players[P].FieldSkillDelay;
                   Teleport(P, X, Y);
                   Players[P].FieldSkillDelay := TempFieldSkillDelay;
                   Players[P].WineSkillDelay := Round(LANCE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                 end;

      s10kSpears: TenThousandsSpears(P, X, Y, -1);

      sCrackingEarth: begin
                        TempRoadSkillDelay := Players[P].RoadSkillDelay;
                        CrackingEarth(P, X, Y, -1);
                        Players[P].RoadSkillDelay := TempRoadSkillDelay;
                        Players[P].WineSkillDelay := Round(BARB_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                      end;

      sWaveOfRage: begin
                     TempFieldSkillDelay := Players[P].FieldSkillDelay;
                     WaveOfRage(P, X, Y);
                     Players[P].FieldSkillDelay := TempFieldSkillDelay;
                     Players[P].WineSkillDelay := Round(BARB_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                   end;

      sTotem: if (Abs(X - X2) <= TOTEM_ADD_RADIUS)
              and (Abs(Y - Y2) <= TOTEM_ADD_RADIUS) then
                TotemOfAncestors(P, X, Y);

      sSpikedEarth: begin
                      TempRoadSkillDelay := Players[P].RoadSkillDelay;
                      SpikedEarth(P, X, Y, -1);
                      Players[P].RoadSkillDelay := TempRoadSkillDelay;
                      Players[P].WineSkillDelay := Round(SWORD_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                    end;

      sZombieSummon: if (Abs(X - X2) <= MILIZOMBIE_RADIUS)
                     and (Abs(Y - Y2) <= MILIZOMBIE_RADIUS) then
                     begin
                       TempFieldSkillDelay := Players[P].FieldSkillDelay;
                       ZombieSummon(P, X, Y);
                       Players[P].FieldSkillDelay := TempFieldSkillDelay;
                       Players[P].WineSkillDelay := Round(SWORD_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                     end;

      sFear: if (U > 0)
             and (InRange(O, 0, 7))
             and (Abs(X - X2) <= IN_FEAR_RADIUS)
             and (Abs(Y - Y2) <= IN_FEAR_RADIUS)
             and (Players[P].PlayersTeam <> Players[O].PlayersTeam) then
               Fear(P, X, Y);

      sAccurateShot: begin
                       TempRoadSkillDelay := Players[P].RoadSkillDelay;
                       AccurateShot(P, X, Y, -1);
                       Players[P].RoadSkillDelay := TempRoadSkillDelay;
                       Players[P].WineSkillDelay := Round(XBOW_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                     end;

      sSuddenDeath: if (Abs(X - X2) <= BOMB_RADIUS)
                    and (Abs(Y - Y2) <= BOMB_RADIUS) then
                    begin
                      TempFieldSkillDelay := Players[P].FieldSkillDelay;
                      SuddenDeath(P, X, Y);
                      Players[P].FieldSkillDelay := TempFieldSkillDelay;
                      Players[P].WineSkillDelay := Round(XBOW_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                    end;

      sSniperShot: SniperShot(P, X, Y, -1);

      sGravity: if (Abs(X - X2) <= GRAVITY_RADIUS)
                and (Abs(Y - Y2) <= GRAVITY_RADIUS) then
                begin
                  TempRoadSkillDelay := Players[P].RoadSkillDelay;
                  Gravity(P, X, Y);
                  Players[P].RoadSkillDelay := TempRoadSkillDelay;
                  Players[P].WineSkillDelay := Round(AXE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                end;

      sDeadlyFireworks: if (Abs(X - X2) <= FIRE_RADIUS)
                        and (Abs(Y - Y2) <= FIRE_RADIUS) then
                        begin
                          TempFieldSkillDelay := Players[P].FieldSkillDelay;
                          DeadlyFireworks(P, X, Y);
                          Players[P].FieldSkillDelay := TempFieldSkillDelay;
                          Players[P].WineSkillDelay := Round(AXE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                        end;

      sWerewolf: if (Abs(X - X2) <= WEREWOLF_RADIUS)
                 and (Abs(Y - Y2) <= WEREWOLF_RADIUS) then
                   Werewolf(P, X, Y);

      sDisorientation: if (Abs(X - X2) <= SHOCK_RADIUS)
                       and (Abs(Y - Y2) <= SHOCK_RADIUS) then
                       begin
                         TempRoadSkillDelay := Players[P].RoadSkillDelay;
                         Disorientation(P, X, Y);
                         Players[P].RoadSkillDelay := TempRoadSkillDelay;
                         Players[P].WineSkillDelay := Round(VAGA_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                       end;

      sVagaWave: begin
                   TempFieldSkillDelay := Players[P].FieldSkillDelay;
                   VagaWave(P, X, Y);
                   Players[P].FieldSkillDelay := TempFieldSkillDelay;
                   Players[P].WineSkillDelay := Round(VAGA_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                 end;

      sRegen: if (Abs(X - X2) <= REGEN_RADIUS)
              and (Abs(Y - Y2) <= REGEN_RADIUS) then
                Regen(P, X, Y);

      sViseOfDeath: begin
                      TempRoadSkillDelay := Players[P].RoadSkillDelay;
                      ViseOfDeath(P, X, Y, -1);
                      Players[P].RoadSkillDelay := TempRoadSkillDelay;
                      Players[P].WineSkillDelay := Round(PIKE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                    end;

      sSacrificialTeleport: if (Abs(X - X2) <= SACRIFICIAL_RADIUS)
                            and (Abs(Y - Y2) <= SACRIFICIAL_RADIUS)
                            and (Players[P].HP > 1) then
                            begin
                              TempFieldSkillDelay := Players[P].FieldSkillDelay;
                              SacrificialTeleport(P, X, Y);
                              Players[P].FieldSkillDelay := TempFieldSkillDelay;
                              Players[P].WineSkillDelay := Round(PIKE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                            end;

      sConcentration: Concentration(P, X, Y);

      sMine: if CanPlaceMine(P, X2, Y2) then
             begin
               TempRoadSkillDelay := Players[P].RoadSkillDelay;
               CatchTheBomb(P, X, Y, -1);
               Players[P].RoadSkillDelay := TempRoadSkillDelay;
               Players[P].WineSkillDelay := Round(BOWMAN_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
             end;

      sPrison: if (U > 0)
               and (Abs(X - X2) <= PRISON_RADIUS)
               and (Abs(Y - Y2) <= PRISON_RADIUS) then
               begin
                 TempFieldSkillDelay := Players[P].FieldSkillDelay;
                 Prison(P, X, Y);
                 Players[P].FieldSkillDelay := TempFieldSkillDelay;
                 Players[P].WineSkillDelay := Round(BOWMAN_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               end;

      sRevengeFromNowhere: RevengeFromNowhere(P, X, Y, -1);

      sFierySnake: begin
                     TempRoadSkillDelay := Players[P].RoadSkillDelay;
                     FierySnake(P, X, Y, -1);
                     Players[P].RoadSkillDelay := TempRoadSkillDelay;
                     Players[P].WineSkillDelay := Round(WARRIOR_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                   end;

      sSturdyArmor: if (U > 0)
                    and (InRange(O, 0, 7))
                    and (Abs(X - X2) <= ARMOR_RADIUS)
                    and (Abs(Y - Y2) <= ARMOR_RADIUS)
                    and (Players[P].PlayersTeam = Players[O].PlayersTeam) then
                    begin
                      TempFieldSkillDelay := Players[P].FieldSkillDelay;
                      SturdyArmor(P, X, Y);
                      Players[P].FieldSkillDelay := TempFieldSkillDelay;
                      Players[P].WineSkillDelay := Round(WARRIOR_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                    end;

      sCircleOfSilence: CircleOfSilence(P, X, Y);

      sRopesOfDeath: if (U > 0)
                     and (InRange(O, 0, 7))
                     and (Abs(X - X2) <= ROPE_RADIUS)
                     and (Abs(Y - Y2) <= ROPE_RADIUS) then
                     begin
                       TempRoadSkillDelay := Players[P].RoadSkillDelay;
                       RopesOfDeath(P, X, Y);
                       Players[P].RoadSkillDelay := TempRoadSkillDelay;
                       Players[P].WineSkillDelay := Round(KNIGHT_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                     end;

      sDeafeningClatter: begin
                           TempFieldSkillDelay := Players[P].FieldSkillDelay;
                           DeafeningClatter(P, X, Y);
                           Players[P].FieldSkillDelay := TempFieldSkillDelay;
                           Players[P].WineSkillDelay := Round(KNIGHT_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                         end;

      sRagingSpurt: RagingSpurt(P, X, Y, -1);

      sMentalBurst: begin
                      TempRoadSkillDelay := Players[P].RoadSkillDelay;
                      MentalBurst(P, X, Y, -1);
                      Players[P].RoadSkillDelay := TempRoadSkillDelay;
                      Players[P].WineSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                    end;

      sSteal: if (U > 0)
              and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
              and (InRange(O, 0, 7))
              and (Abs(X - X2) <= STEAL_RADIUS)
              and (Abs(Y - Y2) <= STEAL_RADIUS) then
              begin
                TempFieldSkillDelay := Players[P].FieldSkillDelay;
                StealSkill(P, X, Y);
                Players[P].FieldSkillDelay := TempFieldSkillDelay;
                Players[P].WineSkillDelay := Round(ROGUE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
              end;

      sStones: begin
                 Players[P].StoneRogue := True;
                 TempRoadSkillDelay := Players[P].RoadSkillDelay;
                 Stones(P, X, Y);
                 Players[P].RoadSkillDelay := TempRoadSkillDelay;
                 if Players[P].Stone = 0 then
                 begin
                   Players[P].WineSkillDelay := Round(SCOUT_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                   ClearRoadTilesArrayTime[P] := States.GameTime + Round(SCOUT_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - 5;
                   Players[P].Stone := MAX_SCOUT_STONES;
                 end;
               end;

      sVampire: if (U > 0)
             and (Abs(X - X2) <= VAMPIRE_RADIUS)
             and (Abs(Y - Y2) <= VAMPIRE_RADIUS)
             and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
             or (P = O) then
             begin
               TempFieldSkillDelay := Players[P].FieldSkillDelay;
               Vampire(P, X, Y);
               Players[P].FieldSkillDelay := TempFieldSkillDelay;
               Players[P].WineSkillDelay := Round(SCOUT_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
             end;

      sMind: if (U > 0)
             and (Abs(X - X2) <= MIND_RADIUS)
             and (Abs(Y - Y2) <= MIND_RADIUS)
             and (Players[P].PlayersTeam <> Players[O].PlayersTeam) then
               Mind(P, X, Y);

      sUniversal: Exit;

      sNone: Players[P].StolenSkillName := '<$58>';

    end; 
  end;
end;


procedure OnPlanRoadPlaced(P, X, Y: Integer);
begin

  Actions.PlanRemove(P, X, Y);

//Choose Hero

  if (not Players[P].HeroChosen)
  and (Players[P].Hero = -1)
  and (States.UnitAt(X, Y) > 0)
  and (InRange(States.UnitType(States.UnitAt(X, Y)), 14, 27)) then
  begin
    Players[P].HeroType := States.UnitType(States.UnitAt(X, Y));
    Players[P].TempHeroType := Players[P].HeroType;
    Players[P].HeroMindType := Players[P].HeroType;
    Players[P].TempHeroMindType := Players[P].HeroType;
    Players[P].HeroChosen := True;
    Actions.ShowMsg(P, HeroDescription(P, Players[P].HeroType));
    if InRange(P, 0, 3) then
      TeamChoice[0] := TeamChoice[0] + '|[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[] <$32> ' + States.UnitTypeName(Players[P].HeroType);
    if InRange(P, 4, 7) then
      TeamChoice[1] := TeamChoice[1] + '|[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[] <$32> ' + States.UnitTypeName(Players[P].HeroType);
  end;

  if Players[P].HP <= 0 then
    Exit;

  if not TileOnBattlefield(X, Y) then
    Exit;
  
//Use skills

//Vaga-Vaga - Disorientation

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 27)
  and (Players[P].RoadSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    Disorientation(P, X, Y);

//Axe Fighter - Gravity

  if (Players[P].Hero <> -1)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 15)
  and (Players[P].RoadSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    Gravity(P, X, Y);

//Pikeman - Vise of Death

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 20)
  and (Players[P].RoadSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    ViseOfDeath(P, X, Y, -1);

//Sword Fighter - Spiked Earth

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 16)
  and (Players[P].RoadSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    SpikedEarth(P, X, Y, -1);
  
//Crossbowman - Accurate Shot

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 18)
  and (Players[P].RoadSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    AccurateShot(P, X, Y, -1);

//Bowman - Catch the Bomb!

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 17)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and (Players[P].RoadSkillDelay = 0)
  and not (Players[P].HeroSilent) then
    CatchTheBomb(P, X, Y, -1);
  
//Lance Carrier - Fiery Lance

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 19)
  and (Players[P].RoadSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    FieryLance(P, X, Y, -1);

//Barbarian - Cracking Earth

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 23)
  and (Players[P].RoadSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    CrackingEarth(P, X, Y, -1);

//Warrior - Fiery Snake

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 26)
  and (Players[P].RoadSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    FierySnake(P, X, Y, -1);

//Knight - Ropes of Death

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 22)
  and (Players[P].RoadSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    RopesOfDeath(P, X, Y);

//Rogue - Mental Burst

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 25)
  and (Players[P].RoadSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    MentalBurst(P, X, Y, -1);

//Scout - Stones

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 21)
  and (Players[P].RoadSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    Stones(P, X, Y);

end;


procedure OnPlanFieldPlaced(P, X, Y: Integer);
begin

  Actions.PlanRemove(P, X, Y);

  if Players[P].HP <= 0 then
    Exit;

  if not TileOnBattlefield(X, Y) then
    Exit;

//Use skills

//Sword Fighter - Milizombie Summon

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 16)
  and (Players[P].FieldSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    ZombieSummon(P, X, Y);

//Axe Fighter - Deadly Fireworks

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 15)
  and (Players[P].FieldSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    DeadlyFireworks(P, X, Y);

//Bowman - Prison

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 17)
  and (Players[P].FieldSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent)
  and (States.UnitAt(X, Y) > 0) then
    Prison(P, X, Y);

//Crossbowman - Sudden Death

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 18)
  and (Players[P].FieldSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    SuddenDeath(P, X, Y);


//Barbarian - Wave of Rage

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 23)
  and (Players[P].FieldSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    WaveOfRage(P, X, Y);

//Vaga-Vaga - Vaga-Wave

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 27)
  and (Players[P].FieldSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    VagaWave(P, X, Y);
   
//Lance Carrier - Teleport

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 19)
  and (Players[P].FieldSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    Teleport(P, X, Y);

//Pikeman - Sacrificial Teleport

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 20)
  and (Players[P].FieldSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    SacrificialTeleport(P, X, Y);

//Warrior - Sturdy Armor

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 26)
  and (Players[P].FieldSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    SturdyArmor(P, X, Y);

//Knight - Deafening Clatter

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 22)
  and (Players[P].FieldSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    DeafeningClatter(P, X, Y);

//Rogue - Steal Skills

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 25)
  and (Players[P].FieldSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    StealSkill(P, X, Y);

//Scout - Vampire

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 21)
  and (Players[P].FieldSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    Vampire(P, X, Y);

end;

  
procedure OnPlanWinefieldPlaced(P, X, Y: Integer);
begin

  Actions.PlanRemove(P, X, Y);

  if Players[P].HP <= 0 then
    Exit;

  if not TileOnBattlefield(X, Y) then
    Exit;

//Use skills

//Vaga-Vaga - Regen

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 27)
  and (Players[P].WineSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    Regen(P, X, Y);

//Axe Fighter - Werewolf

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 15)
  and (Players[P].WineSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    Werewolf(P, X, Y);

//Sword Fighter - Fear

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 16)
  and (Players[P].WineSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    Fear(P, X, Y);

//Barbarian - Totem of Ancestors

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 23)
  and (Players[P].WineSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    TotemOfAncestors(P, X, Y);

//Pikeman - Concentration

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 20)
  and (Players[P].WineSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    Concentration(P, X, Y);

//Crossbowman - Sniper Shot

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 18)
  and (Players[P].WineSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    SniperShot(P, X, Y, -1);

//Bowman - Revenge from Nowhere

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 17)
  and (Players[P].WineSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    RevengeFromNowhere(P, X, Y, -1);

//Lance Carrier - Ten Thousands Spears

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 19)
  and (Players[P].WineSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    TenThousandsSpears(P, X, Y, -1);

//Warrior - Circle of Silence

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 26)
  and (Players[P].WineSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    CircleOfSilence(P, X, Y);

//Knight - Raging Spurt

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 22)
  and (Players[P].WineSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    RagingSpurt(P, X, Y, -1);

//Rogue - Use Stolen Skill

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 25)
  and (Players[P].WineSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    UseStolenSkill(P, X, Y, -1);

//Scout - Mind

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].HeroType = 21)
  and (Players[P].WineSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
    Mind(P, X, Y);

end;


procedure CheckTiles(P: Integer);
var
  T, aX, aY, aObj: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;
  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;
  if Players[P].Hero > 0 then
  if not States.GroupDead(Players[P].Hero) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
  end;
  if aX <= 0 then
    Exit;
  if aY <= 0 then
    Exit;
  if (TileOnBattlefield(aX, aY))
  or (States.MapTileType(aX, aY) = 152) then
    aObj := States.MapTileObject(aX, aY);
  if aObj = PikeObjects[P] then
    Exit;

  if (aObj = BOWMAN_MINE)
  and (InRange(P, 0, 3))
  and (States.PlayerIsAI(P))
  and (Roads[aX][aY].Owner = 8) then
    Exit;

  if (aObj = BOWMAN_MINE)
  and (InRange(P, 4, 7))
  and (States.PlayerIsAI(P))
  and (Roads[aX][aY].Owner = 9) then
    Exit;

  if (aObj = LANCE_OBJECT)
  or (aObj = LANCE_OBJECT2)
  or (aObj = LANCE_OBJECT3)
  or (aObj = BARB_OBJECT)
  or (aObj = BARB_OBJECT2)
  or (aObj = BARB_OBJECT3)
  or (aObj = BARB_OBJECT4)
  or (aObj = BARB_OBJECT5)
  or (aObj = XBOW_OBJECT)
  or (aObj = XBOW_OBJECT2)
  or (aObj = XBOW_OBJECT3)
  or (aObj = PIKE_OBJECT)
  or (aObj = PIKE_OBJECT2)
  or (aObj = PIKE_OBJECT3)
  or (aObj = PIKE_OBJECT4)
  or (aObj = PIKE_OBJECT5)
  or (aObj = PIKE_OBJECT6)
  or (aObj = PIKE_OBJECT7)
  or (aObj = PIKE_OBJECT8)
  or (aObj = PIKE_OBJECT9)
  or (aObj = BOWMAN_OBJECT)
  or (aObj = BOWMAN_OBJECT2)
  or (aObj = BOWMAN_OBJECT3)
  or (aObj = BOWMAN_OBJECT4)
  or (aObj = BOWMAN_MINE)
  or (aObj = AXE_OBJECT2)
  or (aObj = AXE_OBJECT3)
  or (aObj = VAGA_OBJECT2)
  or (aObj = WARRIOR_OBJECT3)
  or (aObj = WARRIOR_OBJECT)
  or (aObj = WARRIOR_OBJECT2)
  or (aObj = WARRIOR_OBJECT5)
  or (aObj = WARRIOR_OBJECT6)
  or (aObj = WARRIOR_OBJECT6 + 1)
  or (aObj = KNIGHT_OBJECT4)
  or (aObj = ROGUE_OBJECT)
  or (aObj = ROGUE_OBJECT2)
  or (aObj = ROGUE_OBJECT4) then
  begin
    T := Players[P].HeroType;
    if (not States.PlayerDefeated(P))
    and (not Players[P].HeroImmortal) then
    begin
      if Players[P].HP > 0 then
      begin 
      Actions.GroupKillAll(Players[P].Hero, False);
      Players[P].Hero := Actions.GiveGroup(P, T, Players[P].SpawnX, Players[P].SpawnY, Players[P].Direction, 1, 1);
      if not (Players[P].CaptureMind)
      and not (Players[P].MindStunned) then
          Players[P].HP := Players[P].HP - 1;
        if Players[P].CaptureMind then
          Players[M[P]].HP := Players[M[P]].HP - 1;
        if Players[P].MindStunned then
        begin
          Players[M2[P]].HP := Players[M2[P]].HP - 1;
          Actions.GroupBlockOrders(Players[P].Hero, True);
          Actions.GroupOrderHalt(Players[P].Hero);
        end;
      end;
      Players[P].HeroImmortal := True;
      Players[P].HeroImmortalTime := States.GameTime + IMMORTAL_TIME;
      Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
      Actions.CinematicStart(P);
      Actions.CinematicPanTo(P, Players[P].SpawnX, Players[P].SpawnY, 0);
      Actions.CinematicEnd(P);
    end;
  end;

  if aObj = VAGA_OBJECT then
  begin
    if (not Players[P].MindStunned) and (not Players[P].CaptureMind) then
      if States.GameTime > Players[P].RegenDelay then
        if Players[P].HP < MAX_HP then
        begin
          Players[P].HP := Players[P].HP + 1;
          Players[P].RegenDelay := States.GameTime + REGEN_DELAY;
          Actions.MapTileObjectSet(aX, aY, 255);
        end;
    if Players[P].CaptureMind then
      if States.GameTime > Players[M[P]].RegenDelay then
        if Players[M[P]].HP < MAX_HP then
        begin
          Players[M[P]].HP := Players[M[P]].HP + 1;
          Players[M[P]].RegenDelay := States.GameTime + REGEN_DELAY;
          Actions.MapTileObjectSet(aX, aY, 255);
        end;
    if Players[P].MindStunned then
      if States.GameTime > Players[M2[P]].RegenDelay then
        if Players[M2[P]].HP < MAX_HP then
        begin
          Players[M2[P]].HP := Players[M2[P]].HP + 1;
          Players[M2[P]].RegenDelay := States.GameTime + REGEN_DELAY;
          Actions.MapTileObjectSet(aX, aY, 255);
        end;
  end;

  if aObj = RUNE_DOUBLE_OBJ then
  begin
    if States.GameTime > Players[P].DDTime then
    begin
      Players[P].DD := True;
      Players[P].DDTime := States.GameTime + RUNE_DOUBLE_TIME;
      Actions.MapTileObjectSet(aX, aY, 255);
    end;
  end;

  if aObj = RUNE_IMMORTAL_OBJ then
  begin
    if States.GameTime > Players[P].HeroImmortalTime then
    begin
      Players[P].HeroImmortal := True;
      Players[P].HeroImmortalTime := States.GameTime + RUNE_IMMORTAL_TIME;
      Actions.MapTileObjectSet(aX, aY, 255);
    end;
  end;

  if aObj = RUNE_ILLUSION_OBJ then
  begin
    Players[P].InIllusion := True;
    for I := 0 to 3 do
    begin
      ZomboHero[P][I] := Actions.GiveGroup(Players[P].ZombiePlayer, Players[P].HeroType, RUNE_X + States.KaMRandomI(5) - States.KaMRandomI(5), RUNE_Y + States.KaMRandomI(5) - States.KaMRandomI(5), States.KaMRandomI(8), 1, 1);
      Actions.GroupHungerSet(ZomboHero[P][I], RUNE_ZOMBIE_LIFE);
      Actions.MapTileObjectSet(aX, aY, 255);
    end;
  end;

  if aObj = RUNE_RECHARGE_OBJ then
  begin
    Players[P].ReCharge := True;
    Players[P].ReChargeTime := States.GameTime + RUNE_RECHARGE_TIME;
    Players[P].RoadSkillDelay := 0;
    Players[P].FieldSkillDelay := 0;
    if Players[P].HeroType <> 25 then
      Players[P].WineSkillDelay := 0;
    Actions.MapTileObjectSet(aX, aY, 255);
  end;

  if aObj = BOWMAN_MINE then
  begin
    Actions.MapTileObjectSet(aX, aY, 255);
    if InRange(Roads[aX][aY].Owner, 8, 11) then
      Actions.PlanRemove(Roads[aX][aY].Owner, aX, aY);
    Roads[aX][aY].Owner := -1;
  end;

  if InRange(aObj, SWORD_OBJECT, SWORD_OBJECT + 3) then
  begin
    if (not States.PlayerDefeated(P))
    and (not Players[P].HeroImmortal) then
    begin
      if Players[P].Hero > 0 then
      begin
        Actions.GroupBlockOrders(Players[P].Hero, True);
        Actions.GroupOrderHalt(Players[P].Hero);
      end;
      Players[P].HeroStunnedTime := States.GameTime + STUNNED_TIME;
      Players[P].HeroStunned := True;
    end;
  end;

  if aObj = VAGA_OBJECT6 then
  begin
    if (not States.PlayerDefeated(P))
    and (not Players[P].HeroImmortal) then
    begin
      if Players[P].Hero > 0 then
      begin
        Actions.GroupBlockOrders(Players[P].Hero, True);
        Actions.GroupOrderHalt(Players[P].Hero);
      end;
      Players[P].HeroStunnedTime := States.GameTime + SHOCK_TIME;
      Players[P].HeroStunned := True;
    end;
  end;

  if aObj = KNIGHT_OBJECT3 then
  begin
    if (not States.PlayerDefeated(P))
    and (not Players[P].HeroImmortal) then
    begin
      if Players[P].Hero > 0 then
      begin
        Actions.GroupBlockOrders(Players[P].Hero, True);
        Actions.GroupOrderHalt(Players[P].Hero);
      end;
      Players[P].HeroStunnedTime := States.GameTime + DEAFENING_TIME;
      Players[P].HeroStunned := True;
    end;
  end;

end;


procedure CheckTilesForAI;
var
  AIUnits: array of Integer;
  aObj: Integer;
  aX, aY: Integer;
begin
  for I := 9 to 11 do
  begin
    AIUnits := States.PlayerGetAllUnits(I);
    for K := 0 to length(AIUnits) - 1 do
    begin
      if AIUnits[K] > 0 then
      begin
        aX := States.UnitPositionX(AIUnits[K]);
        aY := States.UnitPositionY(AIUnits[K]);
      end;
      if TileOnBattlefield(aX, aY) then
        aObj := States.MapTileObject(aX, aY);
      if (aObj = LANCE_OBJECT)
      or (aObj = LANCE_OBJECT2)
      or (aObj = LANCE_OBJECT3)
      or (aObj = BARB_OBJECT)
      or (aObj = BARB_OBJECT2)
      or (aObj = BARB_OBJECT3)
      or (aObj = BARB_OBJECT4)
      or (aObj = BARB_OBJECT5)
      or (aObj = XBOW_OBJECT)
      or (aObj = XBOW_OBJECT2)
      or (aObj = XBOW_OBJECT3)
      or (aObj = PIKE_OBJECT)
      or (aObj = PIKE_OBJECT2)
      or (aObj = PIKE_OBJECT3)
      or (aObj = PIKE_OBJECT4)
      or (aObj = PIKE_OBJECT5)
      or (aObj = PIKE_OBJECT6)
      or (aObj = PIKE_OBJECT7)
      or (aObj = PIKE_OBJECT8)
      or (aObj = PIKE_OBJECT9)
      or (aObj = BOWMAN_OBJECT)
      or (aObj = BOWMAN_OBJECT2)
      or (aObj = BOWMAN_OBJECT3)
      or (aObj = BOWMAN_OBJECT4)
      or (aObj = BOWMAN_MINE)
      or (aObj = AXE_OBJECT2)
      or (aObj = AXE_OBJECT3)
      or (aObj = VAGA_OBJECT2)
      or (aObj = WARRIOR_OBJECT3)
      or (aObj = WARRIOR_OBJECT)
      or (aObj = WARRIOR_OBJECT2)
      or (aObj = WARRIOR_OBJECT5)
      or (aObj = WARRIOR_OBJECT6)
      or (aObj = WARRIOR_OBJECT6 + 1)
      or (aObj = KNIGHT_OBJECT4)
      or (aObj = ROGUE_OBJECT)
      or (aObj = ROGUE_OBJECT2)
      or (aObj = ROGUE_OBJECT4) then
        Actions.UnitKill(AIUnits[K], False);

      if aObj = BOWMAN_MINE then
      begin
        Actions.MapTileObjectSet(aX, aY, 255);
        if InRange(Roads[aX][aY].Owner, 8, 11) then
          Actions.PlanRemove(Roads[aX][aY].Owner, aX, aY);
        Roads[aX][aY].Owner := -1;
      end;

    end;
  end;
end;


function TileIsDangerous(X, Y: Integer): Boolean;
var
  aObj: Integer;
begin
  Result := False;
  if TileonBattlefield(X, Y) then
  begin
    aObj := States.MapTileobject(X, Y);
    Result := ((aObj = LANCE_OBJECT)
              or (aObj = LANCE_OBJECT2)
              or (aObj = LANCE_OBJECT3)
              or (aObj = BARB_OBJECT)
              or (aObj = BARB_OBJECT2)
              or (aObj = BARB_OBJECT3)
              or (aObj = BARB_OBJECT4)
              or (aObj = BARB_OBJECT5)
              or (aObj = XBOW_OBJECT)
              or (aObj = XBOW_OBJECT2)
              or (aObj = XBOW_OBJECT3)
              or (aObj = PIKE_OBJECT)
              or (aObj = PIKE_OBJECT2)
              or (aObj = PIKE_OBJECT3)
              or (aObj = PIKE_OBJECT4)
              or (aObj = PIKE_OBJECT5)
              or (aObj = PIKE_OBJECT6)
              or (aObj = PIKE_OBJECT7)
              or (aObj = PIKE_OBJECT8)
              or (aObj = PIKE_OBJECT9)
              or (aObj = BOWMAN_OBJECT)
              or (aObj = BOWMAN_OBJECT2)
              or (aObj = BOWMAN_OBJECT3)
              or (aObj = BOWMAN_OBJECT4)
              or (aObj = BOWMAN_MINE)
              or (aObj = AXE_OBJECT2)
              or (aObj = AXE_OBJECT3)
              or (aObj = VAGA_OBJECT2)
              or (aObj = WARRIOR_OBJECT3)
              or (aObj = WARRIOR_OBJECT)
              or (aObj = WARRIOR_OBJECT2)
              or (aObj = WARRIOR_OBJECT5)
              or (aObj = WARRIOR_OBJECT6)
              or (aObj = WARRIOR_OBJECT6 + 1)
              or (aObj = KNIGHT_OBJECT4)
              or (aObj = ROGUE_OBJECT)
              or (aObj = ROGUE_OBJECT2)
              or (aObj = ROGUE_OBJECT4));
  end;
end;


procedure CheckVictoryDefeat;
var
  TeamPlayersCount: array[0..1] of Integer;
begin
  for I := 0 to 1 do
    TeamPlayersCount[I] := 0;

  for I := 0 to 7 do
    if States.PlayerEnabled(I) then
    begin
      if Players[I].HP = 0 then
        Actions.PlayerDefeat(I);
    end;

  for J := 0 to 3 do
    if States.PlayerEnabled(J) then
      if not States.PlayerDefeated(J) then
        TeamPlayersCount[0] := TeamPlayersCount[0] + 1;

  for J := 4 to 7 do
    if States.PlayerEnabled(J) then
      if not States.PlayerDefeated(J) then
        TeamPlayersCount[1] := TeamPlayersCount[1] + 1;

  if TeamPlayersCount[0] = 0 then
    for J := 3 to 7 do
      if States.PlayerEnabled(J) then
        if not States.PlayerDefeated(J) then
          Actions.PlayerWin([J], True);

  if TeamPlayersCount[1] = 0 then
    for J := 0 to 3 do
      if States.PlayerEnabled(J) then
        if not States.PlayerDefeated(J) then
          Actions.PlayerWin([J], True);

  for I := 0 to 7 do
    if States.PlayerEnabled(I) then
      if Players[I].HP = 0 then
      begin
        if (States.UnitPositionX(States.GroupMember(Players[I].Hero, 0)) <> Players[I].TribuneX)
        and (States.UnitPositionY(States.GroupMember(Players[I].Hero, 0)) <> Players[I].TribuneY) then
        begin
          Actions.GroupKillAll(Players[I].Hero, True);
          Players[I].Hero := Actions.GiveGroup(I, Players[I].HeroType, Players[I].TribuneX, Players[I].TribuneY, 4, 1, 1);
          Actions.GroupHungerSet(Players[I].Hero, States.UnitMaxHunger);
        end;
      end;

end;


procedure CheckTotemCircles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    if TotemCirclesLength[P] > 0 then
      for I := 0 to TotemCirclesLength[P] - 1 do
      begin
        if TileOnBattlefield(TotemCircles[P][I].X, TotemCircles[P][I].Y) then
        begin
          if (States.GameTime = TotemCircles[P][I].AddTime) then
            SetCircle(P, TotemCircles[P][I].X, TotemCircles[P][I].Y, TotemCircles[P][I].Radius, TotemCircles[P][I].Obj, False, False, True);
        end;
      end;
end;


procedure CheckRageCircles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    if RageCirclesLength[P] > 0 then
      for I := 0 to RageCirclesLength[P] - 1 do
      begin
        if TileOnBattlefield(RageCircles[P][I].X, RageCircles[P][I].Y) then
        begin
          if (States.GameTime = RageCircles[P][I].AddTime) then
            SetCircle(P, RageCircles[P][I].X, RageCircles[P][I].Y, RageCircles[P][I].Radius, RageCircles[P][I].Obj, True, False, true);
        end;
      end;
end;


procedure CheckVagaCircles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    if VagaCirclesLength[P] > 0 then
      for I := 0 to VagaCirclesLength[P] - 1 do
      begin
        if TileOnBattlefield(VagaCircles[P][I].X, VagaCircles[P][I].Y) then
        begin
          if (States.GameTime = VagaCircles[P][I].AddTime) then
            SetCircle(P, VagaCircles[P][I].X, VagaCircles[P][I].Y, VagaCircles[P][I].Radius, VagaCircles[P][I].Obj, True, False, True);
        end;
      end;
end;


procedure CheckFireworks1Circles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    if FireworksCircles1Length[P] > 0 then
      for I := 0 to FireworksCircles1Length[P] - 1 do
      begin
        if TileOnBattlefield(FireworksCircles1[P][I].X, FireworksCircles1[P][I].Y) then
        begin
          if (States.GameTime = FireworksCircles1[P][I].AddTime) then
            SetCircle(P, FireworksCircles1[P][I].X, FireworksCircles1[P][I].Y, FireworksCircles1[P][I].Radius, FireworksCircles1[P][I].Obj, False, False, True);
        end;
      end;
end;


procedure CheckFireworks2Circles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    if FireworksCircles2Length[P] > 0 then
      for I := 0 to FireworksCircles2Length[P] - 1 do
      begin
        if TileOnBattlefield(FireworksCircles2[P][I].X, FireworksCircles2[P][I].Y) then
        begin
          if (States.GameTime = FireworksCircles2[P][I].AddTime) then
            SetCircle(P, FireworksCircles2[P][I].X, FireworksCircles2[P][I].Y, FireworksCircles2[P][I].Radius, FireworksCircles2[P][I].Obj, False, False, True);
        end;
      end;
end;


procedure CheckFireworks3Circles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    if FireworksCircles3Length[P] > 0 then
      for I := 0 to FireworksCircles3Length[P] - 1 do
      begin
        if TileOnBattlefield(FireworksCircles3[P][I].X, FireworksCircles3[P][I].Y) then
        begin
          if (States.GameTime = FireworksCircles3[P][I].AddTime) then
            SetCircle(P, FireworksCircles3[P][I].X, FireworksCircles3[P][I].Y, FireworksCircles3[P][I].Radius, FireworksCircles3[P][I].Obj, False, False, True);
        end;
      end;
end;


procedure CheckFireworks4Circles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    if FireworksCircles4Length[P] > 0 then
      for I := 0 to FireworksCircles4Length[P] - 1 do
      begin
        if TileOnBattlefield(FireworksCircles4[P][I].X, FireworksCircles4[P][I].Y) then
        begin
          if (States.GameTime = FireworksCircles4[P][I].AddTime) then
            SetCircle(P, FireworksCircles4[P][I].X, FireworksCircles4[P][I].Y, FireworksCircles4[P][I].Radius, FireworksCircles4[P][I].Obj, False, False, True);
        end;
      end;
end;


procedure CheckFireworks5Circles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    if FireworksCircles5Length[P] > 0 then
      for I := 0 to FireworksCircles5Length[P] - 1 do
      begin
        if TileOnBattlefield(FireworksCircles5[P][I].X, FireworksCircles5[P][I].Y) then
        begin
          if (States.GameTime = FireworksCircles2[P][I].AddTime) then
            SetCircle(P, FireworksCircles5[P][I].X, FireworksCircles5[P][I].Y, FireworksCircles5[P][I].Radius, FireworksCircles5[P][I].Obj, False, False, True);
        end;
      end;
end;


procedure CheckExpCircles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    if ExpCirclesLength[P] > 0 then
      for I := 0 to ExpCirclesLength[P] - 1 do
      begin
        if TileOnBattlefield(ExpCircles[P][I].X, ExpCircles[P][I].Y) then
        begin
          if (States.GameTime = ExpCircles[P][I].AddTime) then
            SetCircle(P, ExpCircles[P][I].X, ExpCircles[P][I].Y, ExpCircles[P][I].Radius, ExpCircles[P][I].Obj, False, False, True);
        end;
      end;
end;


procedure CheckKnightCircles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    if KnightCirclesLength[P] > 0 then
      for I := 0 to KnightCirclesLength[P] - 1 do
      begin
        if TileOnBattlefield(KnightCircles[P][I].X, KnightCircles[P][I].Y) then
        begin
          if (States.GameTime = KnightCircles[P][I].AddTime) then
          begin
            SetCircle(P, KnightCircles[P][I].X, KnightCircles[P][I].Y, KnightCircles[P][I].Radius, KnightCircles[P][I].Obj, True, False, False);
          end;
        end;
      end;
end;


procedure CheckRogueCircles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    if RogueCirclesLength[P] > 0 then
      for I := 0 to RogueCirclesLength[P] - 1 do
      begin
        if TileOnBattlefield(RogueCircles[P][I].X, RogueCircles[P][I].Y) then
        begin
          if (States.GameTime = RogueCircles[P][I].AddTime) then
          begin
            SetCircle(P, RogueCircles[P][I].X, RogueCircles[P][I].Y, RogueCircles[P][I].Radius, RogueCircles[P][I].Obj, False, False, True);
          end;
        end;
      end;
end;


procedure CheckViseCircles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    if ViseCirclesLength[P] > 0 then
      for I := 0 to ViseCirclesLength[P] - 1 do
      begin
        if TileOnBattlefield(ViseCircles[P][I].X, ViseCircles[P][I].Y) then
        begin
          if (States.GameTime = ViseCircles[P][I].AddTime) then
          begin
            SetCircle(P, ViseCircles[P][I].X, ViseCircles[P][I].Y, VISE_RADIUS, 255, False, False, True);
            SetCircle(P, ViseCircles[P][I].X, ViseCircles[P][I].Y, ViseCircles[P][I].Radius, ViseCircles[P][I].Obj, False, False, True);
          end;
        end;
      end;
end;


procedure CheckGravityCircles(P: Integer);
var
  X, Y, O, U, G, D, UT, CC: Integer;
begin
  if States.PlayerEnabled(P) then
    if GravityCirclesLength[P] > 0 then
      for CC := 0 to GravityCirclesLength[P] - 1 do
      begin
        if TileOnBattlefield(GravityCircles[P][CC].X, GravityCircles[P][CC].Y) then
        begin
          if (States.GameTime = GravityCircles[P][CC].AddTime) then
          begin
            SetCircle(P, GravityCircles[P][CC].X, GravityCircles[P][CC].Y, GRAVITY_RADIUS, 255, False, True, True);
            SetCircle(P, GravityCircles[P][CC].X, GravityCircles[P][CC].Y, GravityCircles[P][CC].Radius, GravityCircles[P][CC].Obj, False, True, True);
            for X := GravityCircles[P][CC].X - GravityCircles[P][CC].Radius - 1 to GravityCircles[P][CC].X + GravityCircles[P][CC].Radius + 1 do
            for Y := GravityCircles[P][CC].Y - GravityCircles[P][CC].Radius - 1 to GravityCircles[P][CC].Y + GravityCircles[P][CC].Radius + 1 do
            begin
              if (((X - GravityCircles[P][CC].X) * (X - GravityCircles[P][CC].X) + (Y - GravityCircles[P][CC].Y) * (Y - GravityCircles[P][CC].Y)) <= GravityCircles[P][CC].Radius * GravityCircles[P][CC].Radius) then
              begin
                U := States.UnitAt(X, Y);
                if U <> -1 then
                begin
                  O := States.UnitOwner(U);
                  UT := States.UnitType(U);
                  D := States.UnitDirection(U);
                  if (InRange(O, 0, 7))
                  and (not Players[O].HeroImmortal) then
                  begin
                    Actions.GroupKillAll(Players[O].Hero, True);
                    Players[O].Hero := Actions.GiveGroup(O, Players[O].HeroType, Players[P].GravityX, Players[P].GravityY, D, 1, 1);
                    Actions.GroupHungerSet(Players[O].Hero, States.UnitMaxHunger);
                    Break;
                    Exit;
                  end
                  else
                    if (InRange(O, 8, 11)) then 
                    begin
                      Actions.GroupKillAll(States.UnitsGroup(U), True);
                      G := Actions.GiveGroup(O, UT, Players[P].GravityX, Players[P].GravityY, D, 1, 1);
                      Actions.GroupHungerSet(G, RUNE_ZOMBIE_LIFE);
                      Break;
                      Exit;
                    end;
                  if not InRange (O, 0, 11) then
                    Exit;
                end;
              end;
            end;
          end;
        end;
      end;
end;


procedure CheckConcentrationCircles(P: Integer);
begin
  if States.PlayerEnabled(P) then
    if ConcentrationCirclesLength[P] > 0 then
      for I := 0 to ConcentrationCirclesLength[P] - 1 do
      begin
        if TileOnBattlefield(ConcentrationCircles[P][I].X, ConcentrationCircles[P][I].Y) then
        begin
          if (States.GameTime = ConcentrationCircles[P][I].AddTime) then
            SetCircle(P, ConcentrationCircles[P][I].X, ConcentrationCircles[P][I].Y, ConcentrationCircles[P][I].Radius, ConcentrationCircles[P][I].Obj, True, False, True);
        end;
      end;
end;


procedure SetMegaMine(O, aX, aY: Integer);
begin
  Actions.PlayWAV(O, 'Wtf', 1);
  TilesFieldLength[8] := TilesFieldLength[8] + 9;
  SetLength(TilesFieldX[8], TilesFieldLength[8]);
  SetLength(TilesFieldY[8], TilesFieldLength[8]);
  SetLength(ClearTilesFieldTimes[8], TilesFieldLength[8]);
  SetLength(SetTilesFieldTimes[8], TilesFieldLength[8]);
  SetLength(TilesFieldObjects[8], TilesFieldLength[8]);

  TilesFieldX[8][Length(TilesFieldX[8]) - 1] := aX;
  TilesFieldY[8][Length(TilesFieldY[8]) - 1] := aY;
  TilesFieldX[8][Length(TilesFieldX[8]) - 2] := aX;
  TilesFieldY[8][Length(TilesFieldY[8]) - 2] := aY - 1;
  TilesFieldX[8][Length(TilesFieldX[8]) - 3] := aX;
  TilesFieldY[8][Length(TilesFieldY[8]) - 3] := aY + 1;
  TilesFieldX[8][Length(TilesFieldX[8]) - 4] := aX - 1;
  TilesFieldY[8][Length(TilesFieldY[8]) - 4] := aY;
  TilesFieldX[8][Length(TilesFieldX[8]) - 5] := aX + 1;
  TilesFieldY[8][Length(TilesFieldY[8]) - 5] := aY;
  TilesFieldX[8][Length(TilesFieldX[8]) - 6] := aX + 1;
  TilesFieldY[8][Length(TilesFieldY[8]) - 6] := aY + 1;
  TilesFieldX[8][Length(TilesFieldX[8]) - 7] := aX + 1;
  TilesFieldY[8][Length(TilesFieldY[8]) - 7] := aY - 1;
  TilesFieldX[8][Length(TilesFieldX[8]) - 8] := aX - 1;
  TilesFieldY[8][Length(TilesFieldY[8]) - 8] := aY + 1;
  TilesFieldX[8][Length(TilesFieldX[8]) - 9] := aX - 1;
  TilesFieldY[8][Length(TilesFieldY[8]) - 9] := aY - 1;

  for I := 1 to 9 do
  begin
    ClearTilesFieldTimes[8][Length(ClearTilesFieldTimes[8]) - I] := States.GameTime + 21;
    SetTilesFieldTimes[8][Length(SetTilesFieldTimes[8]) - I] := States.GameTime + 1;
    TilesFieldObjects[8][Length(TilesFieldObjects[8]) - I] := XBOW_OBJECT3;
  end;

end;


procedure OnPlayerDefeated(P: Integer);
begin
  if (InRange(P, 0, 7)) then
  begin
    Actions.GroupKillAll(Players[P].Hero, True);
    Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].TribuneX, Players[P].TribuneY, 4, 1, 1);
    Actions.CinematicStart(P);
    Actions.CinematicPanTo(P, Players[P].TribuneX, Players[P].TribuneY, 0);
    Actions.CinematicEnd(P);
  end;
end;


procedure OnUnitDied(aID, aKiller: Integer);
var
  O: Integer;
begin
  if aID < 0 then
    Exit;

  O := States.UnitOwner(aID);
  for I := 0 to 7 do
  for K := 0 to 3 do
    if ZomboHero[I][K] > 0 then
      if aID = States.GroupMember(ZomboHero[I][K], 0) then
        ZomboHero[I][K] := -1;

  DeathX := States.UnitPositionX(aID);
  DeathY := States.UnitPositionY(aID);

  if States.MapTileObject(DeathX, DeathY) = BOWMAN_MINE then
    SetMegaMine(O, DeathX, DeathY);

  if (InRange(aKiller, 9, 11))
  and (InRange(States.UnitOwner(aID), 0, 7))
  and (aID = States.GroupMember(Players[O].Hero, 0)) then
  begin
    Players[O].RespawnCheckTime := States.GameTime + 10;
    if Players[O].HP > 0 then
    begin 
      Players[O].Hero := -1;
      Players[O].Hero := Actions.GiveGroup(O, Players[O].HeroType, Players[O].SpawnX, Players[O].SpawnY, Players[O].Direction, 1, 1);
      if not (Players[O].CaptureMind)
      and not (Players[O].MindStunned) then
        Players[States.UnitOwner(aID)].HP := Players[States.UnitOwner(aID)].HP - 1;
      if Players[O].CaptureMind then
        Players[M[O]].HP := Players[M[O]].HP - 1;
      if Players[O].MindStunned then
        begin
          Players[M2[O]].HP := Players[M2[O]].HP - 1;
          Actions.GroupBlockOrders(Players[O].Hero, True);
          Actions.GroupOrderHalt(Players[O].Hero);
        end;
    end;
    Players[O].HeroImmortal := True;
    Players[O].HeroImmortalTime := States.GameTime + IMMORTAL_TIME;
    if (Players[O].HeroStunned)
    or (Players[O].HeroInFear) then
      Actions.GroupBlockOrders(Players[O].Hero, True);
    Actions.GroupHungerSet(Players[O].Hero, States.UnitMaxHunger);
    Actions.CinematicStart(O);
    Actions.CinematicPanTo(O, Players[O].SpawnX, Players[O].SpawnY, 0);
    Actions.CinematicEnd(O);
    if Players[O].HP = 0 then
    begin
      Actions.GroupKillAll(Players[O].Hero, True);
      Players[O].Hero := Actions.GiveGroup(O, Players[O].HeroType, Players[O].TribuneX, Players[O].TribuneY, 4, 1, 1);
      Actions.GroupHungerSet(Players[O].Hero, States.UnitMaxHunger);
      Actions.CinematicStart(O);
      Actions.CinematicPanTo(O, Players[O].TribuneX, Players[O].TribuneY, 0);
      Actions.CinematicEnd(O);
    end;
  end;
end;


procedure SetHeroes;
begin

  for J := 0 to Length(AISoldiers) - 1 do
    Actions.GroupKillAll(AISoldiers[J], True);

  for I := 0 to 7 do
  begin
    if (States.PlayerEnabled(I)) then
    begin
      if (not Players[I].HeroChosen)
      and (Players[I].Hero = -1) then
      begin
        Players[I].HeroType := States.KaMRandomI(6) + 15;
        if States.KaMRandomI(10) = 5 then
          Players[I].HeroType := 23;
        if States.KaMRandomI(5) = 3 then
          Players[I].HeroType := 26;
        if States.KaMRandomI(20) < 6 then
          Players[I].HeroType := 22;
        if States.KaMRandomI(15) < 8 then
          Players[I].HeroType := 25;
        Players[I].HeroChosen := True;
        Players[I].TempHeroType := Players[I].HeroType;
      end;
      Players[I].Hero := Actions.GiveGroup(I, Players[I].HeroType, Players[I].SpawnX, Players[I].SpawnY, Players[I].Direction, 1, 1);
      Actions.GroupHungerSet(Players[I].Hero, States.UnitMaxHunger);
      Players[I].HeroImmortal := True;
      Players[I].HeroImmortalTime := States.GameTime + IMMORTAL_TIME;
      Actions.CinematicStart(I);
      Actions.CinematicPanTo(I, Players[I].SpawnX, Players[I].SpawnY, 0);
      Actions.CinematicEnd(I);
    end;
  end;

  for K := 0 to 7 do
    if States.PlayerEnabled(K) then
      Actions.FogRevealAll(K);

end;


procedure CheckStatus;
var
  aX, aY, aD, aX2, aY2, aD2, I1: Integer;
  G: array of Integer;
begin
  for I1 := 0 to 7 do
  begin

    if States.GameTime = Players[I1].VagaAppearTime then
    begin
      Players[I1].Hero := Actions.GiveGroup(I1, 27, Players[I1].VagaX, Players[I1].VagaY, Players[I1].VagaDir, 1, 1);
      Actions.GroupHungerSet(Players[I1].Hero, States.UnitMaxHunger);
      Players[I1].WerewolfTime := States.GameTime + WEREWOLF_TIME;
    end;

    if States.GameTime = Players[I1].WerewolfTime then
    begin
      if Players[I1].Hero <> -1 then
      begin
        aX := States.UnitPositionX(States.GroupMember(Players[I1].Hero, 0));
        aY := States.UnitPositionY(States.GroupMember(Players[I1].Hero, 0));
        aD := States.UnitDirection(States.GroupMember(Players[I1].Hero, 0));
        Actions.GroupKillAll(Players[I1].Hero, True);
        Players[I1].Hero := Actions.GiveGroup(I1, Players[I1].TempHeroType, aX, aY, aD, 1, 1);
        Players[I1].HeroType := Players[I1].TempHeroType;
        Actions.GroupHungerSet(Players[I1].Hero, States.UnitMaxHunger);
        Players[I1].WineSkillDelay := AXE_WINE_DELAY * (1 - Round(RECHARGE_FACTOR * Byte(Players[I1].ReCharge))) - WEREWOLF_TIME;
        Players[I1].RoadSkillDelay := 0;
        Players[I1].FieldSkillDelay := 0;
      end;
    end;

    if (States.PlayerEnabled(I1))
    and (Players[I1].Hero > 0) then
    begin
      if (InRange(States.UnitPositionY(States.GroupMember(Players[I1].Hero, 0)), 1, 10))
      and (Players[I1].HP > 0) then
      begin
        Actions.GroupKillAll(Players[I1].Hero, True);
        Players[I1].Hero := Actions.GiveGroup(I1, Players[I1].HeroType, Players[I1].SpawnX, Players[I1].SpawnY, Players[I1].Direction, 1, 1);
      end;
    end;

    if States.GameTime = Players[I1].HeroSilentStartTime then
    begin
      Players[I1].HeroSilent := True;
      Players[I1].HeroSilentTime := States.GameTime + SILENCE_TIME + 20;
    end;

    if States.GameTime = Players[I1].HeroSilentTime then
      Players[I1].HeroSilent := False;

    if States.GameTime = Players[I1].ReChargeTime then
      Players[I1].ReCharge := False;

    if States.GameTime = Players[I1].PreparingTime then
      Players[I1].Preparing := False;

    if States.GameTime = Players[I1].ArmorStartTime then
    begin
      Players[I1].HeroImmortal := True;
      Players[I1].HeroImmortalTime := States.GameTime + ARMOR_TIME;
    end;

    if States.GameTime = Players[I1].RopeTime then
    begin
      Actions.GroupKillAll(Players[I1].Hero, True);
      Players[I1].Hero := Actions.GiveGroup(I1, Players[I1].HeroType, Players[I1].RopeDX + States.UnitPositionX(States.GroupMember(Players[Players[I1].RopeAttacker].Hero, 0)), Players[I1].RopeDY + States.UnitPositionY(States.GroupMember(Players[Players[I1].RopeAttacker].Hero, 0)), Players[I1].RopeUnitDir, 1, 1);
      Actions.GroupHungerSet(Players[I1].Hero, States.UnitMaxHunger);
    end;

    if States.GameTime = Players[I1].SkillTime then
      Players[I1].CastingSkill := False;

    if States.GameTime = Players[I1].HeroImmortalTime then
      Players[I1].HeroImmortal := False;

    if States.GameTime = Players[I1].HeroPrisonedTime then
      Players[I1].HeroPrisoned := False;

    if (ZomboHero[I1][0] = -1)
    and (ZomboHero[I1][1] = -1) 
    and (ZomboHero[I1][2] = -1) 
    and (ZomboHero[I1][3] = -1) then
      Players[I1].InIllusion := False;

    if States.GameTime = Players[I1].HeroStunnedTime then
    begin
      Players[I1].HeroStunned := False;
      if Players[I1].Hero > 0 then
      begin
        Actions.GroupBlockOrders(Players[I1].Hero, False);
        Actions.GroupOrderHalt(Players[I1].Hero);
      end;
    end;

    if (Players[I1].HeroInFear)
    and not (Players[I1].HeroStunned) then
    begin
      if Players[I1].Hero > 0 then
      begin
        if States.KaMRandom < STORM_CHANCE then
          Actions.GroupOrderStorm(Players[I1].Hero);
        Actions.GroupOrderWalk(Players[I1].Hero, States.KaMRandomI(48) + 12, States.KaMRandomI(48) + 12, States.KaMRandomI(8));
      end;
    end;

    if States.GameTime = Players[I1].HeroInFearTime then
    begin
      Players[I1].HeroInFear := False;
      if Players[I1].Hero > 0 then
      begin
        Actions.GroupBlockOrders(Players[I1].Hero, False);
        Actions.GroupOrderHalt(Players[I1].Hero);
      end;
    end;

   if States.GameTime = Players[I1].CaptureMindTime then
     begin
       aX := States.UnitPositionX(States.GroupMember(Players[I1].Hero, 0));
       aY := States.UnitPositionY(States.GroupMember(Players[I1].Hero, 0));
       aD := States.UnitDirection(States.GroupMember(Players[I1].Hero, 0));
       aX2 := States.UnitPositionX(States.GroupMember(Players[M[I1]].Hero, 0));
       aY2 := States.UnitPositionY(States.GroupMember(Players[M[I1]].Hero, 0));
       aD2 := States.UnitDirection(States.GroupMember(Players[M[I1]].Hero, 0));
       if Players[M[I1]].HP = 0 then
       begin
         aX2 := aX;
         aY2 := aY;
       end;
       Players[I1].CaptureMind := False;
       Players[M[I1]].MindStunned := False;
       if (Players[I1].Hero > 0)
       and (Players[M[I1]].Hero > 0) then
       begin
         Actions.GroupKillAll(Players[I1].Hero, True);
         Actions.GroupKillAll(Players[M[I1]].Hero, True);
         Players[I1].HeroType := Players[I1].HeroMindType;
         Players[M[I1]].HeroType := Players[M[I1]].HeroMindType;
         Players[I1].TempHeroType := Players[I1].TempHeroMindType;
         Players[I1].Hero := Actions.GiveGroup(I1, Players[I1].HeroType, aX2, aY2, aD2, 1, 1);
         Players[M[I1]].Hero := Actions.GiveGroup(M[I1], Players[M[I1]].HeroType, aX, aY, aD, 1, 1);
         Players[M[I1]].RoadSkillDelay := Players[I1].RoadSkillDelay;
         Players[M[I1]].FieldSkillDelay := Players[I1].FieldSkillDelay;
         Players[M[I1]].WineSkillDelay := Players[I1].WineSkillDelay;
         Players[I1].RoadSkillDelay := 0;
         Players[I1].FieldSkillDelay := 0;
         Players[I1].WineSkillDelay := Round(SCOUT_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[I1].ReCharge)));
         Players[M[I1]].LastUsedSkill := Players[I1].LastUsedSkill;
         G := States.PlayerGetAllGroups(I1);
         if Length(G) > 0 then
           for K := 0 to Length(G) - 1 do
             if G[K] <> Players[I1].Hero then
               Actions.GroupKillAll(G[K], True);
       end;
    end;
  end;
end;


procedure CheckTileRoadObjects(P: Integer);
begin
  for K := 0 to TilesRoadLength[P] - 1 do
  begin
    if (TilesRoadX[P][K] > 0)
    and (TilesRoadY[P][K] > 0) then
      if TileOnBattlefield(TilesRoadX[P][K], TilesRoadY[P][K]) then
      begin

        if (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K] - 1))
        and (TilesRoadObjects[P][K] = BOWMAN_OBJECT5)
        and (Roads[TilesRoadX[P][K]][TilesRoadY[P][K]].Owner = -1)
        and (States.GameTime mod 3 = 0) then
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], BOWMAN_OBJECT5);

        if (InRange(States.GameTime, ClearTilesRoadTimes[P][K] - 1, ClearTilesRoadTimes[P][K]))
        and (TilesRoadObjects[P][K] = BOWMAN_OBJECT5) then
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], 255);

        if (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K] - 1))
        and (TilesRoadObjects[P][K] = BARB_OBJECT3) then
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], BARB_OBJECT3);

        if (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K] - 1))
        and (TilesRoadObjects[P][K] = ROGUE_OBJECT4) then
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], ROGUE_OBJECT4);

        if (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K] - 1))
        and (TilesRoadObjects[P][K] = WARRIOR_OBJECT5) then
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], WARRIOR_OBJECT5);

        if (Roads[TilesRoadX[P][K]][TilesRoadY[P][K]].Owner <> - 1)
        and (States.GameTime mod 3 = 0) then
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], BOWMAN_MINE);  

        if States.GameTime = ClearTilesRoadTimes[P][K] then
        begin
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], 255);

          if TilesRoadObjects[P][K] = BOWMAN_MINE then
          begin
            if InRange(Roads[TilesRoadX[P][K]][TilesRoadY[P][K]].Owner, 8, 11) then
              Actions.PlanRemove(Roads[TilesRoadX[P][K]][TilesRoadY[P][K]].Owner, TilesRoadX[P][K], TilesRoadY[P][K]);
            Roads[TilesRoadX[P][K]][TilesRoadY[P][K]].Owner := -1;
          end;
        end;

        if States.GameTime = SetTilesRoadTimes[P][K] then
          if CanPlaceObject(TilesRoadX[P][K], TilesRoadY[P][K]) then
            Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], TilesRoadObjects[P][K]);
      end;
    end;
end;


procedure CheckTileFieldObjects(P: Integer);
begin
  for K := 0 to TilesFieldLength[P] - 1 do
  begin
    if (TilesFieldX[P][K] > 0)
    and (TilesFieldY[P][K] > 0) then
      if TileOnBattlefield(TilesFieldX[P][K], TilesFieldY[P][K]) then
      begin

        if (InRange(States.GameTime, SetTilesFieldTimes[P][K], ClearTilesFieldTimes[P][K] - 1))
        and (TilesFieldObjects[P][K] = BOWMAN_OBJECT5)
        and (Roads[TilesFieldX[P][K]][TilesFieldY[P][K]].Owner = -1)
        and (States.GameTime mod 3 = 0) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], BOWMAN_OBJECT5);

        if (InRange(States.GameTime, ClearTilesFieldTimes[P][K] - 1, ClearTilesFieldTimes[P][K]))
        and (TilesFieldObjects[P][K] = BOWMAN_OBJECT5) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], 255);

        if (InRange(States.GameTime, SetTilesFieldTimes[P][K], ClearTilesFieldTimes[P][K] - 1))
        and (TilesFieldObjects[P][K] = BARB_OBJECT3) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], BARB_OBJECT3);

        if (InRange(States.GameTime, SetTilesFieldTimes[P][K], ClearTilesFieldTimes[P][K] - 1))
        and (TilesFieldObjects[P][K] = ROGUE_OBJECT4) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], ROGUE_OBJECT4);

        if (InRange(States.GameTime, SetTilesFieldTimes[P][K], ClearTilesFieldTimes[P][K] - 1))
        and (TilesFieldObjects[P][K] = WARRIOR_OBJECT5) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], WARRIOR_OBJECT5);

        if (Roads[TilesFieldX[P][K]][TilesFieldY[P][K]].Owner <> - 1)
        and (States.GameTime mod 3 = 0) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], BOWMAN_MINE);  

        if States.GameTime = ClearTilesFieldTimes[P][K] then
        begin
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], 255);

          if TilesFieldObjects[P][K] = BOWMAN_MINE then
          begin
            if InRange(Roads[TilesFieldX[P][K]][TilesFieldY[P][K]].Owner, 8, 11) then
              Actions.PlanRemove(Roads[TilesFieldX[P][K]][TilesFieldY[P][K]].Owner, TilesFieldX[P][K], TilesFieldY[P][K]);
            Roads[TilesFieldX[P][K]][TilesFieldY[P][K]].Owner := -1;
          end;
        end;

        if States.GameTime = SetTilesFieldTimes[P][K] then
          if CanPlaceObject(TilesFieldX[P][K], TilesFieldY[P][K]) then
            Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], TilesFieldObjects[P][K]);
      end;
    end;
end;


procedure CheckTileWineObjects(P: Integer);
begin
  for K := 0 to TilesWineLength[P] - 1 do
  begin
    if (TilesWineX[P][K] > 0)
    and (TilesWineY[P][K] > 0) then
      if TileOnBattlefield(TilesWineX[P][K], TilesWineY[P][K]) then
      begin

        if (InRange(States.GameTime, SetTilesWineTimes[P][K], ClearTilesWineTimes[P][K] - 1))
        and (TilesWineObjects[P][K] = BOWMAN_OBJECT5)
        and (Roads[TilesWineX[P][K]][TilesWineY[P][K]].Owner = -1)
        and (States.GameTime mod 3 = 0) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], BOWMAN_OBJECT5);

        if (InRange(States.GameTime, ClearTilesWineTimes[P][K] - 1, ClearTilesWineTimes[P][K]))
        and (TilesWineObjects[P][K] = BOWMAN_OBJECT5) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], 255);

        if (InRange(States.GameTime, SetTilesWineTimes[P][K], ClearTilesWineTimes[P][K] - 1))
        and (TilesWineObjects[P][K] = BARB_OBJECT3) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], BARB_OBJECT3);

        if (InRange(States.GameTime, SetTilesWineTimes[P][K], ClearTilesWineTimes[P][K] - 1))
        and (TilesWineObjects[P][K] = ROGUE_OBJECT4) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], ROGUE_OBJECT4);

        if (InRange(States.GameTime, SetTilesWineTimes[P][K], ClearTilesWineTimes[P][K] - 1))
        and (TilesWineObjects[P][K] = WARRIOR_OBJECT5) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], WARRIOR_OBJECT5);

        if (Roads[TilesWineX[P][K]][TilesWineY[P][K]].Owner <> - 1)
        and (States.GameTime mod 3 = 0) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], BOWMAN_MINE);  

        if States.GameTime = ClearTilesWineTimes[P][K] then
        begin
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], 255);

          if TilesWineObjects[P][K] = BOWMAN_MINE then
          begin
            if InRange(Roads[TilesWineX[P][K]][TilesWineY[P][K]].Owner, 8, 11) then
              Actions.PlanRemove(Roads[TilesWineX[P][K]][TilesWineY[P][K]].Owner, TilesWineX[P][K], TilesWineY[P][K]);
            Roads[TilesWineX[P][K]][TilesWineY[P][K]].Owner := -1;
          end;
        end;

        if States.GameTime = SetTilesWineTimes[P][K] then
          if CanPlaceObject(TilesWineX[P][K], TilesWineY[P][K]) then
            Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], TilesWineObjects[P][K]);
      end;
    end;
end;


procedure ClearArrays;
begin

  for I := 0 to 11 do
  begin

    if States.GameTime = ClearRoadTilesArrayTime[I] then
    begin
      TilesRoadLength[I] := 1;
      SetLength(TilesRoadX[I], TilesRoadLength[I]);
      SetLength(TilesRoadY[I], TilesRoadLength[I]);
      SetLength(ClearTilesRoadTimes[I], TilesRoadLength[I]);
      SetLength(SetTilesRoadTimes[I], TilesRoadLength[I]);
      SetLength(TilesRoadObjects[I], TilesRoadLength[I]);
    end;

    if States.GameTime = ClearFieldTilesArrayTime[I] then
    begin
      TilesFieldLength[I] := 1;
      SetLength(TilesFieldX[I], TilesFieldLength[I]);
      SetLength(TilesFieldY[I], TilesFieldLength[I]);
      SetLength(ClearTilesFieldTimes[I], TilesFieldLength[I]);
      SetLength(SetTilesFieldTimes[I], TilesFieldLength[I]);
      SetLength(TilesFieldObjects[I], TilesFieldLength[I]);
    end;

    if States.GameTime = ClearWineTilesArrayTime[I] then
    begin
      TilesWineLength[I] := 1;
      SetLength(TilesWineX[I], TilesWineLength[I]);
      SetLength(TilesWineY[I], TilesWineLength[I]);
      SetLength(ClearTilesWineTimes[I], TilesWineLength[I]);
      SetLength(SetTilesWineTimes[I], TilesWineLength[I]);
      SetLength(TilesWineObjects[I], TilesWineLength[I]);
    end;

    if States.GameTime = TimeToClearConcentrationArray[I] then
    begin
      ConcentrationCirclesLength[I] := 0;
      SetLength(ConcentrationCircles[I], 0);
    end;

    if States.GameTime = TimeToClearRageArray[I] then
    begin
      RageCirclesLength[I] := 0;
      SetLength(RageCircles[I], 0);
    end;

    if States.GameTime = TimeToClearVagaArray[I] then
    begin
      VagaCirclesLength[I] := 0;
      SetLength(VagaCircles[I], 0);
    end;

    if States.GameTime = TimeToClearTotemArray[I] then
    begin
      TotemCirclesLength[I] := 0;
      SetLength(TotemCircles[I], 0);
    end;

    if States.GameTime = TimeToClearViseArray[I] then
    begin
      ViseCirclesLength[I] := 0;
      SetLength(ViseCircles[I], 0);
    end;

    if States.GameTime = TimeToClearExpArray[I] then
    begin
      ExpCirclesLength[I] := 0;
      SetLength(ExpCircles[I], 0);
    end;

    if States.GameTime = TimeToClearGravityArray[I] then
    begin
      GravityCirclesLength[I] := 0;
      SetLength(GravityCircles[I], 0);
    end;

    if States.GameTime = TimeToClearFireworks1Array[I] then
    begin
      FireworksCircles1Length[I] := 0;
      SetLength(FireworksCircles1[I], 0);
    end;

    if States.GameTime = TimeToClearFireworks2Array[I] then
    begin
      FireworksCircles2Length[I] := 0;
      SetLength(FireworksCircles2[I], 0);
    end;

    if States.GameTime = TimeToClearFireworks3Array[I] then
    begin
      FireworksCircles3Length[I] := 0;
      SetLength(FireworksCircles3[I], 0);
    end;

    if States.GameTime = TimeToClearFireworks4Array[I] then
    begin
      FireworksCircles4Length[I] := 0;
      SetLength(FireworksCircles4[I], 0);
    end;

    if States.GameTime = TimeToClearFireworks5Array[I] then
    begin
      FireworksCircles5Length[I] := 0;
      SetLength(FireworksCircles5[I], 0);
    end;

  end;

end;


procedure ClearDefence(P: Integer);
var
  aX, aY: Integer;
begin
  for aX := MIN_X to MAX_X do
  for aY := MIN_Y to MAX_Y do
    if States.MapTileObject(aX, aY) = SOSObjects[P] then
      Actions.MapTileObjectSet(aX, aY, 255);
end;


procedure ClearPikeObj(P: Integer);
var
  aX, aY: Integer;
begin
  for aX := MIN_X to MAX_X do
  for aY := MIN_Y to MAX_Y do
    if States.MapTileObject(aX, aY) = PikeObjects[P] then
      Actions.MapTileObjectSet(aX, aY, 255);
end;


procedure AIStorm;
var
  Zombies: array of Integer;
begin
  for I := 9 to 11 do
  begin
    Zombies := States.PlayerGetAllGroups(I);
    for K := 0 to Length(Zombies) - 1 do
      if States.KaMRandom < STORM_CHANCE then
        Actions.GroupOrderStorm(Zombies[K]);
  end;
end;


function ObjectIsTree(aX, aY: Integer): Boolean;
begin
  if TileOnBattlefield(aX, aY) then
    Result := ((States.MapTileObject(aX, aY) = 157)
    or (States.MapTileObject(aX, aY) = 158)
    or (States.MapTileObject(aX, aY) = 159)
    or (States.MapTileObject(aX, aY) = 172));
end;


function TileHasTreesAround(aX, aY: Integer): Boolean;
begin
  if TileOnBattlefield(aX, aY) then
    Result := ((ObjectIsTree(aX + 1, aY))
    or (ObjectIsTree(aX + 1, aY + 1))
    or (ObjectIsTree(aX + 1, aY - 1))
    or (ObjectIsTree(aX - 1, aY - 1))
    or (ObjectIsTree(aX - 1, aY))
    or (ObjectIsTree(aX - 1, aY + 1))
    or (ObjectIsTree(aX, aY + 1))
    or (ObjectIsTree(aX, aY - 1)));
end;


procedure PlantTrees;
var
 aX, aY: Integer;
begin
  aX := States.KaMRandomI(46) + 13;
  aY := States.KaMRandomI(46) + 13;
  if (CanUseWineFieldSkill(aX, aY))
  and (not TileHasTreesAround(aX, aY))
  and (States.MapTileObject(aX, aY) <> BARB_OBJECT3)
  and (States.MapTileObject(aX, aY) <> BOWMAN_OBJECT5)
  and (States.MapTileObject(aX, aY) <> BOWMAN_MINE) then
  begin
    if (States.KaMRandom < PLANT_TREES_FACTOR)
    and (States.MapTileObject(aX, aY) = 255) then
      Actions.MapTileObjectSet(aX, aY, 157);

    if (States.MapTileObject(aX, aY) = 157)
    and (States.KaMRandom < (PLANT_TREES_FACTOR/3)) then
      Actions.MapTileObjectSet(aX, aY, 158);

    if (States.MapTileObject(aX, aY) = 158)
    and (States.KaMRandom < (PLANT_TREES_FACTOR/5)) then
      Actions.MapTileObjectSet(aX, aY, 159);

    if (States.MapTileObject(aX, aY) = 159)
    and (States.KaMRandom < (PLANT_TREES_FACTOR/10)) then
      Actions.MapTileObjectSet(aX, aY, 172);
  end;
end;


procedure CheckImmortal;
var
  aX, aY, aU, aO: Integer;
begin
  for aX := MIN_X to MAX_X do
  for aY := MIN_Y to MAX_Y do
  begin
    if States.MapTileObject(aX, aY) = RUNE_IMMORTAL_ANIMATION then
      Actions.MapTileObjectSet(aX, aY, 255);
    aU := States.UnitAt(aX, aY);
    if (aU <> - 1) then
    begin
      aO := States.UnitOwner(aU);
      if (InRange(aO, 0, 7))
      and (aU = States.GroupMember(Players[aO].Hero, 0))
      and (States.MapTileObject(aX, aY) = 255) then
        if Players[aO].HeroImmortal then
          Actions.MapTileObjectSet(aX, aY, RUNE_IMMORTAL_ANIMATION);
    end;
  end;
end;


procedure CheckRespawn(P: Integer);
begin
  if (States.PlayerEnabled(P))
  and (States.GameTime >= Players[P].RespawnCheckTime)
  and (Players[P].RespawnCheckTime > 0)
  and (States.GameTime > CHOOSE_HERO_TIMER)
  and (Players[P].HP > 0)
  and (Players[P].Hero = -1) then
  begin
    Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].SpawnX, Players[P].SpawnY, Players[P].Direction, 1, 1);
    Players[P].HeroImmortal := True;
    Players[P].HeroImmortalTime := States.GameTime + IMMORTAL_TIME;
    Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
    Actions.CinematicStart(P);
    Actions.CinematicPanTo(P, Players[P].SpawnX, Players[P].SpawnY, 0);
    Actions.CinematicEnd(P);
    Exit;
  end;
end;


//AI


procedure RespawnUnit(P: Integer);
begin
  if (States.PlayerEnabled(P))
  and (Players[P].HP > 0) then
  begin
    Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].SkillCastX, Players[P].SkillCastY, Players[P].SkillCastDir, 1, 1);
    Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
    if (Players[P].HeroStunned)
    or (Players[P].HeroInFear) then
      Actions.GroupBlockOrders(Players[P].Hero, True);
   end;
end;


procedure RepeatRespawn(P: Integer);
var
  G: array of Integer;
begin
  if (InRange(States.GameTime, Players[P].SkillCastRespawnTime + 1, Players[P].SkillCastRespawnTime + 3))
  and (Players[P].Hero = -1)
  and (States.PlayerIsAI(P)) then
  begin
    RespawnUnit(P);
    G := States.PlayerGetAllGroups(P);
      if Length(G) > 0 then
        for K := 0 to Length(G) - 1 do
          if G[K] <> Players[P].Hero then
            Actions.GroupKillAll(G[K], True);
  end;
end;


procedure AvoidDanger(P: Integer);
var
  aX, aY, D: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if not States.PlayerIsAI(I) then
    Exit;

  if (InRange(P, 0, 7))
  and (Players[P].Hero > 0) then
  begin

    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    D := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

    if not Players[P].CastingSkill then
    begin
      case D of

        0: if (TileIsDangerous(aX, aY - 2))
           or (TileIsDangerous(aX, aY - 1)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(5) - States.KaMRandomI(5), aY + States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        1: if (TileIsDangerous(aX + 1, aY - 2))
           or (TileIsDangerous(aX + 1, aY - 1))
           or (TileIsDangerous(aX + 2, aY - 2))
           or (TileIsDangerous(aX + 2, aY - 1)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(5) - States.KaMRandomI(5), aY + States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        2: if (TileIsDangerous(aX + 1, aY))
           or (TileIsDangerous(aX + 2, aY)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX - States.KaMRandomI(5), aY + States.KaMRandomI(5) - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        3: if (TileIsDangerous(aX + 1, aY + 2))
           or (TileIsDangerous(aX + 1, aY + 1))
           or (TileIsDangerous(aX + 2, aY + 2))
           or (TileIsDangerous(aX + 2, aY + 1)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX - States.KaMRandomI(5), aY - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        4: if (TileIsDangerous(aX, aY + 2))
           or (TileIsDangerous(aX, aY + 1)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(5) - States.KaMRandomI(5), aY - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        5: if (TileIsDangerous(aX - 1, aY + 2))
           or (TileIsDangerous(aX - 1, aY + 1))
           or (TileIsDangerous(aX - 2, aY + 2))
           or (TileIsDangerous(aX - 2, aY + 1)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(5), aY - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        6: if (TileIsDangerous(aX - 2, aY))
           or (TileIsDangerous(aX - 1, aY)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(5), aY + States.KaMRandomI(5) - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        7: if (TileIsDangerous(aX - 1, aY - 2))
           or (TileIsDangerous(aX - 1, aY - 1))
           or (TileIsDangerous(aX - 2, aY - 2))
           or (TileIsDangerous(aX - 2, aY - 1)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX - States.KaMRandomI(5), aY - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

      end;

    end;

  end;

end;


procedure AITakeRune(P: Integer);
begin
  if (Players[P].Hero <= 0)
  or (Players[P].CastingSkill) then
    Exit;
  if ((States.MapTileObject(RUNE_X, RUNE_Y) <> RUNE_BLOCK_OBJ)
  and (States.MapTileObject(RUNE_X, RUNE_Y) <> RUNE_REGEN_OBJ))
  or ((Players[P].HP < MAX_HP)
  and (States.MapTileObject(RUNE_X, RUNE_Y) = RUNE_REGEN_OBJ)) then
    Actions.GroupOrderWalk(Players[P].Hero, RUNE_X, RUNE_Y, States.KaMRandomI(8));
end;


procedure AIWalk(P: Integer);
begin

  if States.GameTime mod 80 = 0 then
    if (Players[P].Hero > 0)
    and (not Players[P].CastingSkill) then
      Actions.GroupOrderWalk(Players[P].Hero, States.KaMRandomI(47) + 12, States.KaMRandomI(47) + 12, States.KaMRandomI(8));

  if Players[P].Hero > 0 then
    if (Abs(Players[P].SkillTime - States.GameTime) = 1) then
      Actions.GroupOrderWalk(Players[P].Hero, States.KaMRandomI(47) + 12, States.KaMRandomI(47) + 12, States.KaMRandomI(8));

end;


procedure AITakeHealingBush(P: Integer);
var
  X, Y, aX, aY: Integer;
begin
  if (Players[P].Hero <= 0)
  or (Players[P].CastingSkill)
  or (Players[P].HP = 12)
  or (Players[P].RegenDelay - States.GameTime > 0) then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
  aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

  for X := aX - HEAL_CHECK_RADIUS to aX + HEAL_CHECK_RADIUS do
  for Y := aY - HEAL_CHECK_RADIUS to aY + HEAL_CHECK_RADIUS do
    if TileOnBattlefield(X, Y) then
      if States.MapTileObject(X, Y) = VAGA_OBJECT then
        Actions.GroupOrderWalk(Players[P].Hero, X, Y, States.KaMRandomI(8));
end;


procedure ZombieAttack;
var
  G, G1: array of Integer;
  Target, Target1: Integer;
begin
  Target := States.KaMRandomI(4);
  Target1 := States.KaMRandomI(4) + 4;

  G := States.PlayerGetAllGroups(11);
  G1 := States.PlayerGetAllGroups(10);

  if Length(G) > 0 then
    for I := 0 to Length(G) - 1 do
      if (States.GroupIdle(G[I]))
      and (Players[Target].Hero > 0) then
        Actions.GroupOrderAttackUnit(G[I], States.GroupMember(Players[Target].Hero, 0));

  if Length(G1) > 0 then
    for K := 0 to Length(G1) - 1 do
      if (States.GroupIdle(G1[K]))
      and (Players[Target1].Hero > 0) then
        Actions.GroupOrderAttackUnit(G1[K], States.GroupMember(Players[Target1].Hero, 0));

end;


function AICanUseSkills(P, UT: Integer): Boolean;
begin
  Result := False;
  if not InRange(UT, 15, 27) then
    Exit;
  if States.PlayerEnabled(P) then
    if States.PlayerIsAI(P) then
      if Players[P].Hero > 0 then
        Result := ((Players[P].HeroType = UT)
        and (Players[P].HP > 0)
        and (TileOnBattlefield(States.UnitPositionX(States.GroupMember(Players[P].Hero, 0)), States.UnitPositionY(States.GroupMember(Players[P].Hero, 0))))
        and (not Players[P].HeroInFear)
        and (not Players[P].HeroStunned)
        and (not Players[P].HeroSilent));
end;


function CanUseSkillAgainstUnit(P, U: Integer): Boolean;
begin
  Result := True;
  if InRange(States.UnitOwner(U), 0, 7) then
    Result := not Players[States.UnitOwner(U)].HeroImmortal;  
end;


procedure AISword(P: Integer);
var
  X, Y, aX, aY, uX, uY, O, U: Integer;
begin

  if (States.KaMRandomI(10) > 5)
  and (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    for X := (aX - 7) to (aX + 7) do
    for Y := (aY - 7) to (aY + 7) do
    begin
      U := States.UnitAt(X, Y);
      if U > 0 then
      begin
        O := States.UnitOwner(U);
        if (P <> O)
        and (InRange(O, 0, 7))
        and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
        and (States.KaMRandom > 0.1) then 
        begin
          uX := States.UnitPositionX(U);
          uY := States.UnitPositionY(U);
          if ((uX = aX) and (uY < (aY - 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
          begin
            SpikedEarth(P, aX, aY, 0);
            Exit;
          end;
          if ((uX = aX) and (uY > (aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
          begin
            SpikedEarth(P, aX, aY, 4);
            Exit;
          end;
          if ((uX < (aX - 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
          begin
            SpikedEarth(P, aX, aY, 6);
            Exit;
          end;
          if ((uX > (aX + 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
          begin
            SpikedEarth(P, aX, aY, 2);
            Exit;
          end;
        end;
      end;
    end;
  end;

  if (States.KaMRandomI(10) > 5)
  and (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    ZombieSummon(P, aX + States.KaMRandomI(5) - States.KaMRandomI(5), aY + States.KaMRandomI(5) - States.KaMRandomI(5));
  end;

  if (States.GameTime mod 10 = 0)
  and (Players[I].WineSkillDelay = 0)
  and (Players[P].Hero > 0) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    O := States.KaMRandomI(8);
    if (Players[O].Hero > 0) then
      if (Abs(aX - States.UnitPositionX(States.GroupMember(Players[O].Hero, 0))) <= IN_FEAR_RADIUS)
      and (Abs(aY - States.UnitPositionY(States.GroupMember(Players[O].Hero, 0))) <= IN_FEAR_RADIUS)
      and (CanUseWineFieldSkill(X, Y))
      and (P <> O)
      and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
      and (not Players[O].HeroInFear) then
      begin
        Players[O].HeroInFear := True;
        Players[O].HeroInFearTime := States.GameTime + IN_FEAR_TIME;
      end;
  end;

  AIWalk(P);

  if States.GameTime mod 100 = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AIBarb(P: Integer);
var
  aX, aY, O, U, X, Y, uX, uY, A, E, sX, sY: Integer;
begin

  if (States.KaMRandomI(10) > 5)
  and (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - 7) to (aX + 7) do
      for Y := (aY - 7) to (aY + 7) do
      begin
        U := States.UnitAt(X, Y);
        if U > 0 then
        begin
          O := States.UnitOwner(U);
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1) then 
          begin
            uX := States.UnitPositionX(U);
            uY := States.UnitPositionY(U);
            if ((uX = aX) and (uY < (aY - 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              CrackingEarth(P, aX, aY, 0);
              Exit;
            end;
            if ((uX = aX) and (uY > (aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              CrackingEarth(P, aX, aY, 4);
              Exit;
            end;
            if ((uX < (aX - 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              CrackingEarth(P, aX, aY, 6);
              Exit;
            end;
            if ((uX > (aX + 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              CrackingEarth(P, aX, aY, 2);
              Exit;
            end;
          end;
        end;
      end;
    end;

  if (States.KaMRandomI(10) > 5)
  and (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      A := 0;
      E := 0;
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - RAGE_RADIUS + 1) to (aX + RAGE_RADIUS - 1) do
      for Y := (aY - RAGE_RADIUS + 1) to (aY + RAGE_RADIUS - 1) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0)
        and (not InRange(X, aX - 1, aX + 1))
        and (not InRange(Y, aY - 1, aY + 1)) then
        begin
          O := States.UnitOwner(U);
          if Players[P].PlayersTeam <> Players[O].PlayersTeam then
            E := E + 1;
          if Players[P].PlayersTeam = Players[O].PlayersTeam then
            A := A + 1;
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1)
          and (E > A) then 
          begin
            WaveOfRage(P, aX, aY);
            Exit;
          end;
        end;
      end;
    end;

  if (States.KaMRandomI(10) > 7)
  and (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      A := 0;
      E := 0;
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - TOTEM_ADD_RADIUS + 2) to (aX + TOTEM_ADD_RADIUS - 2) do
      for Y := (aY - TOTEM_ADD_RADIUS + 2) to (aY + TOTEM_ADD_RADIUS - 2) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0) then
        begin
          if States.GroupIdle(States.UnitsGroup(U)) then
          begin
            sX := X;
            sY := Y;
          end;
          if not States.GroupIdle(States.UnitsGroup(U)) then
          begin
            case States.UnitDirection(U) of
              0: begin
                   sX := X;
                   sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              1: begin
                   sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              2: begin
                   sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y;
                 end;

              3: begin
                   sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              4: begin
                   sX := X;
                   sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              5: begin
                   sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              6: begin
                   sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y;
                 end;

              7: begin
                   sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

            end;
          end;

          if (not InRange(sX, aX - TOTEM_RADIUS, aX + TOTEM_RADIUS))
          and (not InRange(sY, aY - TOTEM_RADIUS, aY + TOTEM_RADIUS))
          and (CanUseWineFieldSkill(sX, sY)) then
          begin
            O := States.UnitOwner(U);
            if Players[P].PlayersTeam <> Players[O].PlayersTeam then
              E := E + 1;
            if Players[P].PlayersTeam = Players[O].PlayersTeam then
              A := A + 1;
            if (P <> O)
            and (CanUseSkillAgainstUnit(P, U))
            and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
            and (States.KaMRandom > 0.1)
            and (E > A) then 
            begin
              TotemOfAncestors(P, sX, sY);
              Exit;
            end;
          end;
        end;
      end;
    end;

  AIWalk(P);

  if States.GameTime mod 100 = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AICrossbow(P: Integer);
var
  aX, aY, O, U, X, Y, uX, uY, aX1, aX2, aY1, aY2, sX, sY: Integer;
begin

  if (States.KaMRandomI(10) > 5)
  and (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0)
  and not (Players[P].CastingSkill) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - 10) to (aX + 10) do
      for Y := (aY - 10) to (aY + 10) do
      begin
        U := States.UnitAt(X, Y);
        if U > 0 then
        begin
          O := States.UnitOwner(U);
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1) then 
          begin
            uX := States.UnitPositionX(U);
            uY := States.UnitPositionY(U);
            if ((uX = aX) and (uY < (aY - 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              AccurateShot(P, aX, aY, 0);
              Exit;
            end;
            if ((uX = aX) and (uY > (aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              AccurateShot(P, aX, aY, 4);
              Exit;
            end;
            if ((uX < (aX - 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              AccurateShot(P, aX, aY, 6);
              Exit;
            end;
            if ((uX > (aX + 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              AccurateShot(P, aX, aY, 2);
              Exit;
            end;
          end;
        end;
      end;
    end;

  if (States.KaMRandomI(10) > 7)
  and (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - BOMB_RADIUS + 3) to (aX + BOMB_RADIUS - 3) do
      for Y := (aY - BOMB_RADIUS + 3) to (aY + BOMB_RADIUS - 3) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0) then
        begin
          if States.GroupIdle(States.UnitsGroup(U)) then
          begin
            sX := X;
            sY := Y;
          end;
          if not States.GroupIdle(States.UnitsGroup(U)) then
          begin
            case States.UnitDirection(U) of

              0: begin
                   sX := X;
                   sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              1: begin
                   sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              2: begin
                   sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y;
                 end;

              3: begin
                   sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              4: begin
                   sX := X;
                   sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              5: begin
                   sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

              6: begin
                   sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y;
                 end;

              7: begin
                   sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                   sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 end;

            end;
          end;

          if (CanUseSkillAgainstUnit(P, U))
          and (not InRange(sX, aX - 3, aX + 3))
          and (not InRange(sY, aY - 3, aY + 3))
          and (CanUseWineFieldSkill(X, Y)) then
          begin
            O := States.UnitOwner(U);
            if (P <> O)
            and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
            and (States.KaMRandom > 0.1) then 
            begin
              SuddenDeath(P, sX, sY);
              Exit;
            end;
          end;
        end;
      end;
    end;

  if (States.KaMRandomI(10) > 7)
  and (States.KaMRandom < 0.25)
  and (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (States.GameTime > CHOOSE_HERO_TIMER + 100)
  and not (Players[P].CastingSkill) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

      case States.UnitDirection(States.GroupMember(Players[P].Hero, 0)) of

        0, 1: begin
                aX1 := aX;
                aX2 := aX;
                aY1 := MIN_Y;
                aY2 := aY - 1;
              end;

        4, 5: begin
                aX1 := aX;
                aX2 := aX;
                aY1 := aY + 1;
                aY2 := MAX_Y;
              end;

        2, 3: begin
                aX1 := aX + 1;
                aX2 := MAX_X;
                aY1 := aY;
                aY2 := aY;
              end;

        6, 7: begin
                aX1 := MIN_X;
                aX2 := aX - 1;
                aY1 := aY;
                aY2 := aY;
              end;

      end;

      for X := aX1 to aX2 do
      for Y := aY1 to aY2 do
      begin
        if TileOnBattlefield(X, Y) then
          U := States.UnitAt(X, Y);
        if U > 0 then
        begin
          O := States.UnitOwner(U);
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1) then 
          begin
            uX := States.UnitPositionX(U);
            uY := States.UnitPositionY(U);
            if ((uX = aX) and (uY < (aY - 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 1))) then
            begin
              SniperShot(P, aX, aY, 0);
              Exit;
            end;
            if ((uX = aX) and (uY > (aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 4, 5))) then
            begin
              SniperShot(P, aX, aY, 4);
              Exit;
            end;
            if ((uX < (aX - 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 6, 7))) then
            begin
              SniperShot(P, aX, aY, 6);
              Exit;
            end;
            if ((uX > (aX + 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 2, 3))) then
            begin
              SniperShot(P, aX, aY, 2);
              Exit;
            end;
          end;
        end;
      end;
    end;

  AIWalk(P);

  if States.GameTime mod 100 = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AIPikeman(P: Integer);
var
  X, Y, aX, aY, U, O, D, A, E: Integer;
begin

  if (States.KaMRandomI(10) > 5)
  and (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      A := 0;
      E := 0;
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      D := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - VISE_RADIUS + 1) to (aX + VISE_RADIUS - 1) do
      for Y := (aY - VISE_RADIUS + 1) to (aY + VISE_RADIUS - 1) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0) then
        begin
          O := States.UnitOwner(U);
          if Players[P].PlayersTeam <> Players[O].PlayersTeam then
            E := E + 1;
          if Players[P].PlayersTeam = Players[O].PlayersTeam then
            A := A + 1;
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1)
          and (E > A) then 
          begin
            ViseOfDeath(P, aX, aY, D);
            Exit;
          end;
        end;
      end;
    end;

  if (States.KaMRandomI(10) > 7)
  and (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      A := 0;
      E := 0;
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - CONCENTRATION_RADIUS + 1) to (aX + CONCENTRATION_RADIUS - 1) do
      for Y := (aY - CONCENTRATION_RADIUS + 1) to (aY + CONCENTRATION_RADIUS - 1) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0)
        and (not InRange(X, aX - 1, aX + 1))
        and (not InRange(Y, aY - 1, aY + 1)) then
        begin
          O := States.UnitOwner(U);
          if Players[P].PlayersTeam <> Players[O].PlayersTeam then
            E := E + 1;
          if Players[P].PlayersTeam = Players[O].PlayersTeam then
            A := A + 1;
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1)
          and (E > A) then 
          begin
            Concentration(P, aX, aY);
            Exit;
          end;
        end;
      end;
    end;

  AIWalk(P);

  if States.GameTime mod 100 = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AILance(P: Integer);
var
  aX, aY, O, U, X, Y, uX, uY, aX1, aX2, aY1, aY2: Integer;
begin

  if (States.KaMRandomI(10) > 5)
  and (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0)
  and not (Players[P].CastingSkill) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - 8) to (aX + 8) do
      for Y := (aY - 8) to (aY + 8) do
      begin
        U := States.UnitAt(X, Y);
        if U > 0 then
        begin
          O := States.UnitOwner(U);
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1) then 
          begin
            uX := States.UnitPositionX(U);
            uY := States.UnitPositionY(U);
            if ((uX = aX) and (uY < (aY - 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              FieryLance(P, aX, aY, 0);
              Exit;
            end;
            if ((uX = aX) and (uY > (aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              FieryLance(P, aX, aY, 4);
              Exit;
            end;
            if ((uX < (aX - 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              FieryLance(P, aX, aY, 6);
              Exit;
            end;
            if ((uX > (aX + 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 7))) then
            begin
              FieryLance(P, aX, aY, 2);
              Exit;
            end;
          end;
        end;
      end;
    end;

  if (States.KaMRandomI(10) > 7)
  and (States.KaMRandom < 0.25)
  and (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0)
  and not (Players[P].CastingSkill) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := aX - TELEPORT_RADIUS + 2 to aX + TELEPORT_RADIUS - 2 do
      for Y := aY - TELEPORT_RADIUS + 2 to aY + TELEPORT_RADIUS - 2 do
      begin
        U := States.UnitAt(X, Y);
        if U > 0 then
        begin
          O := States.UnitOwner(U);
          if (P <> O)
          and (U <> States.GroupMember(Players[P].Hero, 0))
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1) then
          begin
            case states.KaMRandomI(4) of
              0: Teleport(P, X + 1, Y);
              1: Teleport(P, X - 1, Y);
              2: Teleport(P, X, Y + 1);
              3: Teleport(P, X, Y - 1);
            end;
          end;
        end;
      end;
    end;

  if (States.KaMRandomI(10) > 7)
  and (States.KaMRandom < 0.25)
  and (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0)
  and not (Players[P].CastingSkill) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

      case States.UnitDirection(States.GroupMember(Players[P].Hero, 0)) of

        0, 1: begin
                aX1 := aX - 1;
                aX2 := aX + 1;
                aY1 := aY - 20;
                aY2 := aY - 1;
              end;

        4, 5: begin
                aX1 := aX - 1;
                aX2 := aX + 1;
                aY1 := aY + 1;
                aY2 := aY + 20;
              end;

        2, 3: begin
                aX1 := aX + 1;
                aX2 := aX + 20;
                aY1 := aY - 1;
                aY2 := aY + 1;
              end;

        6, 7: begin
                aX1 := aX - 20;
                aX2 := aX - 1;
                aY1 := aY - 1;
                aY2 := aY + 1;
              end;

      end;

      for X := aX1 to aX2 do
      for Y := aY1 to aY2 do
        if TileOnBattlefield(X, Y) then
        begin
          U := States.UnitAt(X, Y);
          if U > 0 then
          begin
            O := States.UnitOwner(U);
            if (P <> O)
            and (CanUseSkillAgainstUnit(P, U))
            and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
            and (States.KaMRandom > 0.1) then 
            begin
              uX := States.UnitPositionX(U);
              uY := States.UnitPositionY(U);
              if ((InRange(uX, aX - 1, aX + 1)) and (uY < aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 1))) then
              begin
                TenThousandsSpears(P, aX, aY, 0);
                Exit;
              end;
              if ((InRange(uX, aX - 1, aX + 1)) and (uY > aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 4, 5))) then
              begin
                TenThousandsSpears(P, aX, aY, 4);
                Exit;
              end;
              if ((uX < aX) and (InRange(uY, aY - 1, aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 6, 7))) then
              begin
                TenThousandsSpears(P, aX, aY, 6);
                Exit;
              end;
              if ((uX > aX) and (InRange(uY, aY - 1, aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 2, 3))) then
              begin
                TenThousandsSpears(P, aX, aY, 2);
                Exit;
              end;
            end;
        end;
      end;
    end;

  AIWalk(P);

  if States.GameTime mod 100 = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AIWarrior(P: Integer);
var
  aX, aY, O, U, X, Y, uX, uY, aX1, aX2, aY1, aY2: Integer;
begin

  if (States.KaMRandomI(10) > 7)
  and (States.KaMRandom < 0.25)
  and (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0)
  and not (Players[P].CastingSkill) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

      case States.UnitDirection(States.GroupMember(Players[P].Hero, 0)) of

        0, 1: begin
                aX1 := aX - 1;
                aX2 := aX + 1;
                aY1 := aY - 10;
                aY2 := aY - 1;
              end;

        4, 5: begin
                aX1 := aX - 1;
                aX2 := aX + 1;
                aY1 := aY + 1;
                aY2 := aY + 10;
              end;

        2, 3: begin
                aX1 := aX + 1;
                aX2 := aX + 10;
                aY1 := aY - 1;
                aY2 := aY + 1;
              end;

        6, 7: begin
                aX1 := aX - 10;
                aX2 := aX - 1;
                aY1 := aY - 1;
                aY2 := aY + 1;
              end;

      end;

      for X := aX1 to aX2 do
      for Y := aY1 to aY2 do
        if TileOnBattlefield(X, Y) then
        begin
          U := States.UnitAt(X, Y);
          if U > 0 then
          begin
            O := States.UnitOwner(U);
            if (P <> O)
            and (CanUseSkillAgainstUnit(P, U))
            and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
            and (States.KaMRandom > 0.1) then 
            begin
              uX := States.UnitPositionX(U);
              uY := States.UnitPositionY(U);
              if ((InRange(uX, aX - 1, aX + 1)) and (uY < aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 1))) then
              begin
                FierySnake(P, aX, aY, 0);
                Exit;
              end;
              if ((InRange(uX, aX - 1, aX + 1)) and (uY > aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 4, 5))) then
              begin
                FierySnake(P, aX, aY, 4);
                Exit;
              end;
              if ((uX < aX) and (InRange(uY, aY - 1, aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 6, 7))) then
              begin
                FierySnake(P, aX, aY, 6);
                Exit;
              end;
              if ((uX > aX) and (InRange(uY, aY - 1, aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 2, 3))) then
              begin
                FierySnake(P, aX, aY, 2);
                Exit;
              end;
            end;
        end;
      end;
    end;

  if (States.KaMRandomI(10) > 8)
  and (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - ARMOR_RADIUS + 1) to (aX + ARMOR_RADIUS - 1) do
      for Y := (aY - ARMOR_RADIUS + 1) to (aY + ARMOR_RADIUS - 1) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0)
        and (CanUseWineFieldSkill(X, Y)) then
        begin
          O := States.UnitOwner(U);
          if (P <> -1)
          and (CanUseSkillAgainstUnit(P, U))
          and (not Players[O].HeroImmortal)
          and (Players[P].PlayersTeam = Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1) then 
          begin
            SturdyArmor(P, X, Y);
            Exit;
          end;
        end;
      end;
    end;

  if (States.KaMRandomI(10) > 7)
  and (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - SILENCE_RADIUS + 1) to (aX + SILENCE_RADIUS - 1) do
      for Y := (aY - SILENCE_RADIUS + 1) to (aY + SILENCE_RADIUS - 1) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0)
        and (not InRange(X, aX - 1, aX + 1))
        and (not InRange(Y, aY - 1, aY + 1)) then
        begin
          O := States.UnitOwner(U);
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1) then 
          begin
            CircleOfSilence(P, aX, aY);
            Exit;
          end;
        end;
      end;
    end;

  AIWalk(P);

  if States.GameTime mod 100 = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AIBowman(P: Integer);
var
  X, Y, aX, aY, aX1, aY1, aX2, aY2, uX, uY, U, O: Integer;
begin

  if (States.KaMRandomI(10) > 5)
  and (States.KaMRandom < 0.150)
  and (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0)
  and not (Players[P].CastingSkill) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      CatchTheBomb(P, aX, aY, States.UnitDirection(States.GroupMember(Players[P].Hero, 0)));
      Exit;
    end;

  if (States.KaMRandomI(10) > 8)
  and (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - PRISON_RADIUS + 1) to (aX + PRISON_RADIUS - 1) do
      for Y := (aY - PRISON_RADIUS + 1) to (aY + PRISON_RADIUS - 1) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0)
        and (CanUseWineFieldSkill(X, Y)) then
        begin
          O := States.UnitOwner(U);
          if (P <> O)
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (not Players[O].HeroImmortal)
          and (States.KaMRandom > 0.1) then 
          begin
            Prison(P, X, Y);
            Exit;
          end;
        end;
      end;
    end;

  if (States.KaMRandomI(10) > 7)
  and (States.KaMRandom < 0.4)
  and (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (States.GameTime > CHOOSE_HERO_TIMER + 100)
  and not (Players[P].CastingSkill) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

      case States.UnitDirection(States.GroupMember(Players[P].Hero, 0)) of

        0, 1: begin
                aX1 := aX;
                aX2 := aX;
                aY1 := aY - 19;
                aY2 := aY - 1;
              end;

        4, 5: begin
                aX1 := aX;
                aX2 := aX;
                aY1 := aY + 1;
                aY2 := aY + 19;
              end;

        2, 3: begin
                aX1 := aX + 1;
                aX2 := aX + 19;
                aY1 := aY;
                aY2 := aY;
              end;

        6, 7: begin
                aX1 := aX - 19;
                aX2 := aX - 1;
                aY1 := aY;
                aY2 := aY;
              end;

      end;

      for X := aX1 to aX2 do
      for Y := aY1 to aY2 do
      begin
        if TileOnBattlefield(X, Y) then
          U := States.UnitAt(X, Y);
        if U > 0 then
        begin
          O := States.UnitOwner(U);
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1) then 
          begin
            uX := States.UnitPositionX(U);
            uY := States.UnitPositionY(U);
            if ((uX = aX) and (uY < (aY - 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 1))) then
            begin
              RevengeFromNowhere(P, aX, aY, 0);
              Exit;
            end;
            if ((uX = aX) and (uY > (aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 4, 5))) then
            begin
              RevengeFromNowhere(P, aX, aY, 4);
              Exit;
            end;
            if ((uX < (aX - 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 6, 7))) then
            begin
              RevengeFromNowhere(P, aX, aY, 6);
              Exit;
            end;
            if ((uX > (aX + 1)) and (uY = aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 2, 3))) then
            begin
              RevengeFromNowhere(P, aX, aY, 2);
              Exit;
            end;
          end;
        end;
      end;
    end;

  AIWalk(P);

  if States.GameTime mod 100 = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

  Exit;

end;


procedure OnTick;
var
  N: array[0..16] of Integer;
  S: Integer;
begin

  CheckRuneTime;

  GoOutFromRune;

  if States.GameTime mod ZOMBIE_ATTACK_FACTOR = 0 then
    ZombieAttack;

  if States.GameTime mod 10 = 0 then
    CheckImmortal;

  if (DeathX > 0)
  and (DeathY > 0) then
    if States.MapTileObject(DeathX, DeathY) = BOWMAN_MINE then
      Actions.MapTileObjectSet(DeathX, DeathY, 255);

  if States.MapTileObject(RUNE_X, RUNE_Y) = 255 then
    Actions.MapTileObjectSet(RUNE_X, RUNE_Y, RUNE_BLOCK_OBJ);

  for I := 0 to 7 do
  begin
    CheckDelays(I);
    CheckStolenSkillTime(I);
  end;

  for N[13] := 0 to 11 do
    if (States.PlayerEnabled(N[13])) then
      if TilesRoadLength[N[13]] > 0 then
        CheckTileRoadObjects(N[13]);

  for N[14] := 0 to 11 do
      if TilesFieldLength[N[14]] > 0 then
        CheckTileFieldObjects(N[14]);

  for N[15] := 0 to 11 do
      if TilesWineLength[N[15]] > 0 then
        CheckTileWineObjects(N[15]);

  for I := 0 to 7 do
    if Players[I].Hero > 0 then
      CheckTiles(I);

  CheckTilesForAI;

  for N[0] := 0 to 7 do
    CheckRageCircles(N[0]);

  for N[1] := 0 to 7 do
    CheckExpCircles(N[1]);

  for N[2] := 0 to 7 do
    CheckConcentrationCircles(N[2]);

  for N[3] := 0 to 7 do
    CheckViseCircles(N[3]);

  for N[4] := 0 to 7 do
    CheckTotemCircles(N[4]);

  for N[5] := 0 to 7 do
    CheckGravityCircles(N[5]);

  for N[6] := 0 to 7 do
    CheckFireworks1Circles(N[6]);

  for N[7] := 0 to 7 do
    CheckFireworks2Circles(N[7]);

  for N[8] := 0 to 7 do
    CheckFireworks3Circles(N[8]);

  for N[9] := 0 to 7 do
    CheckFireworks4Circles(N[9]);

  for N[10] := 0 to 7 do
    CheckFireworks5Circles(N[10]);

  for N[11] := 0 to 7 do
    CheckVagaCircles(N[11]);

  for N[12] := 0 to 7 do
    CheckKnightCircles(N[12]);

  for N[12] := 0 to 7 do
    CheckRogueCircles(N[12]);

  if States.GameTime > CHOOSE_HERO_TIMER then
  begin
    TeamInfo[0] := '';
    TeamInfo[1] := '';
    for I := 0 to 3 do
      if States.PlayerEnabled(I) then
        TeamInfo[0] := TeamInfo[0] + '|[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]: <$42>: ' + States.UnitTypeName(Players[I].HeroType) + '; <$39>: ' + HPColor(I) + IntToStr(Players[I].HP);
    for I := 4 to 7 do
      if States.PlayerEnabled(I) then
        TeamInfo[1] := TeamInfo[1] + '|[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]: <$42>: ' + States.UnitTypeName(Players[I].HeroType) + '; <$39>: ' + HPColor(I) + IntToStr(Players[I].HP);
  end;

  for I := 0 to 3 do
    if (States.PlayerEnabled(I))
    and (Players[I].HeroChosen)
    and (States.GameTime > CHOOSE_HERO_TIMER) then
    begin
      Actions.OverlayTextSet(I, '<$33> [$ADAF67]' + States.UnitTypeName(Players[I].HeroType) + '[]!'
      + '||<$35>: ' + RoadSkillName(I, Players[I].HeroType) + '. <$34>: ' + IntToStr(Players[I].RoadSkillDelay/10)
      + '|<$36>: ' + FieldSkillName(I, Players[I].HeroType) + '. <$34>: ' + IntToStr(Players[I].FieldSkillDelay/10)
      + '|<$37>: ' + WineSkillName(I, Players[I].HeroType) + '. <$34>: ' + IntToStr(Players[I].WineSkillDelay/10)
      + '|<$39>: ' + HPColor(I) + IntToStr(Players[I].HP) + '[]|' + '|<$45>: ' + IntToStr(RuneTime/10) + '|'
      + StatusText(I) + '|||<$41>:|' + TeamInfo[0]);
    end;

  for I := 4 to 7 do
    if (States.PlayerEnabled(I))
    and (Players[I].HeroChosen)
    and (States.GameTime > CHOOSE_HERO_TIMER) then
    begin
      Actions.OverlayTextSet(I, '<$33> [$ADAF67]' + States.UnitTypeName(Players[I].HeroType) + '[]!'
      + '||<$35>: ' + RoadSkillName(I, Players[I].HeroType) + '. <$34>: ' + IntToStr(Players[I].RoadSkillDelay/10)
      + '|<$36>: ' + FieldSkillName(I, Players[I].HeroType) + '. <$34>: ' + IntToStr(Players[I].FieldSkillDelay/10)
      + '|<$37>: ' + WineSkillName(I, Players[I].HeroType) + '. <$34>: ' + IntToStr(Players[I].WineSkillDelay/10)
      + '|<$39>: ' + HPColor(I) + IntToStr(Players[I].HP) + '[]|' + '|<$45>: ' + IntToStr(RuneTime/10) + '|'
      + StatusText(I) + '|||<$41>:|' + TeamInfo[1]);
    end;

  if States.GameTime mod 12000 = 0 then
    AutoFeed;

  CheckStatus;

  if States.GameTime < CHOOSE_HERO_TIMER then
  begin
    Actions.OverlayTextSet(-1, '<$38>: ' + IntToStr((CHOOSE_HERO_TIMER - States.GameTime) / 10) + ' (<$40>)|');
    for I := 0 to 3 do
      if States.PlayerEnabled(I) then
        Actions.OverlayTextAppend(I, TeamChoice[0]);

    for I := 4 to 7 do
      if States.PlayerEnabled(I) then
        Actions.OverlayTextAppend(I, TeamChoice[1]);
  end;

  if States.GameTime = CHOOSE_HERO_TIMER then
    SetHeroes;

  if States.GameTime > CHOOSE_HERO_TIMER then
    CheckVictoryDefeat;

  if States.GameTime mod ZOMBIE_STORM_TIME = 0 then
    AIStorm;

  ClearArrays;

  if States.GameTime mod PLANT_TREES_TIME = 0 then
    PlantTrees;

  for I := 0 to 11 do
    if (States.GameTime mod AVOID_FACTOR = 0)
    and (States.Gametime > CHOOSE_HERO_TIMER) then
      AvoidDanger(I);

  if not DEBUG_MODE then
    for I := 0 to 7 do
      if States.PlayerEnabled(I) then
        if (States.PlayerIsAI(I))
        and (States.GameTime = Players[I].AIChoiceTime) then
          AIHeroChoice(I);

  for I := 0 to 7 do
    if States.Gametime > CHOOSE_HERO_TIMER then
    begin
      if States.GameTime = Players[I].DefenceTime then
        ClearDefence(I);

      if States.GameTime = Players[I].ClearPikeObjTime then
        ClearPikeObj(I);

      if States.GameTime = Players[I].SkillCastRespawnTime then
        RespawnUnit(I);

      if States.PlayerEnabled(I) then
        RepeatRespawn(I);

      CheckRespawn(I);

      for S := 0 to (SPURT_LENGTH - 1) do
        CheckSpurt(I, S);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 16) then
            AISword(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 23) then
            AIBarb(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 18) then
            AICrossbow(I);

      {if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 20) then
            AIPikeman(I);}

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 19) then
            AILance(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 26) then
            AIWarrior(I);

      {if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 17) then
            AIBowman(I);}

    end;

end;